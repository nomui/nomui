function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
/**
 *
 *       nomui v1.9.0
 *       License: MIT
 *       Copyright (c) 2021-2021, Wetrial
 *
 */ (function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      factory((global.nomui = {})));
})(this, function (exports) {
  "use strict";
  /* eslint-disable */ /**!
   * Sortable 1.13.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   */ function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj &&
          typeof Symbol === "function" &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? "symbol"
          : typeof obj;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true,
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends =
      Object.assign ||
      function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
    return _extends.apply(this, arguments);
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(
          Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          })
        );
      }
      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _toConsumableArray(arr) {
    return (
      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
    );
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    }
  }
  function _iterableToArray(iter) {
    if (
      Symbol.iterator in Object(iter) ||
      Object.prototype.toString.call(iter) === "[object Arguments]"
    )
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  var version = "1.13.0";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));
    }
  }
  var IE11OrLess = userAgent(
    /(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i
  );
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari =
    userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = { capture: false, passive: false };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function matches(/**HTMLElement*/ el, /**String*/ selector) {
    if (!selector) return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType
      ? el.host
      : el.parentNode;
  }
  function closest(
    /**HTMLElement*/ el,
    /**String*/ selector,
    /**HTMLElement*/ ctx,
    includeCTX
  ) {
    if (el) {
      ctx = ctx || document;
      do {
        if (
          (selector != null &&
            (selector[0] === ">"
              ? el.parentNode === ctx && matches(el, selector)
              : matches(el, selector))) ||
          (includeCTX && el === ctx)
        ) {
          return el;
        }
        if (el === ctx) break; /* jshint boss:true */
      } while ((el = getParentOrHost(el)));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name);
      } else {
        var className = (" " + el.className + " ")
          .replace(R_SPACE, " ")
          .replace(" " + name + " ", " ");
        el.className = (className + (state ? " " + name : "")).replace(
          R_SPACE,
          " "
        );
      }
    }
  }
  function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        } /* jshint boss:true */
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn =
      window.DOMMatrix ||
      window.WebKitCSSMatrix ||
      window.CSSMatrix ||
      window.MSCSSMatrix;
    /*jshint -W056 */ return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */ function getRect(
    el,
    relativeToContainingBlock,
    relativeToNonStaticParent,
    undoScale,
    container
  ) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if (
      (relativeToContainingBlock || relativeToNonStaticParent) &&
      el !== window
    ) {
      // Adjust for translate()
      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11
      if (!IE11OrLess) {
        do {
          if (
            container &&
            container.getBoundingClientRect &&
            (css(container, "transform") !== "none" ||
              (relativeToNonStaticParent &&
                css(container, "position") !== "static"))
          ) {
            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container
            top -=
              containerRect.top + parseInt(css(container, "border-top-width"));
            left -=
              containerRect.left +
              parseInt(css(container, "border-left-width"));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          } /* jshint boss:true */
        } while ((container = container.parentNode));
      }
    }
    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }
    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height,
    };
  }
  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */ function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
    /* jshint boss:true */ while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */ function getChild(el, childNum, options) {
    var currentChild = 0,
      i = 0,
      children = el.children;
    while (i < children.length) {
      if (
        children[i].style.display !== "none" &&
        children[i] !== Sortable.ghost &&
        children[i] !== Sortable.dragged &&
        closest(children[i], options.draggable, el, false)
      ) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */ function lastChild(el, selector) {
    var last = el.lastElementChild;
    while (
      last &&
      (last === Sortable.ghost ||
        css(last, "display") === "none" ||
        (selector && !matches(last, selector)))
    ) {
      last = last.previousElementSibling;
    }
    return last || null;
  }
  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */ function index$1(el, selector) {
    var index = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    /* jshint boss:true */ while ((el = el.previousElementSibling)) {
      if (
        el.nodeName.toUpperCase() !== "TEMPLATE" &&
        el !== Sortable.clone &&
        (!selector || matches(el, selector))
      ) {
        index++;
      }
    }
    return index;
  }
  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */ function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */ function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
          return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (
        elem.clientWidth < elem.scrollWidth ||
        elem.clientHeight < elem.scrollHeight
      ) {
        var elemCSS = css(elem);
        if (
          (elem.clientWidth < elem.scrollWidth &&
            (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll")) ||
          (elem.clientHeight < elem.scrollHeight &&
            (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll"))
        ) {
          if (!elem.getBoundingClientRect || elem === document.body)
            return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      } /* jshint boss:true */
    } while ((elem = elem.parentNode));
    return getWindowScrollingElement();
  }
  function extend$1(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return (
      Math.round(rect1.top) === Math.round(rect2.top) &&
      Math.round(rect1.left) === Math.round(rect2.left) &&
      Math.round(rect1.height) === Math.round(rect2.height) &&
      Math.round(rect1.width) === Math.round(rect2.width)
    );
  }
  var _throttleTimeout;
  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
          _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }
  function clone$1(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function setRect(el, rect) {
    css(el, "position", "absolute");
    css(el, "top", rect.top);
    css(el, "left", rect.left);
    css(el, "width", rect.width);
    css(el, "height", rect.height);
  }
  function unsetRect(el) {
    css(el, "position", "");
    css(el, "top", "");
    css(el, "left", "");
    css(el, "width", "");
    css(el, "height", "");
  }
  var expando = "Sortable" + new Date().getTime();
  function AnimationStateManager() {
    var animationStates = [],
      animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, "display") === "none" || child === Sortable.ghost)
            return;
          animationStates.push({ target: child, rect: getRect(child) });
          var fromRect = _objectSpread(
            {},
            animationStates[animationStates.length - 1].rect
          ); // If animating: compensate for current animation
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(
          indexOfObject(animationStates, { target: target }),
          1
        );
      },
      animateAll: function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === "function") callback();
          return;
        }
        var animating = false,
          animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);
          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (
              isRectEqual(prevFromRect, toRect) &&
              !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
              (animatingRect.top - toRect.top) /
                (animatingRect.left - toRect.left) ===
                (fromRect.top - toRect.top) / (fromRect.left - toRect.left)
            ) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(
                animatingRect,
                prevFromRect,
                prevToRect,
                _this.options
              );
            }
          } // if fromRect != toRect: animate
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === "function") callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === "function") callback();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(
            target,
            "transform",
            "translate3d(" + translateX + "px," + translateY + "px,0)"
          );
          this.forRepaintDummy = repaint(target); // repaint
          css(
            target,
            "transition",
            "transform " +
              duration +
              "ms" +
              (this.options.easing ? " " + this.options.easing : "")
          );
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      },
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return (
      (Math.sqrt(
        Math.pow(fromRect.top - animatingRect.top, 2) +
          Math.pow(fromRect.left - animatingRect.left, 2)
      ) /
        Math.sqrt(
          Math.pow(fromRect.top - toRect.top, 2) +
            Math.pow(fromRect.left - toRect.left, 2)
        )) *
      options.animation
    );
  }
  var plugins = [];
  var defaults = { initializeByDefault: true };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }
      plugins.forEach(function (p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(
            plugin.pluginName,
            " more than once"
          );
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function () {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](
            _objectSpread({ sortable: sortable }, evt)
          );
        } // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined
        if (
          sortable.options[plugin.pluginName] &&
          sortable[plugin.pluginName][eventName]
        ) {
          sortable[plugin.pluginName][eventName](
            _objectSpread({ sortable: sortable }, evt)
          );
        }
      });
    },
    initializePlugins: function initializePlugins(
      sortable,
      el,
      defaults,
      options
    ) {
      plugins.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault)
          return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized; // Add default options from plugin
        _extends(defaults, initialized.defaults);
      });
      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(
          sortable,
          option,
          sortable.options[option]
        );
        if (typeof modified !== "undefined") {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== "function") return;
        _extends(
          eventProperties,
          plugin.eventProperties.call(sortable[plugin.pluginName], name)
        );
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
        if (
          plugin.optionListeners &&
          typeof plugin.optionListeners[name] === "function"
        ) {
          modifiedValue = plugin.optionListeners[name].call(
            sortable[plugin.pluginName],
            value
          );
        }
      });
      return modifiedValue;
    },
  };
  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || (rootEl && rootEl[expando]);
    if (!sortable) return;
    var evt,
      options = sortable.options,
      onName = "on" + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, { bubbles: true, cancelable: true });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
    var allEventProperties = _objectSpread(
      {},
      extraEventProperties,
      PluginManager.getEventProperties(name, sortable)
    );
    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }
    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);
    PluginManager.pluginEvent.bind(Sortable)(
      eventName,
      sortable,
      _objectSpread(
        {
          dragEl: dragEl,
          parentEl: parentEl,
          ghostEl: ghostEl,
          rootEl: rootEl,
          nextEl: nextEl,
          lastDownEl: lastDownEl,
          cloneEl: cloneEl,
          cloneHidden: cloneHidden,
          dragStarted: moved,
          putSortable: putSortable,
          activeSortable: Sortable.active,
          originalEvent: originalEvent,
          oldIndex: oldIndex,
          oldDraggableIndex: oldDraggableIndex,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          hideGhostForTarget: _hideGhostForTarget,
          unhideGhostForTarget: _unhideGhostForTarget,
          cloneNowHidden: function cloneNowHidden() {
            cloneHidden = true;
          },
          cloneNowShown: function cloneNowShown() {
            cloneHidden = false;
          },
          dispatchSortableEvent: function dispatchSortableEvent(name) {
            _dispatchEvent({
              sortable: sortable,
              name: name,
              originalEvent: originalEvent,
            });
          },
        },
        data
      )
    );
  };
  function _dispatchEvent(info) {
    dispatchEvent(
      _objectSpread(
        {
          putSortable: putSortable,
          cloneEl: cloneEl,
          targetEl: dragEl,
          rootEl: rootEl,
          oldIndex: oldIndex,
          oldDraggableIndex: oldDraggableIndex,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
        },
        info
      )
    );
  }
  var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance, // For positioning ghost absolutely
    ghostRelativeParent,
    ghostRelativeParentInitialScroll = [], // (left, top)
    _silent = false,
    savedInputChecked = [];
  /** @const */ var documentExists = typeof document !== "undefined",
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", // This will not pass for IE9, because IE9 DnD only works on anchors
    supportDraggable =
      documentExists &&
      !ChromeForAndroid &&
      !IOS &&
      "draggable" in document.createElement("div"),
    supportCssPointerEvents = (function () {
      if (!documentExists) return; // false when <= IE11
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement("x");
      el.style.cssText = "pointer-events:auto";
      return el.style.pointerEvents === "auto";
    })(),
    _detectDirection = function _detectDirection(el, options) {
      var elCSS = css(el),
        elWidth =
          parseInt(elCSS.width) -
          parseInt(elCSS.paddingLeft) -
          parseInt(elCSS.paddingRight) -
          parseInt(elCSS.borderLeftWidth) -
          parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth =
          firstChildCSS &&
          parseInt(firstChildCSS.marginLeft) +
            parseInt(firstChildCSS.marginRight) +
            getRect(child1).width,
        secondChildWidth =
          secondChildCSS &&
          parseInt(secondChildCSS.marginLeft) +
            parseInt(secondChildCSS.marginRight) +
            getRect(child2).width;
      if (elCSS.display === "flex") {
        return elCSS.flexDirection === "column" ||
          elCSS.flexDirection === "column-reverse"
          ? "vertical"
          : "horizontal";
      }
      if (elCSS.display === "grid") {
        return elCSS.gridTemplateColumns.split(" ").length <= 1
          ? "vertical"
          : "horizontal";
      }
      if (
        child1 &&
        firstChildCSS["float"] &&
        firstChildCSS["float"] !== "none"
      ) {
        var touchingSideChild2 =
          firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 &&
          (secondChildCSS.clear === "both" ||
            secondChildCSS.clear === touchingSideChild2)
          ? "vertical"
          : "horizontal";
      }
      return child1 &&
        (firstChildCSS.display === "block" ||
          firstChildCSS.display === "flex" ||
          firstChildCSS.display === "table" ||
          firstChildCSS.display === "grid" ||
          (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none") ||
          (child2 &&
            elCSS[CSSFloatProperty] === "none" &&
            firstChildWidth + secondChildWidth > elWidth))
        ? "vertical"
        : "horizontal";
    },
    _dragElInRowColumn = function _dragElInRowColumn(
      dragRect,
      targetRect,
      vertical
    ) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
      return (
        dragElS1Opp === targetS1Opp ||
        dragElS2Opp === targetS2Opp ||
        dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2
      );
    },
    /**
     * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
     * @param  {Number} x      X position
     * @param  {Number} y      Y position
     * @return {HTMLElement}   Element of the first found nearest Sortable
     */ _detectNearestEmptySortable = function _detectNearestEmptySortable(
      x,
      y
    ) {
      var ret;
      sortables.some(function (sortable) {
        if (lastChild(sortable)) return;
        var rect = getRect(sortable),
          threshold = sortable[expando].options.emptyInsertThreshold,
          insideHorizontally =
            x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically =
            y >= rect.top - threshold && y <= rect.bottom + threshold;
        if (threshold && insideHorizontally && insideVertically) {
          return (ret = sortable);
        }
      });
      return ret;
    },
    _prepareGroup = function _prepareGroup(options) {
      function toFn(value, pull) {
        return function (to, from, dragEl, evt) {
          var sameGroup =
            to.options.group.name &&
            from.options.group.name &&
            to.options.group.name === from.options.group.name;
          if (value == null && (pull || sameGroup)) {
            // Default pull value
            // Default pull and put value if same group
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === "clone") {
            return value;
          } else if (typeof value === "function") {
            return toFn(value(to, from, dragEl, evt), pull)(
              to,
              from,
              dragEl,
              evt
            );
          } else {
            var otherGroup = (pull ? to : from).options.group.name;
            return (
              value === true ||
              (typeof value === "string" && value === otherGroup) ||
              (value.join && value.indexOf(otherGroup) > -1)
            );
          }
        };
      }
      var group = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof(originalGroup) != "object") {
        originalGroup = { name: originalGroup };
      }
      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    },
    _hideGhostForTarget = function _hideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "none");
      }
    },
    _unhideGhostForTarget = function _unhideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "");
      }
    }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position
  if (documentExists) {
    document.addEventListener(
      "click",
      function (evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      },
      true
    );
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(
    evt
  ) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        // Create imitation event
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */ function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat(
        {}.toString.call(el)
      );
    }
    this.el = el; // root element
    this.options = options = _extends({}, options); // Export instance
    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1, // percentage; 0 <= x <= 1
      invertSwap: false, // invert always
      invertedSwapThreshold: null, // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData("Text", dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold:
        (Number.parseInt ? Number : window).parseInt(
          window.devicePixelRatio,
          10
        ) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: { x: 0, y: 0 },
      supportPointer:
        Sortable.supportPointer !== false &&
        "PointerEvent" in window &&
        !Safari,
      emptyInsertThreshold: 5,
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options
    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }
    _prepareGroup(options); // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    } // Setup drag mode
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    } // Bind events
    if (options.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el); // Restore sorting
    options.store &&
      options.store.get &&
      this.sort(options.store.get(this) || []); // Add animation state manager
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */ {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function"
        ? this.options.direction.call(this, evt, target, dragEl)
        : this.options.direction;
    },
    _onTapStart: function _onTapStart(/** Event|TouchEvent */ evt) {
      if (!evt.cancelable) return;
      var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch =
          (evt.touches && evt.touches[0]) ||
          (evt.pointerType && evt.pointerType === "touch" && evt),
        target = (touch || evt).target,
        originalTarget =
          (evt.target.shadowRoot &&
            ((evt.path && evt.path[0]) ||
              (evt.composedPath && evt.composedPath()[0]))) ||
          target,
        filter = options.filter;
      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
      if (dragEl) {
        return;
      }
      if (
        (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||
        options.disabled
      ) {
        return; // only left button and enabled
      } // cancel dnd if original target is content editable
      if (originalTarget.isContentEditable) {
        return;
      } // Safari ignores further event handling after mousedown
      if (
        !this.nativeDraggable &&
        Safari &&
        target &&
        target.tagName.toUpperCase() === "SELECT"
      ) {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      } // Get the index of the dragged element within its parent
      oldIndex = index$1(target);
      oldDraggableIndex = index$1(target, options.draggable); // Check filter
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el,
          });
          pluginEvent("filter", _this, { evt: evt });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(",").some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el,
            });
            pluginEvent("filter", _this, { evt: evt });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      }
      if (
        options.handle &&
        !closest(originalTarget, options.handle, el, false)
      ) {
        return;
      } // Prepare `dragstart`
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(
      /** Event */ evt,
      /** Touch */ touch,
      /** HTMLElement */ target
    ) {
      var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY,
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn() {
          pluginEvent("delayEnded", _this, { evt: evt });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          } // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          } // Bind the events: dragstart/dragend
          _this._triggerDragStart(evt, touch); // Drag start event
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt,
          }); // Chosen item
          toggleClass(dragEl, options.chosenClass, true);
        }; // Disable "draggable"
        options.ignore.split(",").forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent("delayStart", this, { evt: evt }); // Delay is impossible for native DnD in Edge or IE
        if (
          options.delay &&
          (!options.delayOnTouchOnly || touch) &&
          (!this.nativeDraggable || !(Edge || IE11OrLess))
        ) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          } // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer &&
            on(
              ownerDocument,
              "pointermove",
              _this._delayedDragTouchMoveHandler
            );
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
      /** TouchEvent|PointerEvent **/ e
    ) {
      var touch = e.touches ? e.touches[0] : e;
      if (
        Math.max(
          Math.abs(touch.clientX - this._lastX),
          Math.abs(touch.clientY - this._lastY)
        ) >=
        Math.floor(
          this.options.touchStartThreshold /
            ((this.nativeDraggable && window.devicePixelRatio) || 1)
        )
      ) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(
      /** Event */ evt,
      /** Touch */ touch
    ) {
      touch = touch || (evt.pointerType == "touch" && evt);
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          // Timeout neccessary for IE9
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent("dragStarted", this, { evt: evt });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options; // Apply effect
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost(); // Drag start event
        _dispatchEvent({ sortable: this, name: "start", originalEvent: evt });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(
          touchEvt.clientX,
          touchEvt.clientY
        );
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(
            touchEvt.clientX,
            touchEvt.clientY
          );
          if (target === parent) break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent,
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent; // store last element
          } while (/* jshint boss:true */ (parent = parent.parentNode));
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(/**TouchEvent*/ evt) {
      if (tapEvt) {
        var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset =
            PositionGhostAbsolutely &&
            ghostRelativeParent &&
            getRelativeScrollOffset(ghostRelativeParent),
          dx =
            (touch.clientX - tapEvt.clientX + fallbackOffset.x) /
              (scaleX || 1) +
            (relativeScrollOffset
              ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]
              : 0) /
              (scaleX || 1),
          dy =
            (touch.clientY - tapEvt.clientY + fallbackOffset.y) /
              (scaleY || 1) +
            (relativeScrollOffset
              ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]
              : 0) /
              (scaleY || 1); // only set the status to dragging, when we are actually dragging
        if (!Sortable.active && !awaitingDragStarted) {
          if (
            fallbackTolerance &&
            Math.max(
              Math.abs(touch.clientX - this._lastX),
              Math.abs(touch.clientY - this._lastY)
            ) < fallbackTolerance
          ) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = { a: 1, b: 0, c: 0, d: 1, e: dx, f: dy };
          }
          var cssMatrix = "matrix("
            .concat(ghostMatrix.a, ",")
            .concat(ghostMatrix.b, ",")
            .concat(ghostMatrix.c, ",")
            .concat(ghostMatrix.d, ",")
            .concat(ghostMatrix.e, ",")
            .concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(
            dragEl,
            true,
            PositionGhostAbsolutely,
            true,
            container
          ),
          options = this.options; // Position absolutely
        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;
          while (
            css(ghostRelativeParent, "position") === "static" &&
            css(ghostRelativeParent, "transform") === "none" &&
            ghostRelativeParent !== document
          ) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (
            ghostRelativeParent !== document.body &&
            ghostRelativeParent !== document.documentElement
          ) {
            if (ghostRelativeParent === document)
              ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(
            ghostRelativeParent
          );
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(
          ghostEl,
          "position",
          PositionGhostAbsolutely ? "absolute" : "fixed"
        );
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl); // Set transform-origin
        css(
          ghostEl,
          "transform-origin",
          (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +
            "% " +
            (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +
            "%"
        );
      }
    },
    _onDragStart: function _onDragStart(/**Event*/ evt, /**boolean*/ fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent("dragStart", this, { evt: evt });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone$1(dragEl);
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      } // #1143: IFrame support workaround
      _this.cloneId = _nextTick(function () {
        pluginEvent("clone", _this);
        if (Sortable.eventCanceled) return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({ sortable: _this, name: "clone" });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this); // #1276 fix:
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(
        _this._dragStarted.bind(_this, fallback, evt)
      );
      on(document, "selectstart", _this);
      moved = true;
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    }, // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(/**Event*/ evt) {
      var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;
      if (_silent) return;
      function dragOverEvent(name, extra) {
        pluginEvent(
          name,
          _this,
          _objectSpread(
            {
              evt: evt,
              isOwner: isOwner,
              axis: vertical ? "vertical" : "horizontal",
              revert: revert,
              dragRect: dragRect,
              targetRect: targetRect,
              canSort: canSort,
              fromSortable: fromSortable,
              target: target,
              completed: completed,
              onMove: function onMove(target, after) {
                return _onMove(
                  rootEl,
                  el,
                  dragEl,
                  dragRect,
                  target,
                  getRect(target),
                  evt,
                  after
                );
              },
              changed: changed,
            },
            extra
          )
        );
      } // Capture animation state
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      } // Return invocation when dragEl is inserted (or completed)
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", { insertion: insertion });
        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(
              dragEl,
              putSortable
                ? putSortable.options.ghostClass
                : activeSortable.options.ghostClass,
              false
            );
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          } // Animation
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function () {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        } // Null lastTarget if it is not inside a previously swapped element
        if (
          (target === dragEl && !dragEl.animated) ||
          (target === el && !target.animated)
        ) {
          lastTarget = null;
        } // no bubbling and not fallback
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return (completedFired = true);
      } // Call when dragEl has been inserted
      function changed() {
        newIndex = index$1(dragEl);
        newDraggableIndex = index$1(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt,
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled) return completedFired;
      if (
        dragEl.contains(evt.target) ||
        (target.animated && target.animatingX && target.animatingY) ||
        _this._ignoreWhileAnimating === target
      ) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (
        activeSortable &&
        !options.disabled &&
        (isOwner
          ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
          : putSortable === this ||
            ((this.lastPutMode = activeGroup.checkPull(
              this,
              activeSortable,
              dragEl,
              evt
            )) &&
              group.checkPut(this, activeSortable, dragEl, evt)))
      ) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled) return completedFired;
        if (revert) {
          parentEl = rootEl; // actualization
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (
          !elLastChild ||
          (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)
        ) {
          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          } // assign target only if condition is true
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (
            _onMove(
              rootEl,
              el,
              dragEl,
              dragRect,
              target,
              targetRect,
              evt,
              !!target
            ) !== false
          ) {
            capture();
            el.appendChild(dragEl);
            parentEl = el; // actualization
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(
              (dragEl.animated && dragEl.toRect) || dragRect,
              (target.animated && target.toRect) || targetRect,
              vertical
            ),
            side1 = vertical ? "top" : "left",
            scrolledPastTop =
              isScrolledPast(target, "top", "top") ||
              isScrolledPast(dragEl, "top", "top"),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert =
              (!differentRowCol && options.invertSwap) || differentLevel;
          }
          direction = _getSwapDirection(
            evt,
            target,
            targetRect,
            vertical,
            differentRowCol ? 1 : options.swapThreshold,
            options.invertedSwapThreshold == null
              ? options.swapThreshold
              : options.invertedSwapThreshold,
            isCircumstantialInvert,
            lastTarget === target
          );
          var sibling;
          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index$1(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (
              sibling &&
              (css(sibling, "display") === "none" || sibling === ghostEl)
            );
          } // If dragEl is already beside target: Do not insert
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
            after = false;
          after = direction === 1;
          var moveVector = _onMove(
            rootEl,
            el,
            dragEl,
            dragRect,
            target,
            targetRect,
            evt,
            after
          );
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(
                dragEl,
                after ? nextSibling : target
              );
            } // Undo chrome's scroll adjustment (has no effect on other browsers)
            if (scrolledPastTop) {
              scrollBy(
                scrolledPastTop,
                0,
                scrollBefore - scrolledPastTop.scrollTop
              );
            }
            parentEl = dragEl.parentNode; // actualization
            // must be done before animation
            if (
              targetBeforeFirstSwap !== undefined &&
              !isCircumstantialInvert
            ) {
              targetMoveDistance = Math.abs(
                targetBeforeFirstSwap - getRect(target)[side1]
              );
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(/**Event*/ evt) {
      var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      pluginEvent("drop", this, { evt: evt });
      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId); // Unbind events
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl &&
          ghostEl.parentNode &&
          ghostEl.parentNode.removeChild(ghostEl);
        if (
          rootEl === parentEl ||
          (putSortable && putSortable.lastPutMode !== "clone")
        ) {
          // Remove clone(s)
          cloneEl &&
            cloneEl.parentNode &&
            cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = ""; // Remove classes
          // ghostClass is added in dragStarted
          if (moved && !awaitingDragStarted) {
            toggleClass(
              dragEl,
              putSortable
                ? putSortable.options.ghostClass
                : this.options.ghostClass,
              false
            );
          }
          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt,
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt,
              }); // Remove event
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt,
              }); // drag from one list and drop into another
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt,
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt,
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt,
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt,
                });
              }
            }
          }
          if (Sortable.active) {
            /* jshint eqnull:true */ if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt,
            }); // Save sorting
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(/**Event*/ evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */ toArray: function toArray() {
      var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;
      for (; i < n; i++) {
        el = children[i];
        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */ sort: function sort(order, useAnimation) {
      var items = {},
        rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];
        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */ save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */ closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */ option: function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);
        if (typeof modifiedValue !== "undefined") {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }
        if (name === "group") {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */ destroy: function destroy() {
      pluginEvent("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      } // Remove draggable attributes
      Array.prototype.forEach.call(
        el.querySelectorAll("[draggable]"),
        function (el) {
          el.removeAttribute("draggable");
        }
      );
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent("hideClone", this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent("showClone", this);
        if (Sortable.eventCanceled) return; // show clone at dragEl or original position
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    },
  };
  function _globalDragOver(/**Event*/ evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(
    fromEl,
    toEl,
    dragEl,
    dragRect,
    targetEl,
    targetRect,
    originalEvent,
    willInsertAfter
  ) {
    var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", { bubbles: true, cancelable: true });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical
      ? evt.clientX > rect.right + spacer ||
          (evt.clientX <= rect.right &&
            evt.clientY > rect.bottom &&
            evt.clientX >= rect.left)
      : (evt.clientX > rect.right && evt.clientY > rect.top) ||
          (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);
  }
  function _getSwapDirection(
    evt,
    target,
    targetRect,
    vertical,
    swapThreshold,
    invertedSwapThreshold,
    invertSwap,
    isLastTarget
  ) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;
    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (
          !pastFirstInvertThresh &&
          (lastDirection === 1
            ? mouseOnAxis >
              targetS1 + (targetLength * invertedSwapThreshold) / 2
            : mouseOnAxis <
              targetS2 - (targetLength * invertedSwapThreshold) / 2)
        ) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (
            lastDirection === 1
              ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
              : mouseOnAxis > targetS2 - targetMoveDistance
          ) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (
          mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&
          mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2
        ) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      // Invert of regular
      if (
        mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||
        mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2
      ) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */ function _getInsertDirection(target) {
    if (index$1(dragEl) < index$1(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */ function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  function _cancelNextTick(id) {
    return clearTimeout(id);
  } // Fixed #973:
  if (documentExists) {
    on(document, "touchmove", function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  } // Export utils
  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend$1,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone$1,
    index: index$1,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild,
  };
  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */ Sortable.get = function (element) {
    return element[expando];
  };
  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */ Sortable.mount = function () {
    for (
      var _len = arguments.length, plugins = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      plugins[_key] = arguments[_key];
    }
    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat(
          {}.toString.call(plugin)
        );
      }
      if (plugin.utils)
        Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */ Sortable.create = function (el, options) {
    return new Sortable(el, options);
  }; // Export
  Sortable.version = version;
  var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true,
      }; // Bind all private methods
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt; // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good
        if (fallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (
            scrolling &&
            (!pointerElemChangedInterval ||
              x !== lastAutoScrollX ||
              y !== lastAutoScrollY)
          ) {
            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour
            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(
                document.elementFromPoint(x, y),
                true
              );
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (
            !this.options.bubbleScroll ||
            getParentAutoScrollElement(elem, true) ===
              getWindowScrollingElement()
          ) {
            clearAutoScrolls();
            return;
          }
          autoScroll(
            evt,
            this.options,
            getParentAutoScrollElement(elem, false),
            false
          );
        }
      },
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true,
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl
    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX =
          width < scrollWidth &&
          (elCSS.overflowX === "auto" ||
            elCSS.overflowX === "scroll" ||
            elCSS.overflowX === "visible");
        canScrollY =
          height < scrollHeight &&
          (elCSS.overflowY === "auto" ||
            elCSS.overflowY === "scroll" ||
            elCSS.overflowY === "visible");
      } else {
        canScrollX =
          width < scrollWidth &&
          (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY =
          height < scrollHeight &&
          (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx =
        canScrollX &&
        (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -
          (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy =
        canScrollY &&
        (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -
          (Math.abs(top - y) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (
        autoScrolls[layersOut].vx != vx ||
        autoScrolls[layersOut].vy != vy ||
        autoScrolls[layersOut].el !== el
      ) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */ autoScrolls[layersOut].pid = setInterval(
            function () {
              // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
              }
              var scrollOffsetY = autoScrolls[this.layer].vy
                ? autoScrolls[this.layer].vy * speed
                : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx
                ? autoScrolls[this.layer].vx * speed
                : 0;
              if (typeof scrollCustomFn === "function") {
                if (
                  scrollCustomFn.call(
                    Sortable.dragged.parentNode[expando],
                    scrollOffsetX,
                    scrollOffsetY,
                    evt,
                    touchEvt$1,
                    autoScrolls[this.layer].el
                  ) !== "continue"
                ) {
                  return;
                }
              }
              scrollBy(
                autoScrolls[this.layer].el,
                scrollOffsetX,
                scrollOffsetY
              );
            }.bind({ layer: layersOut }),
            24
          );
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);
  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch =
      originalEvent.changedTouches && originalEvent.changedTouches.length
        ? originalEvent.changedTouches[0]
        : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({ dragEl: dragEl, putSortable: putSortable });
    }
  };
  function Revert() {}
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable) {
        putSortable.captureAnimationState();
      }
      var nextSibling = getChild(
        this.sortable.el,
        this.startIndex,
        this.options
      );
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }
      this.sortable.animateAll();
      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop,
  };
  _extends(Revert, { pluginName: "revertOnSpill" });
  function Remove() {}
  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop,
  };
  _extends(Remove, { pluginName: "removeOnSpill" });
  var OnSpill = [Remove, Revert];
  var lastSwapEl;
  function SwapPlugin() {
    function Swap() {
      this.defaults = { swapClass: "sortable-swap-highlight" };
    }
    Swap.prototype = {
      dragStart: function dragStart(_ref) {
        var dragEl = _ref.dragEl;
        lastSwapEl = dragEl;
      },
      dragOverValid: function dragOverValid(_ref2) {
        var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
        if (!activeSortable.options.swap) return;
        var el = this.sortable.el,
          options = this.options;
        if (target && target !== el) {
          var prevSwapEl = lastSwapEl;
          if (onMove(target) !== false) {
            toggleClass(target, options.swapClass, true);
            lastSwapEl = target;
          } else {
            lastSwapEl = null;
          }
          if (prevSwapEl && prevSwapEl !== lastSwapEl) {
            toggleClass(prevSwapEl, options.swapClass, false);
          }
        }
        changed();
        completed(true);
        cancel();
      },
      drop: function drop(_ref3) {
        var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
        var toSortable = putSortable || this.sortable;
        var options = this.options;
        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
        if (
          lastSwapEl &&
          (options.swap || (putSortable && putSortable.options.swap))
        ) {
          if (dragEl !== lastSwapEl) {
            toSortable.captureAnimationState();
            if (toSortable !== activeSortable)
              activeSortable.captureAnimationState();
            swapNodes(dragEl, lastSwapEl);
            toSortable.animateAll();
            if (toSortable !== activeSortable) activeSortable.animateAll();
          }
        }
      },
      nulling: function nulling() {
        lastSwapEl = null;
      },
    };
    return _extends(Swap, {
      pluginName: "swap",
      eventProperties: function eventProperties() {
        return { swapItem: lastSwapEl };
      },
    });
  }
  function swapNodes(n1, n2) {
    var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
    i1 = index$1(n1);
    i2 = index$1(n2);
    if (p1.isEqualNode(p2) && i1 < i2) {
      i2++;
    }
    p1.insertBefore(n2, p1.children[i1]);
    p2.insertBefore(n1, p2.children[i2]);
  }
  var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect, // for selection with modifier key down (SHIFT)
    multiDragSortable,
    initialFolding = false, // Initial multi-drag fold when drag started
    folding = false, // Folding any other time
    dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;
  function MultiDragPlugin() {
    function MultiDrag(sortable) {
      // Bind all private methods
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
      if (sortable.options.supportPointer) {
        on(document, "pointerup", this._deselectMultiDrag);
      } else {
        on(document, "mouseup", this._deselectMultiDrag);
        on(document, "touchend", this._deselectMultiDrag);
      }
      on(document, "keydown", this._checkKeyDown);
      on(document, "keyup", this._checkKeyUp);
      this.defaults = {
        selectedClass: "sortable-selected",
        multiDragKey: null,
        setData: function setData(dataTransfer, dragEl) {
          var data = "";
          if (multiDragElements.length && multiDragSortable === sortable) {
            multiDragElements.forEach(function (multiDragElement, i) {
              data += (!i ? "" : ", ") + multiDragElement.textContent;
            });
          } else {
            data = dragEl.textContent;
          }
          dataTransfer.setData("Text", data);
        },
      };
    }
    MultiDrag.prototype = {
      multiDragKeyDown: false,
      isMultiDrag: false,
      delayStartGlobal: function delayStartGlobal(_ref) {
        var dragged = _ref.dragEl;
        dragEl$1 = dragged;
      },
      delayEnded: function delayEnded() {
        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
      },
      setupClone: function setupClone(_ref2) {
        var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
        if (!this.isMultiDrag) return;
        for (var i = 0; i < multiDragElements.length; i++) {
          multiDragClones.push(clone$1(multiDragElements[i]));
          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
          multiDragClones[i].draggable = false;
          multiDragClones[i].style["will-change"] = "";
          toggleClass(multiDragClones[i], this.options.selectedClass, false);
          multiDragElements[i] === dragEl$1 &&
            toggleClass(multiDragClones[i], this.options.chosenClass, false);
        }
        sortable._hideClone();
        cancel();
      },
      clone: function clone(_ref3) {
        var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
        if (!this.isMultiDrag) return;
        if (!this.options.removeCloneOnHide) {
          if (multiDragElements.length && multiDragSortable === sortable) {
            insertMultiDragClones(true, rootEl);
            dispatchSortableEvent("clone");
            cancel();
          }
        }
      },
      showClone: function showClone(_ref4) {
        var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
        if (!this.isMultiDrag) return;
        insertMultiDragClones(false, rootEl);
        multiDragClones.forEach(function (clone) {
          css(clone, "display", "");
        });
        cloneNowShown();
        clonesHidden = false;
        cancel();
      },
      hideClone: function hideClone(_ref5) {
        var _this = this;
        _ref5.sortable;
        var cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
        if (!this.isMultiDrag) return;
        multiDragClones.forEach(function (clone) {
          css(clone, "display", "none");
          if (_this.options.removeCloneOnHide && clone.parentNode) {
            clone.parentNode.removeChild(clone);
          }
        });
        cloneNowHidden();
        clonesHidden = true;
        cancel();
      },
      dragStartGlobal: function dragStartGlobal(_ref6) {
        _ref6.sortable;
        if (!this.isMultiDrag && multiDragSortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
        }
        multiDragElements.forEach(function (multiDragElement) {
          multiDragElement.sortableIndex = index$1(multiDragElement);
        }); // Sort multi-drag elements
        multiDragElements = multiDragElements.sort(function (a, b) {
          return a.sortableIndex - b.sortableIndex;
        });
        dragStarted = true;
      },
      dragStarted: function dragStarted(_ref7) {
        var _this2 = this;
        var sortable = _ref7.sortable;
        if (!this.isMultiDrag) return;
        if (this.options.sort) {
          // Capture rects,
          // hide multi drag elements (by positioning them absolute),
          // set multi drag elements rects to dragRect,
          // show multi drag elements,
          // animate to rects,
          // unset rects & remove from DOM
          sortable.captureAnimationState();
          if (this.options.animation) {
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              css(multiDragElement, "position", "absolute");
            });
            var dragRect = getRect(dragEl$1, false, true, true);
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              setRect(multiDragElement, dragRect);
            });
            folding = true;
            initialFolding = true;
          }
        }
        sortable.animateAll(function () {
          folding = false;
          initialFolding = false;
          if (_this2.options.animation) {
            multiDragElements.forEach(function (multiDragElement) {
              unsetRect(multiDragElement);
            });
          } // Remove all auxiliary multidrag items from el, if sorting enabled
          if (_this2.options.sort) {
            removeMultiDragElements();
          }
        });
      },
      dragOver: function dragOver(_ref8) {
        var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;
        if (folding && ~multiDragElements.indexOf(target)) {
          completed(false);
          cancel();
        }
      },
      revert: function revert(_ref9) {
        var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;
        if (multiDragElements.length > 1) {
          // Setup unfold animation
          multiDragElements.forEach(function (multiDragElement) {
            sortable.addAnimationState({
              target: multiDragElement,
              rect: folding ? getRect(multiDragElement) : dragRect,
            });
            unsetRect(multiDragElement);
            multiDragElement.fromRect = dragRect;
            fromSortable.removeAnimationState(multiDragElement);
          });
          folding = false;
          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref10) {
        var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
        var options = this.options;
        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          }
          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location
          if (
            options.animation &&
            multiDragElements.length > 1 &&
            (folding ||
              (!isOwner && !activeSortable.options.sort && !putSortable))
          ) {
            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
            var dragRectAbsolute = getRect(dragEl$1, false, true, true);
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
              parentEl.appendChild(multiDragElement);
            });
            folding = true;
          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
          if (!isOwner) {
            // Only remove if not folding (folding will remove them anyways)
            if (!folding) {
              removeMultiDragElements();
            }
            if (multiDragElements.length > 1) {
              var clonesHiddenBefore = clonesHidden;
              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden
              if (
                activeSortable.options.animation &&
                !clonesHidden &&
                clonesHiddenBefore
              ) {
                multiDragClones.forEach(function (clone) {
                  activeSortable.addAnimationState({
                    target: clone,
                    rect: clonesFromRect,
                  });
                  clone.fromRect = clonesFromRect;
                  clone.thisAnimationDuration = null;
                });
              }
            } else {
              activeSortable._showClone(sortable);
            }
          }
        }
      },
      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
        var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
        multiDragElements.forEach(function (multiDragElement) {
          multiDragElement.thisAnimationDuration = null;
        });
        if (
          activeSortable.options.animation &&
          !isOwner &&
          activeSortable.multiDrag.isMultiDrag
        ) {
          clonesFromRect = _extends({}, dragRect);
          var dragMatrix = matrix(dragEl$1, true);
          clonesFromRect.top -= dragMatrix.f;
          clonesFromRect.left -= dragMatrix.e;
        }
      },
      dragOverAnimationComplete: function dragOverAnimationComplete() {
        if (folding) {
          folding = false;
          removeMultiDragElements();
        }
      },
      drop: function drop(_ref12) {
        var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
        var toSortable = putSortable || this.sortable;
        if (!evt) return;
        var options = this.options,
          children = parentEl.children; // Multi-drag selection
        if (!dragStarted) {
          if (options.multiDragKey && !this.multiDragKeyDown) {
            this._deselectMultiDrag();
          }
          toggleClass(
            dragEl$1,
            options.selectedClass,
            !~multiDragElements.indexOf(dragEl$1)
          );
          if (!~multiDragElements.indexOf(dragEl$1)) {
            multiDragElements.push(dragEl$1);
            dispatchEvent({
              sortable: sortable,
              rootEl: rootEl,
              name: "select",
              targetEl: dragEl$1,
              originalEvt: evt,
            }); // Modifier activated, select from last to dragEl
            if (
              evt.shiftKey &&
              lastMultiDragSelect &&
              sortable.el.contains(lastMultiDragSelect)
            ) {
              var lastIndex = index$1(lastMultiDragSelect),
                currentIndex = index$1(dragEl$1);
              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;
                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }
                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: "select",
                    targetEl: children[i],
                    originalEvt: evt,
                  });
                }
              }
            } else {
              lastMultiDragSelect = dragEl$1;
            }
            multiDragSortable = toSortable;
          } else {
            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
            lastMultiDragSelect = null;
            dispatchEvent({
              sortable: sortable,
              rootEl: rootEl,
              name: "deselect",
              targetEl: dragEl$1,
              originalEvt: evt,
            });
          }
        } // Multi-drag drop
        if (dragStarted && this.isMultiDrag) {
          // Do not "unfold" after around dragEl if reverted
          if (
            (parentEl[expando].options.sort || parentEl !== rootEl) &&
            multiDragElements.length > 1
          ) {
            var dragRect = getRect(dragEl$1),
              multiDragIndex = index$1(
                dragEl$1,
                ":not(." + this.options.selectedClass + ")"
              );
            if (!initialFolding && options.animation)
              dragEl$1.thisAnimationDuration = null;
            toSortable.captureAnimationState();
            if (!initialFolding) {
              if (options.animation) {
                dragEl$1.fromRect = dragRect;
                multiDragElements.forEach(function (multiDragElement) {
                  multiDragElement.thisAnimationDuration = null;
                  if (multiDragElement !== dragEl$1) {
                    var rect = folding ? getRect(multiDragElement) : dragRect;
                    multiDragElement.fromRect = rect; // Prepare unfold animation
                    toSortable.addAnimationState({
                      target: multiDragElement,
                      rect: rect,
                    });
                  }
                });
              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
              // properly they must all be removed
              removeMultiDragElements();
              multiDragElements.forEach(function (multiDragElement) {
                if (children[multiDragIndex]) {
                  parentEl.insertBefore(
                    multiDragElement,
                    children[multiDragIndex]
                  );
                } else {
                  parentEl.appendChild(multiDragElement);
                }
                multiDragIndex++;
              }); // If initial folding is done, the elements may have changed position because they are now
              // unfolding around dragEl, even though dragEl may not have his index changed, so update event
              // must be fired here as Sortable will not.
              if (oldIndex === index$1(dragEl$1)) {
                var update = false;
                multiDragElements.forEach(function (multiDragElement) {
                  if (
                    multiDragElement.sortableIndex !== index$1(multiDragElement)
                  ) {
                    update = true;
                    return;
                  }
                });
                if (update) {
                  dispatchSortableEvent("update");
                }
              }
            } // Must be done after capturing individual rects (scroll bar)
            multiDragElements.forEach(function (multiDragElement) {
              unsetRect(multiDragElement);
            });
            toSortable.animateAll();
          }
          multiDragSortable = toSortable;
        } // Remove clones if necessary
        if (
          rootEl === parentEl ||
          (putSortable && putSortable.lastPutMode !== "clone")
        ) {
          multiDragClones.forEach(function (clone) {
            clone.parentNode && clone.parentNode.removeChild(clone);
          });
        }
      },
      nullingGlobal: function nullingGlobal() {
        this.isMultiDrag = dragStarted = false;
        multiDragClones.length = 0;
      },
      destroyGlobal: function destroyGlobal() {
        this._deselectMultiDrag();
        off(document, "pointerup", this._deselectMultiDrag);
        off(document, "mouseup", this._deselectMultiDrag);
        off(document, "touchend", this._deselectMultiDrag);
        off(document, "keydown", this._checkKeyDown);
        off(document, "keyup", this._checkKeyUp);
      },
      _deselectMultiDrag: function _deselectMultiDrag(evt) {
        if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable
        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable
        if (
          evt &&
          closest(evt.target, this.options.draggable, this.sortable.el, false)
        )
          return; // Only deselect if left click
        if (evt && evt.button !== 0) return;
        while (multiDragElements.length) {
          var el = multiDragElements[0];
          toggleClass(el, this.options.selectedClass, false);
          multiDragElements.shift();
          dispatchEvent({
            sortable: this.sortable,
            rootEl: this.sortable.el,
            name: "deselect",
            targetEl: el,
            originalEvt: evt,
          });
        }
      },
      _checkKeyDown: function _checkKeyDown(evt) {
        if (evt.key === this.options.multiDragKey) {
          this.multiDragKeyDown = true;
        }
      },
      _checkKeyUp: function _checkKeyUp(evt) {
        if (evt.key === this.options.multiDragKey) {
          this.multiDragKeyDown = false;
        }
      },
    };
    return _extends(MultiDrag, {
      // Static methods & properties
      pluginName: "multiDrag",
      utils: {
        /**
         * Selects the provided multi-drag item
         * @param  {HTMLElement} el    The element to be selected
         */ select: function select(el) {
          var sortable = el.parentNode[expando];
          if (
            !sortable ||
            !sortable.options.multiDrag ||
            ~multiDragElements.indexOf(el)
          )
            return;
          if (multiDragSortable && multiDragSortable !== sortable) {
            multiDragSortable.multiDrag._deselectMultiDrag();
            multiDragSortable = sortable;
          }
          toggleClass(el, sortable.options.selectedClass, true);
          multiDragElements.push(el);
        },
        /**
         * Deselects the provided multi-drag item
         * @param  {HTMLElement} el    The element to be deselected
         */ deselect: function deselect(el) {
          var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
          if (!sortable || !sortable.options.multiDrag || !~index) return;
          toggleClass(el, sortable.options.selectedClass, false);
          multiDragElements.splice(index, 1);
        },
      },
      eventProperties: function eventProperties() {
        var _this3 = this;
        var oldIndicies = [],
          newIndicies = [];
        multiDragElements.forEach(function (multiDragElement) {
          oldIndicies.push({
            multiDragElement: multiDragElement,
            index: multiDragElement.sortableIndex,
          }); // multiDragElements will already be sorted if folding
          var newIndex;
          if (folding && multiDragElement !== dragEl$1) {
            newIndex = -1;
          } else if (folding) {
            newIndex = index$1(
              multiDragElement,
              ":not(." + _this3.options.selectedClass + ")"
            );
          } else {
            newIndex = index$1(multiDragElement);
          }
          newIndicies.push({
            multiDragElement: multiDragElement,
            index: newIndex,
          });
        });
        return {
          items: _toConsumableArray(multiDragElements),
          clones: [].concat(multiDragClones),
          oldIndicies: oldIndicies,
          newIndicies: newIndicies,
        };
      },
      optionListeners: {
        multiDragKey: function multiDragKey(key) {
          key = key.toLowerCase();
          if (key === "ctrl") {
            key = "Control";
          } else if (key.length > 1) {
            key = key.charAt(0).toUpperCase() + key.substr(1);
          }
          return key;
        },
      },
    });
  }
  function insertMultiDragElements(clonesInserted, rootEl) {
    multiDragElements.forEach(function (multiDragElement, i) {
      var target =
        rootEl.children[
          multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)
        ];
      if (target) {
        rootEl.insertBefore(multiDragElement, target);
      } else {
        rootEl.appendChild(multiDragElement);
      }
    });
  }
  /**
   * Insert multi-drag clones
   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
   * @param  {HTMLElement} rootEl
   */ function insertMultiDragClones(elementsInserted, rootEl) {
    multiDragClones.forEach(function (clone, i) {
      var target =
        rootEl.children[
          clone.sortableIndex + (elementsInserted ? Number(i) : 0)
        ];
      if (target) {
        rootEl.insertBefore(clone, target);
      } else {
        rootEl.appendChild(clone);
      }
    });
  }
  function removeMultiDragElements() {
    multiDragElements.forEach(function (multiDragElement) {
      if (multiDragElement === dragEl$1) return;
      multiDragElement.parentNode &&
        multiDragElement.parentNode.removeChild(multiDragElement);
    });
  } // 
  window.BROWSER_INFO = getBrowser();
  /**
   * 
   * @returns {type: string, version: number}
   */ function getBrowser() {
    const UserAgent = navigator.userAgent.toLowerCase();
    const browserInfo = {};
    const browserArray = {
      IE: window.ActiveXObject || "ActiveXObject" in window, // IE
      Chrome:
        UserAgent.indexOf("chrome") > -1 && UserAgent.indexOf("safari") > -1, // Chrome
      Firefox: UserAgent.indexOf("firefox") > -1, // 
      Opera: UserAgent.indexOf("opera") > -1, // Opera
      Safari:
        UserAgent.indexOf("safari") > -1 && UserAgent.indexOf("chrome") === -1, // safari
      Edge: UserAgent.indexOf("edge") > -1, // Edge
      QQBrowser: /qqbrowser/.test(UserAgent), // qq
      WeixinBrowser: /MicroMessenger/i.test(UserAgent), // 
    };
    for (const i in browserArray) {
      if (browserArray[i]) {
        let version = "";
        if (i === "IE") {
          version = UserAgent.match(/(msie\s|trident.*rv:)([\w.]+)/)[2];
        } else if (i === "Chrome") {
          version = UserAgent.match(/chrome\/([\d.]+)/)[1];
        } else if (i === "Firefox") {
          version = UserAgent.match(/firefox\/([\d.]+)/)[1];
        } else if (i === "Opera") {
          version = UserAgent.match(/opera\/([\d.]+)/)[1];
        } else if (i === "Safari") {
          version =
            UserAgent.match(/version\/([\d.]+)/) &&
            UserAgent.match(/version\/([\d.]+)/)[1];
        } else if (i === "Edge") {
          version = UserAgent.match(/edge\/([\d.]+)/)[1];
        } else if (i === "QQBrowser") {
          version = UserAgent.match(/qqbrowser\/([\d.]+)/)[1];
        }
        browserInfo.type = i;
        browserInfo.version = parseInt(version, 10);
      }
    }
    return browserInfo;
  } //  position: sticky 
  //  https://caniuse.com/?search=sticky
  const SUPPORT_STICKY_MIN_BROWSER_VERSION_MAP = {
    Chrome: 56,
    Firefox: 59,
    Opera: 42,
    Safari: 6,
    Edge: 16,
    QQBrowser: 10,
  }; // sticky
  function isBrowerSupportSticky() {
    if (window.BROWSER_INFO.type === "IE") return false; //
    //  minVersion 
    const minVersion =
      SUPPORT_STICKY_MIN_BROWSER_VERSION_MAP[window.BROWSER_INFO.type];
    if (minVersion && minVersion > window.BROWSER_INFO.version) {
      return false;
    } // 
    return true;
  }
  function isChrome49() {
    return (
      window.BROWSER_INFO.type === "Chrome" &&
      window.BROWSER_INFO.version === 49
    );
  }
  String.prototype.trim = function (characters) {
    return this.replace(new RegExp(`^${characters}+|${characters}+$`, "g"), "");
  };
  String.prototype.startWith = function (str) {
    const reg = new RegExp(`^${str}`);
    return reg.test(this);
  };
  String.prototype.trimEnd = function (characters) {
    return this.replace(new RegExp(`${characters}+$`, "g"), "");
  };
  String.prototype.prepend = function (character) {
    if (this[0] !== character) {
      return (character + this).toString();
    }
    return this.toString();
  };
  String.prototype.format = function (args) {
    let result = this;
    if (arguments.length > 0) {
      if (arguments.length === 1 && typeof args === "object") {
        for (const key in args) {
          if (args[key] !== undefined) {
            const reg = new RegExp(`({${key}})`, "g");
            result = result.replace(reg, args[key]);
          }
        }
      } else {
        for (let i = 0; i < arguments.length; i++) {
          if (arguments[i] !== undefined) {
            const reg = new RegExp(`({)${i}(})`, "g");
            result = result.replace(reg, arguments[i]);
          }
        }
      }
    }
    return result;
  };
  String.prototype.contains = function (search, ignoreCase = true) {
    // 
    const escapedSearchString = escapeRegExp(search); // 
    const regex = new RegExp(escapedSearchString, ignoreCase ? "igm" : "gm"); //  exec 
    return regex.test(this);
  };
  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   *
   * @param {*} obj
   * @return {Boolean}
   */ const { toString } = Object.prototype;
  const OBJECT_STRING = "[object Object]";
  function isPlainObject(obj) {
    if (Object.prototype.toString.call(obj) !== OBJECT_STRING) {
      return false;
    }
    const prototype = Object.getPrototypeOf(obj);
    return prototype === null || prototype === Object.prototype;
  }
  function isString(obj) {
    // 
    return Object.prototype.toString.call(obj) === "[object String]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  } //  null  undefined
  function isNullish(val) {
    return val === null || val === undefined;
  }
  function localeCompareString(prev, next, field) {
    if (!prev[field] && !next[field]) {
      return 0;
    }
    if (!!prev[field] && !next[field]) {
      return 1;
    }
    if (!prev[field] && !!next[field]) {
      return -1;
    }
    return prev[field].localeCompare(next[field], "zh");
  }
  function ascCompare(prev, next, field) {
    if (!prev[field] && !next[field]) {
      return 0;
    }
    if (!!prev[field] && !next[field]) {
      return 1;
    }
    if (!prev[field] && !!next[field]) {
      return -1;
    }
    return `${prev[field]}`.charCodeAt() - `${next[field]}`.charCodeAt();
  }
  /**
   * Hyphenate a camelCase string.
   *
   * @param {String} str
   * @return {String}
   */ const hyphenateRE = /([^-])([A-Z])/g;
  function hyphenate(str) {
    return str
      .replace(hyphenateRE, "$1-$2")
      .replace(hyphenateRE, "$1-$2")
      .toLowerCase();
  }
  function htmlEncode(value) {
    // Create a in-memory element, set its inner text (which is automatically encoded)
    // Then grab the encoded contents back out. The element never exists on the DOM.
    const textarea = document.createElement("textarea");
    textarea.textContent = value;
    return textarea.innerHTML;
  }
  function extend() {
    let options;
    let name;
    let src;
    let copy;
    let _clone;
    let target = arguments[0] || {};
    let i = 1;
    const { length } = arguments;
    let deep = false; // Handle a deep copy situation
    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    }
    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name]; // Prevent never-ending loop
          if (target === copy) {
            continue;
          } // Recurse if we're merging plain objects
          if (deep && copy && isPlainObject(copy)) {
            _clone = src && isPlainObject(src) ? src : {}; // Never move original objects, clone them
            target[name] = extend(deep, _clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object
    return target;
  }
  function clone(from) {
    if (isPlainObject(from) || Array.isArray(from)) {
      return JSON.parse(JSON.stringify(from));
    }
    return from;
  }
  function accessProp(options, key) {
    if (typeof key === "string") {
      // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
      const parts = key.split(".");
      let curOption;
      key = parts.shift();
      if (parts.length) {
        curOption = options[key];
        for (let i = 0; i < parts.length - 1; i++) {
          curOption[parts[i]] = curOption[parts[i]] || {};
          curOption = curOption[parts[i]];
        }
        key = parts.pop();
        return curOption[key] === undefined ? null : curOption[key];
      }
      return options[key] === undefined ? null : options[key];
    }
  }
  function pathCombine() {
    let path = "";
    const args = Array.from(arguments);
    args.forEach(function (item, index) {
      if (index > 0) {
        path += `/${item.trim("/")}`;
      } else {
        path += item.trimEnd("/");
      }
    });
    return path;
  }
  const uppercaseRegex = /[A-Z]/g;
  function toLowerCase(capital) {
    return `-${capital.toLowerCase()}`;
  }
  function normalizeKey(key) {
    return key[0] === "-" && key[1] === "-"
      ? key
      : key === "cssFloat"
      ? "float"
      : key.replace(uppercaseRegex, toLowerCase);
  }
  function isNumeric(val) {
    const num = Number(val);
    const type = typeof val;
    return (
      (val != null &&
        type !== "boolean" &&
        (type !== "string" || val.length) &&
        !Number.isNaN(num) &&
        Number.isFinite(num)) ||
      false
    );
  }
  function newGuid() {
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function (n) {
      // eslint-disable-next-line no-bitwise
      const t = (Math.random() * 16) | 0; // eslint-disable-next-line no-bitwise
      const i = n === "x" ? t : (t & 3) | 8;
      return i.toString(16);
    });
  }
  function isPromiseLike$1(promiseLike) {
    return (
      promiseLike !== null &&
      (typeof promiseLike === "object" || typeof promiseLike === "function") &&
      typeof promiseLike.then === "function"
    );
  }
  function formatDate(date, format) {
    if (!date) {
      return null;
    }
    let mydate = null; //  ISO 8601 
    if (typeof date === "string") {
      mydate = new Date(date); // 
    } else if (typeof date === "number") {
      mydate = new Date(date); // 
    } else if (date instanceof Date) {
      mydate = date; //  Date 
    } // 
    if (Number.isNaN(mydate.getTime())) {
      throw new Error("Invalid date");
    }
    return new Date(mydate).format(format);
  }
  function isDate(date) {
    return toString.call(date) === "[object Date]";
  }
  /**
   * 
   * @param {string} date - 
   * @returns {boolean} 
   */ function isValidDate$1(date) {
    if (typeof date !== "string") return false; // 1. TZ-/:.+
    if (/[^0-9TZ\-/:.+\\s]/.test(date)) {
      return false;
    } // 2. 
    if (/^\d{4}$/.test(date)) {
      const year = parseInt(date, 10);
      return year >= 1000 && year <= 3000;
    } // 3. 1-6
    if (/\.\d{7,}/.test(date)) return false; // 4. 
    const timezoneMatch = date.match(/[+-]\d{2}:\d{2}$/);
    if (timezoneMatch) {
      const hours = parseInt(timezoneMatch[1], 10);
      const minutes = parseInt(timezoneMatch[2], 10);
      if (hours > 23 || minutes > 59) return false;
    } // 5.  Date 
    try {
      const d = new Date(date);
      if (d.toString() === "Invalid Date") return false; // 
      const dateParts = date.split(/[^\d]/).filter(Boolean);
      if (dateParts.length >= 3) {
        const month = parseInt(dateParts[1], 10);
        const day = parseInt(dateParts[2], 10);
        if (month < 1 || month > 12 || day < 1 || day > 31) return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  /**
   * urlquery
   * @param {string} url url
   * @returns Object
   */ function parseToQuery(url) {
    // url
    if (url.indexOf("?") < 0 || url.indexOf("?") === url.length - 1) {
      return {};
    }
    const queryStr = /.+\?(.+)$/.exec(url)[1];
    const queryArr = queryStr.split("&");
    const paramsObj = {};
    queryArr.forEach((param) => {
      if (/=/.test(param)) {
        // = 
        // eslint-disable-next-line prefer-const
        let [key, val] = param.split("="); // 
        val = decodeURIComponent(val); // 
        val = /^\d+$/.test(val) ? parseFloat(val) : val; // key
        if (paramsObj.hasOwnProperty(key)) {
          paramsObj[key] = [].concat(paramsObj[key], val);
        } else {
          paramsObj[key] = val;
        }
      } // =true
      else {
        paramsObj[param] = true;
      }
    });
    return paramsObj;
  }
  /**
   * string query
   * @param {object}} obj
   * @returns
   */ function parseToQueryString(obj) {
    const result = [];
    for (const key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        const value = obj[key];
        result.push(`${key}=${encodeURIComponent(value)}`);
      }
    }
    return result.join("&");
  }
  function isFalsy(value) {
    if (value === 0) return false;
    return !value;
  } // 
  function debounce(func, wait) {
    let timer = null;
    return function () {
      const context = this;
      const args = arguments;
      timer && clearTimeout(timer);
      timer = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    };
  }
  function isNotEmptyArray(array) {
    return Array.isArray(array) && array.length > 0;
  }
  function isHexColor(str) {
    if (!isString(str)) {
      return false;
    }
    const regex = /^#([0-9A-Fa-f]{3}){1,2}([0-9A-Fa-f]{2})?$/;
    return regex.test(str);
  }
  /**
   *
   * @param {HTMLElement} el dom
   * @param {string} pseudo 
   * @returns
   */ function getStyle(el, pseudo = null) {
    // IE
    if (window.getComputedStyle) {
      return getComputedStyle(el, pseudo);
    }
    return el.currentStyle; // IE
  } //  sortable bug
  function defaultSortableOndrop() {
    document.body.ondrop = function (event) {
      event.preventDefault();
      event.stopPropagation();
    };
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // 
  } // 
  function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
      return true;
    }
    if (typeof obj1 !== typeof obj2) {
      return false;
    }
    if (
      isString(obj1) &&
      isString(obj2) &&
      isValidDate$1(obj1) &&
      isValidDate$1(obj2) &&
      Date.parse(obj1) === Date.parse(obj2)
    ) {
      return true;
    }
    if (Array.isArray(obj1) && Array.isArray(obj2)) {
      // 
      return compareArrays(obj1, obj2);
    }
    if (
      typeof obj1 === "object" &&
      obj1 !== null &&
      typeof obj2 === "object" &&
      obj2 !== null
    ) {
      // 
      const keys1 = Object.keys(obj1),
        keys2 = Object.keys(obj2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (const key of keys1) {
        if (
          !Object.prototype.hasOwnProperty.call(obj2, key) ||
          !deepEqual(obj1[key], obj2[key])
        ) {
          return false;
        }
      }
      return true;
    } // 
    return false;
  }
  function compareArrays(arr1, arr2) {
    // 
    if (arr1.length !== arr2.length) {
      return false;
    } // 
    const set1 = new Set(arr1.map((item) => JSON.stringify(item)));
    const set2 = new Set(arr2.map((item) => JSON.stringify(item))); // 
    if (set1.size !== set2.size) {
      return false;
    } // 
    for (const item of set1) {
      if (!set2.has(item)) {
        return false;
      }
    }
    return true;
  } // 
  function copyToClipboard(text) {
    if (navigator.clipboard) {
      // Clipboard API
      navigator.clipboard.writeText(text);
    } else {
      // 
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed"; // 
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand("copy");
      } catch (err) {
        console.error("Failed to copy text", err);
      } finally {
        document.body.removeChild(textarea); // 
      }
    }
  }
  /**
   *   (1112XX1231)
   * @param {Date} date -    startWeekOnMonday - 
   * @returns {Object} -  { year: 2023, week: 12 }
   */ function getWeekInYear({
    date,
    weekFormat = "{year}{week}",
    startWeekOnMonday = true,
  }) {
    date = new Date(date);
    let year = date.getFullYear();
    const firstDayOfYear = new Date(year, 0, 1); // 11
    // const lastDayOfYear = new Date(year, 11, 31) // 1231
    // 
    let firstWeekStart;
    if (startWeekOnMonday) {
      // 
      const firstMondayOfYear = new Date(firstDayOfYear);
      firstMondayOfYear.setDate(
        firstDayOfYear.getDate() + ((1 - firstDayOfYear.getDay() + 7) % 7)
      );
      firstWeekStart = new Date(firstMondayOfYear);
    } else {
      // 
      const firstSundayOfYear = new Date(firstDayOfYear);
      firstSundayOfYear.setDate(
        firstDayOfYear.getDate() + ((7 - firstDayOfYear.getDay()) % 7)
      );
      firstWeekStart = new Date(firstSundayOfYear);
    } // 11
    if (startWeekOnMonday && firstDayOfYear.getDay() !== 1) {
      firstWeekStart.setDate(firstWeekStart.getDate() - 7);
    } else if (!startWeekOnMonday && firstDayOfYear.getDay() !== 0) {
      firstWeekStart.setDate(firstWeekStart.getDate() - 7);
    } // 
    if (date < firstWeekStart) {
      return { year: year - 1, week: 52 }; // 52
    } // 
    const delta = Math.floor(
      (date - firstWeekStart) / (7 * 24 * 60 * 60 * 1000)
    );
    let weekNumber = delta + 1; // 
    if (weekNumber > 52) {
      weekNumber = 1;
      year++;
    }
    const dates = getWeekDates({ date });
    return {
      year,
      week: weekNumber,
      dates,
      weekText: weekFormat
        .replace("{year}", year)
        .replace("{week}", weekNumber)
        .replace("{start}", dates[0])
        .replace(`{end}`, dates[6]),
    };
  }
  /**
   * 
   * @param {number} year - 
   * @param {number} week - 
   * @param {boolean} startWeekOnMonday - 
   * @returns {Date} - 
   */ function getDateFromYearAndWeek(year, week, startWeekOnMonday) {
    // 11
    const firstDayOfYear = new Date(year, 0, 1); // 110=1=...6=
    const firstDayOfYearWeekday = firstDayOfYear.getDay(); // 
    const firstWeekStart = new Date(firstDayOfYear);
    if (startWeekOnMonday) {
      // 
      if (firstDayOfYearWeekday !== 1) {
        // 1112
        firstWeekStart.setDate(1 - ((firstDayOfYearWeekday + 6) % 7));
      }
    } else if (firstDayOfYearWeekday !== 0) {
      // 1112
      firstWeekStart.setDate(1 - firstDayOfYearWeekday);
    } // 
    const targetWeekStart = new Date(firstWeekStart);
    targetWeekStart.setDate(firstWeekStart.getDate() + (week - 1) * 7);
    return targetWeekStart;
  }
  /**
   * 7
   * @param {Object} params - 
   * @param {number} [params.year] - 
   * @param {number} [params.week] - 
   * @param {string} [params.date] - 'yyyy-MM-dd'
   * @param {boolean} [params.startWeekOnMonday=true] - 
   * @returns {Array} - 7 'yyyy-MM-dd'
   */ function getWeekDates({ year, week, date, startWeekOnMonday = true }) {
    let targetDate;
    if (date) {
      //  Date 
      targetDate = new Date(date);
      if (Number.isNaN(targetDate.getTime())) {
        throw new Error("Invalid date string");
      }
    } else if (year !== undefined && week !== undefined) {
      //  year  week
      targetDate = getDateFromYearAndWeek(year, week, startWeekOnMonday);
    } else {
      throw new Error(
        "Invalid parameters: must provide either { year, week } or { date }"
      );
    } // 0=1=...6=
    const dayOfWeek = targetDate.getDay(); // 
    const weekStart = new Date(targetDate);
    if (startWeekOnMonday) {
      // 
      weekStart.setDate(
        targetDate.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1)
      );
    } else {
      // 
      weekStart.setDate(targetDate.getDate() - dayOfWeek);
    } // 7
    return Array.from({ length: 7 }, (_, i) => {
      const currentDate = new Date(weekStart);
      currentDate.setDate(weekStart.getDate() + i);
      return new Date(currentDate).format("yyyy-MM-dd"); // 
    });
  }
  function checkOverflowAncestor(ele, direction = "vertical") {
    let currentElement = ele;
    let overflowAncestor = null;
    while (currentElement !== null && currentElement instanceof Element) {
      const style = window.getComputedStyle(currentElement);
      const hasOverflow =
        direction === "vertical"
          ? ["auto", "scroll"].includes(style.overflowY) ||
            ["auto", "scroll"].includes(style.overflow)
          : ["auto", "scroll"].includes(style.overflowX) ||
            ["auto", "scroll"].includes(style.overflow);
      if (hasOverflow) {
        overflowAncestor = currentElement;
        break;
      }
      if (currentElement === document.documentElement) {
        break;
      }
      currentElement = currentElement.parentNode;
    }
    return overflowAncestor;
  }
  const _nomScrollToEndCleanupMap = new WeakMap();
  /**
   * /
   * @param {Object} params - 
   * @param {Element|Object} params.target - element
   * @param {Function} params.callback - /
   * @param {string} [params.direction='vertical'] - 'vertical'|'horizontal'
   * @returns {Function} - 
   */ function watchScrollToEnd({ target, callback, direction = "vertical" }) {
    if (target.element) {
      target = target.element;
    } // 
    if (_nomScrollToEndCleanupMap.has(target)) {
      _nomScrollToEndCleanupMap.get(target)();
    }
    let ele = target; // 
    const style = window.getComputedStyle(target);
    const isSelfScrollable =
      direction === "vertical"
        ? ["auto", "scroll"].includes(style.overflowY) ||
          ["auto", "scroll"].includes(style.overflow)
        : ["auto", "scroll"].includes(style.overflowX) ||
          ["auto", "scroll"].includes(style.overflow);
    if (!isSelfScrollable) {
      ele = checkOverflowAncestor(target, direction) || target;
    }
    const handleScroll = () => {
      const isAtEnd =
        direction === "vertical"
          ? Math.abs(ele.scrollHeight - ele.scrollTop - ele.clientHeight) < 1
          : Math.abs(ele.scrollWidth - ele.scrollLeft - ele.clientWidth) < 1;
      if (isAtEnd) callback();
    };
    ele.addEventListener("scroll", handleScroll);
    const cleanup = () => {
      ele.removeEventListener("scroll", handleScroll);
      _nomScrollToEndCleanupMap.delete(target);
    };
    _nomScrollToEndCleanupMap.set(target, cleanup);
    return cleanup;
  }
  function isTargetInViewport(target) {
    let el = target;
    if (target.element) {
      el = target.element;
    }
    if (!el) return false;
    const rect = el.getBoundingClientRect();
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <=
        (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  } // svgsvg
  function formatSvg(svg, isColored) {
    if (!svg || typeof svg !== "string") return ""; // 
    let result = svg
      .replace(/\s{2,}/g, " ")
      .replace(/[\r\n]/g, "")
      .trim(); // svgwidthheight1em
    result = result.replace(/<svg\b([^>]*)>/i, (match, attrs) => {
      // width/height/fill
      const newAttrs = attrs
        .replace(/\swidth="[^"]*"/i, "")
        .replace(/\sheight="[^"]*"/i, "")
        .replace(/\sfill="[^"]*"/i, ""); // widthheight
      return `<svg${newAttrs} width="1em" height="1em">`;
    });
    if (!isColored) {
      // svgfill="currentColor"
      result = result.replace(/<svg\b([^>]*)>/i, (match, attrs) => {
        // fill
        const newAttrs = attrs.replace(/\sfill="[^"]*"/i, "");
        return `<svg${newAttrs} fill="currentColor">`;
      }); // svgfill
      result = result.replace(/(<(?!svg\b)[^>]+)\sfill="[^"]*"/gi, "$1");
    }
    return result;
  }
  var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isPlainObject: isPlainObject,
    isString: isString,
    isFunction: isFunction,
    isNullish: isNullish,
    localeCompareString: localeCompareString,
    ascCompare: ascCompare,
    hyphenate: hyphenate,
    htmlEncode: htmlEncode,
    extend: extend,
    clone: clone,
    accessProp: accessProp,
    pathCombine: pathCombine,
    normalizeKey: normalizeKey,
    isNumeric: isNumeric,
    newGuid: newGuid,
    isPromiseLike: isPromiseLike$1,
    formatDate: formatDate,
    isDate: isDate,
    isValidDate: isValidDate$1,
    parseToQuery: parseToQuery,
    parseToQueryString: parseToQueryString,
    isFalsy: isFalsy,
    debounce: debounce,
    isNotEmptyArray: isNotEmptyArray,
    isHexColor: isHexColor,
    getStyle: getStyle,
    defaultSortableOndrop: defaultSortableOndrop,
    escapeRegExp: escapeRegExp,
    deepEqual: deepEqual,
    copyToClipboard: copyToClipboard,
    getWeekInYear: getWeekInYear,
    getWeekDates: getWeekDates,
    watchScrollToEnd: watchScrollToEnd,
    isTargetInViewport: isTargetInViewport,
    formatSvg: formatSvg,
    AutoScroll: AutoScrollPlugin,
    MultiDrag: MultiDragPlugin,
    OnSpill: OnSpill,
    Sortable: Sortable,
    Swap: SwapPlugin,
    isBrowerSupportSticky: isBrowerSupportSticky,
    isChrome49: isChrome49,
  }); // Events
  // -----------------
  // Thanks to:
  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js
  //  - https://github.com/joyent/node/blob/master/lib/events.js
  // Regular expression used to split event strings
  const eventSplitter = /\s+/; // A module that can be mixed in to *any object* in order to provide it
  // with custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = new Events();
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  function Events() {} // Bind one or more space separated events, `events`, to a `callback`
  // function. Passing `"all"` will bind the callback to all events fired.
  Events.prototype.on = function (events, callback, context) {
    if (!callback) return this;
    const cache = this.__events || (this.__events = {});
    events = events.split(eventSplitter);
    let event;
    let list;
    while ((event = events.shift())) {
      list = cache[event] || (cache[event] = []);
      list.push(callback, context);
    }
    return this;
  };
  Events.prototype.once = function (events, callback, context) {
    const that = this;
    const cb = function () {
      that.off(events, cb);
      callback.apply(context || that, arguments);
    };
    return this.on(events, cb, context);
  }; // Remove one or many callbacks. If `context` is null, removes all callbacks
  // with that function. If `callback` is null, removes all callbacks for the
  // event. If `events` is null, removes all bound callbacks for all events.
  Events.prototype.off = function (events, callback, context) {
    let cache;
    let event;
    let list;
    let i; // No events, or removing *all* events.
    if (!(cache = this.__events)) return this;
    if (!(events || callback || context)) {
      delete this.__events;
      return this;
    }
    events = events ? events.split(eventSplitter) : Object.keys(cache); // Loop through the callback list, splicing where appropriate.
    while ((event = events.shift())) {
      list = cache[event];
      if (!list) continue;
      if (!(callback || context)) {
        delete cache[event];
        continue;
      }
      for (i = list.length - 2; i >= 0; i -= 2) {
        if (
          !(
            (callback && list[i] !== callback) ||
            (context && list[i + 1] !== context)
          )
        ) {
          list.splice(i, 2);
        }
      }
    }
    return this;
  }; // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.prototype.trigger = function (events) {
    let cache;
    let event;
    let all;
    let list;
    let i;
    let len;
    const rest = [];
    let returned = true;
    if (!(cache = this.__events)) return this;
    events = events.split(eventSplitter); // Fill up `rest` with the callback arguments.  Since we're only copying
    // the tail of `arguments`, a loop is much faster than Array#slice.
    for (i = 1, len = arguments.length; i < len; i++) {
      rest[i - 1] = arguments[i];
    } // For each event, walk through the list of callbacks twice, first to
    // trigger the event, then to trigger any `"all"` callbacks.
    while ((event = events.shift())) {
      // Copy callback lists to prevent modification.
      if ((all = cache.all)) all = all.slice();
      if ((list = cache[event])) list = list.slice(); // Execute event callbacks except one named "all"
      if (event !== "all") {
        returned = triggerEvents(list, rest, this) && returned;
      } // Execute "all" callbacks.
      returned = triggerEvents(all, [event].concat(rest), this) && returned;
    }
    return returned;
  };
  Events.prototype.emit = Events.prototype.trigger; // Mix `Events` to object instance or Class function.
  Events.mixTo = function (receiver) {
    const proto = Events.prototype;
    if (isFunction(receiver)) {
      for (const key in proto) {
        if (proto.hasOwnProperty(key)) {
          receiver.prototype[key] = proto[key];
        }
      }
      Object.keys(proto).forEach(function (key) {
        receiver.prototype[key] = proto[key];
      });
    } else {
      const event = new Events();
      for (const key in proto) {
        if (proto.hasOwnProperty(key)) {
          copyProto(key, event);
        }
      }
    }
    function copyProto(key, event) {
      receiver[key] = function () {
        proto[key].apply(event, Array.prototype.slice.call(arguments));
        return this;
      };
    }
  }; // Execute callbacks
  function triggerEvents(list, args, context) {
    let pass = true;
    if (list) {
      let i = 0;
      const l = list.length;
      const a1 = args[0];
      const a2 = args[1];
      const a3 = args[2]; // call is faster than apply, optimize less than 3 argu
      // http://blog.csdn.net/zhengyinhui100/article/details/7837127
      switch (args.length) {
        case 0:
          for (; i < l; i += 2) {
            pass = list[i].call(list[i + 1] || context) !== false && pass;
          }
          break;
        case 1:
          for (; i < l; i += 2) {
            pass = list[i].call(list[i + 1] || context, a1) !== false && pass;
          }
          break;
        case 2:
          for (; i < l; i += 2) {
            pass =
              list[i].call(list[i + 1] || context, a1, a2) !== false && pass;
          }
          break;
        case 3:
          for (; i < l; i += 2) {
            pass =
              list[i].call(list[i + 1] || context, a1, a2, a3) !== false &&
              pass;
          }
          break;
        default:
          for (; i < l; i += 2) {
            pass =
              list[i].apply(list[i + 1] || context, args) !== false && pass;
          }
          break;
      }
    } // trigger will return false if one of the callbacks return false
    return pass;
  }
  const nomGlobalContexts = new WeakMap();
  const nomComponentStack = [];
  const nomuiContextWatchers = {};
  /**
   * DOMcontext
   * 
   */ let cleanupDebounce;
  function cleanupStaleContexts() {
    clearTimeout(cleanupDebounce);
    cleanupDebounce = setTimeout(() => {
      _performCleanup();
    }, 500);
  }
  /**
   * 
   */ function _performCleanup() {
    // ()
    for (let i = nomComponentStack.length - 1; i >= 0; i--) {
      const componentRef = nomComponentStack[i];
      const component = componentRef.deref(); // 
      // 
      if (!component || !_isComponentInDOM(component)) {
        // context
        if (component) {
          nomGlobalContexts.delete(component);
        } // 
        nomComponentStack.splice(i, 1);
      }
    }
  }
  /**
   * DOM
   */ function _isComponentInDOM(component) {
    try {
      // element
      return component.element && document.contains(component.element);
    } catch (e) {
      // DOM
      return false;
    }
  }
  /**
   * context
   */ function registerComponentContext(component, context) {
    nomGlobalContexts.set(component, context); // eslint-disable-next-line no-undef
    nomComponentStack.push(new WeakRef(component));
  }
  class ComponentDescriptor {
    constructor(tagOrComponent, props, children, mixins) {
      this.tagOrComponent = tagOrComponent;
      this.props = props || {};
      this.children = children;
      this.mixins = Array.isArray(mixins) ? mixins : [];
    }
    getProps() {
      if (this.props instanceof ComponentDescriptor) {
        this.mixins = this.mixins.concat(this.props.mixins);
        this.props = this.props.getProps();
      }
      if (this.tagOrComponent) {
        this.props.component = this.tagOrComponent;
      }
      if (this.children) {
        this.props.children = this.children;
      }
      return this.props;
    }
  }
  const components = {};
  const MIXINS = [];
  let keySeq = 0;
  class Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "div",
        reference: document.body,
        placement: "append",
        autoRender: true,
        renderIf: true,
        animate: true,
        hidden: false,
        disabled: false,
        selected: false,
        expanded: false,
        selectable: {
          byClick: false,
          byHover: false,
          canRevert: false,
          selectedProps: null,
          unselectedProps: null,
        },
        expandable: {
          byClick: false,
          byHover: false,
          target: null,
          indicator: null,
          byIndicator: false,
          expandedProps: false,
          collapsedProps: false,
        },
        prefixClass: "nom-",
      };
      this.props = Component.extendProps(defaults, props);
      this.parent = null;
      this.root = null;
      this.rendered = false;
      this.mixins = [];
      this.firstRender = true;
      this._propStyleClasses = [];
      mixins && this._mixin(mixins);
      this._setKey();
      this._componentContext = {};
      isFunction(this._create) && this._create();
      this.referenceComponent =
        this.props.reference instanceof Component
          ? this.props.reference
          : this.props.reference.component;
      if (this.referenceComponent) {
        if (
          this.props.placement === "append" ||
          this.props.placement === "prepend"
        ) {
          this.parent = this.referenceComponent;
        } else {
          this.parent = this.referenceComponent.parent;
        }
      }
      this.referenceElement =
        this.props.reference instanceof Component
          ? this.props.reference.element
          : this.props.reference;
      if (this.parent === null) {
        this.root = this;
      } else {
        this.root = this.parent.root;
      }
      if (this.props.placement === "replace") {
        if (this.referenceComponent) {
          this.referenceElement = this.referenceComponent._removeCore();
        }
      }
      if (this.props.ref) {
        this.props.ref(this);
      }
      this.componentType = this.__proto__.constructor.name;
      const ret = this.create();
      if (Array.isArray(ret)) {
        Promise.all(ret).then(() => {
          if (this.props.autoRender === true) {
            this._handleContext(props);
            this.config();
            this.render();
          }
        });
        this._mountPlaceHolder();
      } else if (this.props.autoRender === true) {
        this._handleContext(props);
        this.config();
        this.render();
      } else {
        this._mountPlaceHolder();
      } // context
      if (
        this.props &&
        this.props.contextListeners &&
        isPlainObject(this.props.contextListeners)
      ) {
        ((target) => Object.keys(target).map((key) => [key, target[key]]))(
          this.props.contextListeners
        ).forEach(([key, callback]) => {
          if (isFunction(callback)) {
            this.addContextListener(key, callback);
          }
        });
      }
    }
    create() {
      const promises = [];
      this.__handleClick = this.__handleClick.bind(this);
      this.__handleMouseEnter = this.__handleMouseEnter.bind(this);
      this.__handleMouseLeave = this.__handleMouseLeave.bind(this);
      if (isFunction(this._created)) {
        const ret = this._created();
        if (ret && isFunction(ret.then)) {
          promises.push(ret);
        }
      }
      this._callMixin("_created");
      this.props._created && this.props._created.call(this, this);
      if (isFunction(this.props.onCreated)) {
        const ret = this.props.onCreated({ inst: this, props: this.props });
        if (ret && isFunction(ret.then)) {
          promises.push(ret);
        }
      }
      if (promises.length) {
        return promises;
      }
    }
    _created() {}
    _setKey() {
      if (this.props.key) {
        this.key = this.props.key;
        if (isFunction(this.props.key)) {
          this.key = this.props.key.call(this, this);
        }
      }
      if (this.key === undefined || this.key === null) {
        this.key = `__key${++keySeq}`;
      }
    }
    config() {
      this._setExpandableProps();
      this._setSelectableProps();
      this.props._config && this.props._config.call(this, this);
      isFunction(this.props.onConfig) &&
        this.props.onConfig({ inst: this, props: this.props });
      if (this._callMixin("_config") !== false) {
        isFunction(this._config) && this._config();
      }
      this._setExpandableProps();
      this._setSelectableProps();
      this._setStatusProps();
    }
    _config() {}
    render() {
      try {
        if (this.rendered === true) {
          this.emptyChildren();
        } else {
          this._mountElement();
        }
        this._handleAttrs();
        this._handleStyles();
        this._renderChildren();
        this.props.disabled === true &&
          isFunction(this._disable) &&
          this._disable();
        this.props.selected === true &&
          isFunction(this._select) &&
          this._select();
        this.props.hidden === false && isFunction(this._show) && this._show();
        this.props.expanded === true &&
          isFunction(this._expand) &&
          this._expand();
        this.props.selected === true && this._triggerSelectOnInit();
        this._callRendered();
      } catch (error) {
        console.error("Render failed for component", this, error);
      }
    }
    _triggerSelectOnInit() {
      if (this.props.selectable.triggerOnInit === true) {
        this._callHandler(this.props.onSelect, null);
        this._callHandler(this.props.onSelectionChange);
      }
    }
    _callRendered() {
      this.rendered = true;
      isFunction(this._rendered) && this._rendered();
      this._callMixin("_rendered");
      isFunction(this.props._rendered) && this.props._rendered.call(this, this);
      isFunction(this.props.onRendered) &&
        this.props.onRendered({
          inst: this,
          props: this.props,
          isUpdate: this.firstRender === false,
        });
      this.firstRender = false;
    }
    _rendered() {} // todo: 
    remove() {
      if (!this.props) {
        return;
      }
      const el = this._removeCore();
      this.parent &&
        this.parent.hasOwnProperty("removeChild") &&
        this.parent.removeChild(this);
      el.parentNode && el.parentNode.removeChild(el);
    }
    update(props) {
      isFunction(this._update) && this._update(props);
      this._propStyleClasses.length = 0;
      this.setProps(props);
      this._off();
      this.off();
      this.config();
      this.render();
    }
    replace(props) {
      let newProps = props;
      let newMixins = [];
      if (props instanceof ComponentDescriptor) {
        newProps = props.getProps();
        newMixins = props.mixins;
      }
      this.__inReplace = true;
      if (!newProps.component) {
        newProps.component = this.props.component;
      }
      if (!newProps.ref) {
        newProps.ref = this.props.ref;
      }
      return Component.create(
        Component.extendProps(newProps, {
          placement: "replace",
          reference: this,
        }),
        ...newMixins
      );
    }
    emptyChildren() {
      while (this.element.firstChild) {
        const el = this.element.firstChild;
        if (el.component && el.component.props) {
          el.component.remove();
        } else {
          el.parentNode && el.parentNode.removeChild(el);
        }
      }
    }
    offsetWidth() {
      return this.element.offsetWidth;
    }
    _mountPlaceHolder() {
      const { placement } = this.props;
      this._placeHolderElement = document.createElement("div");
      this._placeHolderElement.classList.add("placeholder");
      const { placeholderProps } = this.props;
      if (isPlainObject(placeholderProps)) {
        const { width, height, loading } = placeholderProps;
        if (width) {
          this._placeHolderElement.style.width = isNumeric(width)
            ? `${width}px`
            : width;
        }
        if (height) {
          this._placeHolderElement.style.height = isNumeric(height)
            ? `${height}px`
            : height;
        }
        if (loading) {
          this._placeHolderElement.classList.add(
            "nom-placeholder-element-loading"
          );
        }
      }
      if (placement === "append") {
        this.referenceElement.appendChild(this._placeHolderElement);
      } else if (placement === "prepend") {
        this.referenceElement.insertBefore(
          this._placeHolderElement,
          this.referenceElement.firstChild
        );
      } else if (placement === "after") {
        this.referenceElement.insertAdjacentElement(
          "afterend",
          this._placeHolderElement
        );
      } else if (placement === "before") {
        this.referenceElement.insertAdjacentElement(
          "beforebegin",
          this._placeHolderElement
        );
      } else if (placement === "replace") {
        this._placeHolderElement = this.referenceElement;
      }
    }
    _mountElement() {
      const { placement } = this.props;
      this.element = document.createElement(this.props.tag);
      this.element.component = this;
      if (this._placeHolderElement) {
        this._placeHolderElement.parentNode &&
          this._placeHolderElement.parentNode.replaceChild(
            this.element,
            this._placeHolderElement
          );
        return;
      }
      if (placement === "append") {
        this.referenceElement.appendChild(this.element);
      } else if (placement === "prepend") {
        this.referenceElement.insertBefore(
          this.element,
          this.referenceElement.firstChild
        );
      } else if (placement === "replace") {
        this.referenceElement.parentNode.replaceChild(
          this.element,
          this.referenceElement
        );
      } else if (placement === "after") {
        this.referenceElement.insertAdjacentElement("afterend", this.element);
      } else if (placement === "before") {
        this.referenceElement.insertAdjacentElement(
          "beforebegin",
          this.element
        );
      }
    }
    getComponent(componentOrElement) {
      return componentOrElement instanceof Component
        ? componentOrElement
        : componentOrElement.component;
    }
    getElement(componentOrElement) {
      return componentOrElement instanceof Component
        ? componentOrElement.element
        : componentOrElement;
    }
    _renderChildren() {
      const { children } = this.props;
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          if (children[i] && children[i].renderIf !== false) {
            this.appendChild(children[i]);
          }
        }
      } else if (children === 0) {
        this.appendChild(`${children}`);
      } else if (children && children.renderIf !== false) {
        this.appendChild(children);
      }
    }
    _cleanupUnusedContexts() {
      // context
      if (this._componentContext) {
        nomGlobalContexts.delete(this);
        const index = nomComponentStack.findIndex(
          (ref) => ref.deref() === this
        );
        if (index !== -1) {
          nomComponentStack.splice(index, 1);
        }
      }
      cleanupStaleContexts(); // context
    }
    _removeCore() {
      this._removeContextWatcher(); // context watcher
      this._cleanupUnusedContexts(); // context
      this.props &&
        isFunction(this.props._remove) &&
        this.props._remove.call(this, this);
      let el = this.element;
      if (el) {
        this.emptyChildren();
      } else {
        el = this._placeHolderElement;
      }
      this.props &&
        isFunction(this.props.onRemove) &&
        this.props.onRemove({ inst: this, props: this.props });
      this._callMixin("_remove");
      isFunction(this._remove) && this._remove();
      this.trigger("remove");
      this._off();
      this.off();
      if (!this.__inReplace) {
        this.props.ref && this.props.ref(null);
      }
      for (const p in this) {
        if (this.hasOwnProperty(p)) {
          delete this[p];
        }
      }
      return el;
    }
    _remove() {}
    _callMixin(hookType) {
      const mixinsList = [...MIXINS, ...this.mixins];
      let abort = false; // return false
      for (let i = 0; i < mixinsList.length; i++) {
        const mixin = mixinsList[i];
        const hookContinue =
          mixin[hookType] && mixin[hookType].call(this, this);
        if (hookContinue === false) {
          abort = true;
        }
      }
      if (abort) {
        return false;
      }
    }
    setProps(newProps) {
      this.props = Component.extendProps(this.props, newProps);
    }
    assignProps(newProps) {
      this.props = Object.assign({}, this.props, newProps);
    }
    appendChild(child) {
      if (!child) {
        return;
      }
      const childDefaults = this.props.childDefaults;
      let childDefaultsProps = {};
      let childDefaultsMixins = [];
      let childProps = {};
      let childMixins = [];
      let props = {};
      let mixins = [];
      if (childDefaults) {
        if (isPlainObject(childDefaults)) {
          childDefaultsProps = childDefaults;
        } else if (childDefaults instanceof ComponentDescriptor) {
          childDefaultsProps = childDefaults.getProps();
          childDefaultsMixins = childDefaults.mixins;
        }
      }
      if (isPlainObject(child)) {
        childProps = child;
      } else if (child instanceof ComponentDescriptor) {
        childProps = child.getProps();
        childMixins = child.mixins;
      } else if (isString(child) || isNumeric(child)) {
        if (isPlainObject(childDefaults)) {
          childProps = { children: child };
        } else if (child[0] === "#") {
          this.element.innerHTML = child.slice(1);
          return;
        } else {
          this.element.textContent = child;
          return;
        }
      } else if (child instanceof DocumentFragment) {
        this.element.appendChild(child);
        return;
      }
      props = Component.extendProps({}, childDefaultsProps, childProps, {
        reference: this.element,
        placement: "append",
      });
      mixins = [...childDefaultsMixins, ...childMixins];
      const compt = Component.create(props, ...mixins);
      return compt;
    }
    prependChild(child) {
      if (!child) {
        return;
      }
      const childDefaults = this.props.childDefaults;
      let childDefaultsProps = {};
      let childDefaultsMixins = [];
      let childProps = {};
      let childMixins = [];
      let props = {};
      let mixins = [];
      if (childDefaults) {
        if (isPlainObject(childDefaults)) {
          childDefaultsProps = childDefaults;
        } else if (childDefaults instanceof ComponentDescriptor) {
          childDefaultsProps = childDefaults.getProps();
          childDefaultsMixins = childDefaults.mixins;
        }
      }
      if (isPlainObject(child)) {
        childProps = child;
      } else if (child instanceof ComponentDescriptor) {
        childProps = child.getProps();
        childMixins = child.mixins;
      } else if (isString(child) || isNumeric(child)) {
        if (isPlainObject(childDefaults)) {
          childProps = { children: child };
        } else if (child[0] === "#") {
          this.element.innerHTML = child.slice(1);
          return;
        } else {
          this.element.textContent = child;
          return;
        }
      } else if (child instanceof DocumentFragment) {
        this.referenceElement.insertBefore(
          child,
          this.referenceElement.firstChild
        );
        return;
      }
      props = Component.extendProps({}, childDefaultsProps, childProps, {
        reference: this.element,
        placement: "prepend",
      });
      mixins = [...childDefaultsMixins, ...childMixins];
      const compt = Component.create(props, ...mixins);
      return compt;
    }
    before(props) {
      if (!props) {
        return;
      }
      const { normalizedProps, mixins } = this._normalizeProps(props);
      const extNormalizedProps = Component.extendProps({}, normalizedProps, {
        reference: this.element,
        placement: "before",
      });
      return Component.create(extNormalizedProps, ...mixins);
    }
    after(props) {
      if (!props) {
        return;
      }
      let { normalizedProps, mixins } = this._normalizeProps(props);
      normalizedProps = Component.extendProps({}, normalizedProps, {
        reference: this.element,
        placement: "after",
      });
      if (this.parent && this.parent.props.childDefaults) {
        const {
          normalizedProps: childDefaultsProps,
          mixins: childDefaultsMixins,
        } = this._normalizeProps(this.parent.props.childDefaults);
        normalizedProps = Component.extendProps(
          childDefaultsProps,
          normalizedProps
        );
        mixins = [...childDefaultsMixins, ...mixins];
      }
      return Component.create(normalizedProps, ...mixins);
    }
    _normalizeProps(props) {
      let normalizedProps = {};
      let mixins = [];
      if (isPlainObject(props)) {
        normalizedProps = props;
      } else if (props instanceof ComponentDescriptor) {
        normalizedProps = props.getProps();
        mixins = props.mixins;
      } else if (isString(props) || isNumeric(props)) {
        normalizedProps = { children: props };
      }
      return { normalizedProps, mixins };
    }
    disable() {
      if (!this.rendered || this.props.disabled === true) {
        return;
      }
      this.props.disabled = true;
      this.addClass("s-disabled");
      isFunction(this._disable) && this._disable();
    }
    enable() {
      if (!this.rendered || this.props.disabled === false) {
        return;
      }
      this.props.disabled = false;
      this.removeClass("s-disabled");
      isFunction(this._enable) && this._enable();
    }
    show() {
      if (!this.rendered) {
        this.setProps({ hidden: false });
        this.config();
        this.render();
        return;
      }
      if (this.props.hidden === false) {
        return;
      }
      this.props.hidden = false;
      this.removeClass("s-hidden");
      isFunction(this._show) && this._show();
    }
    hide() {
      if (!this.rendered || this.props.hidden === true) {
        return;
      }
      this.props.hidden = true;
      this.addClass("s-hidden");
      this._callHandler(this.props.onHide);
      isFunction(this._hide) && this._hide();
    }
    select(selectOption) {
      if (!this.rendered) {
        return;
      }
      selectOption = extend(
        { triggerSelect: true, triggerSelectionChange: true },
        selectOption
      );
      if (this.props.selected === false) {
        this.props.selected = true;
        this.addClass("s-selected");
        const { selectedProps } = this.props.selectable;
        if (selectedProps) {
          this.update(selectedProps);
        }
        isFunction(this._select) && this._select();
        selectOption.triggerSelect === true &&
          this._callHandler(this.props.onSelect, null, selectOption.event);
        selectOption.triggerSelectionChange === true &&
          this._callHandler(this.props.onSelectionChange);
        return true;
      }
      return false;
    }
    unselect(unselectOption) {
      if (!this.rendered) {
        return;
      }
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      if (this.props.selected === true) {
        this.props.selected = false;
        this.removeClass("s-selected");
        const { unselectedProps } = this.props.selectable;
        if (unselectedProps) {
          this.update(unselectedProps);
        }
        isFunction(this._unselect) && this._unselect();
        if (unselectOption.triggerUnselect === true && this.props) {
          this._callHandler(this.props.onUnselect, null, unselectOption.event);
        }
        if (unselectOption.triggerSelectionChange === true && this.props) {
          this._callHandler(this.props.onSelectionChange);
        }
        return true;
      }
      return false;
    }
    toggleSelect(event) {
      if (!this.rendered) return;
      const { selected, selectable } = this.props;
      if (selectable && selectable.canRevert === false && selected === true) {
        return;
      }
      this.props.selected === true
        ? this.unselect({ event: event })
        : this.select({ event });
    }
    expand() {
      if (!this.rendered) return;
      if (this.props.expanded === true) return;
      this.props.expanded = true;
      this.addClass("s-expanded");
      const expandTarget = this._getExpandTarget();
      if (expandTarget !== null && expandTarget !== undefined) {
        if (Array.isArray(expandTarget)) {
          expandTarget.forEach((t) => {
            // t.addClass('nom-expandable-animate-show')
            t.show && t.show();
          });
        } else {
          // expandTarget.addClass('nom-expandable-animate-show')
          expandTarget.show && expandTarget.show();
        }
      }
      this._expandIndicator && this._expandIndicator.expand();
      const { expandedProps } = this.props.expandable;
      if (expandedProps) {
        this.update(expandedProps);
      }
      isFunction(this._expand) && this._expand();
    }
    collapse() {
      if (!this.rendered) return;
      if (this.props.expanded === false) return;
      this.props.expanded = false;
      this.removeClass("s-expanded");
      const expandTarget = this._getExpandTarget();
      if (expandTarget !== null && expandTarget !== undefined) {
        if (Array.isArray(expandTarget)) {
          expandTarget.forEach((t) => {
            t.hide && t.hide(); // t.addClass('nom-expandable-animate-hide')
            // setTimeout(() => {
            //   t.hide && t.hide()
            //   t.removeClass('nom-expandable-animate-show')
            //   t.removeClass('nom-expandable-animate-hide')
            // }, 120)
          });
        } else {
          expandTarget.hide && expandTarget.hide(); // expandTarget.addClass('nom-expandable-animate-hide')
          // setTimeout(() => {
          //   expandTarget.hide && expandTarget.hide()
          //   expandTarget.removeClass('nom-expandable-animate-show')
          //   expandTarget.removeClass('nom-expandable-animate-hide')
          // }, 120)
        }
      }
      this._expandIndicator && this._expandIndicator.collapse();
      isFunction(this._collapse) && this._collapse();
      const { collapsedProps } = this.props.expandable;
      if (collapsedProps) {
        this.update(collapsedProps);
      }
    }
    toggleExpand() {
      this.props.expanded === true ? this.collapse() : this.expand();
    }
    toggleHidden() {
      this.props.hidden === true ? this.show() : this.hide();
    }
    addClass(className) {
      this.element.classList.add(className);
    }
    removeClass(className) {
      this.element.classList.remove(className);
    }
    _setExpandableProps() {
      const that = this;
      const { expandable, expanded } = this.props;
      if (isPlainObject(expandable)) {
        if (isPlainObject(expandable.indicator)) {
          this.setProps({
            expandable: {
              indicator: {
                expanded: expanded,
                _created: function () {
                  that._expandIndicator = this;
                },
              },
            },
          });
        }
        if (this.props.expanded) {
          if (expandable.expandedProps) {
            this.setProps(expandable.expandedProps);
          }
        } else if (expandable.collapsedProps) {
          this.setProps(expandable.collapsedProps);
        }
      }
    }
    _setSelectableProps() {
      const { selectable, selected } = this.props;
      if (isPlainObject(selectable)) {
        if (selected) {
          if (selectable.selectedProps) {
            this.setProps(selectable.selectedProps);
          }
        } else if (selectable.unselectedProps) {
          this.setProps(selectable.unselectedProps);
        }
      }
    }
    _setStatusProps() {
      const { props } = this;
      this.setProps({
        classes: {
          "s-disabled": props.disabled,
          "s-selected": props.selected,
          "s-hidden": props.hidden,
          "s-expanded": props.expanded,
        },
      });
    }
    _getExpandTarget() {
      const { target } = this.props.expandable;
      if (target === undefined || target === null) {
        return null;
      }
      if (target instanceof Component) {
        return target;
      }
      if (isFunction(target)) {
        return target.call(this, this);
      }
    }
    getExpandableIndicatorProps(expanded = null) {
      const that = this;
      const {
        indicator,
        byIndicator,
        byClick,
        byHover,
      } = this.props.expandable;
      if (expanded == null) {
        expanded = this.props.expanded;
      }
      if (indicator === undefined || indicator === null) {
        return null;
      }
      if (isPlainObject(indicator)) {
        this.setProps({
          expandable: {
            indicator: {
              expanded: expanded,
              _created: function () {
                that._expandIndicator = this;
              },
            },
          },
        });
        if (byIndicator === true) {
          if (byClick === true) {
            this.setProps({
              expandable: {
                indicator: {
                  attrs: {
                    onclick: (event) => {
                      that.toggleExpand();
                      event.stopPropagation();
                    },
                  },
                },
              },
            });
          }
          if (byHover === true) {
            this.setProps({
              expandable: {
                indicator: {
                  attrs: {
                    onmouseenter: (event) => {
                      that.expand();
                      event.stopPropagation();
                    },
                    onmouseleave: (event) => {
                      that.collapse();
                      event.stopPropagation();
                    },
                  },
                },
              },
            });
          }
        }
      }
      return this.props.expandable.indicator;
    }
    getChildren() {
      const children = [];
      for (let i = 0; i < this.element.childNodes.length; i++) {
        children.push(this.element.childNodes[i].component);
      }
      return children;
    }
    findChild(key) {
      let find = null;
      for (let i = 0; i < this.element.childNodes.length; i++) {
        const child = this.element.childNodes[i].component;
        if (child.key === key) {
          find = child;
          break;
        }
      }
      return find;
    }
    _handleAttrs() {
      this._processClick();
      this._processHover();
      for (const name in this.props.attrs) {
        const value = this.props.attrs[name];
        if (value == null) continue;
        if (name === "style") {
          this._setStyle(value);
        } else if (name[0] === "o" && name[1] === "n") {
          this._on(name.slice(2), value);
        } else if (
          name !== "list" &&
          name !== "tagName" &&
          name !== "form" &&
          name !== "type" &&
          name !== "size" &&
          name in this.element
        ) {
          this.element[name] = value == null ? "" : value;
        } else {
          this.element.setAttribute(name, value);
        }
      }
    }
    _handleStyles() {
      const { props } = this;
      const classes = [];
      let propClasses = [];
      const componentTypeClasses = this._getComponentTypeClasses(this);
      for (let i = 0; i < componentTypeClasses.length; i++) {
        const componentTypeClass = componentTypeClasses[i];
        classes.push(`${props.prefixClass}${hyphenate(componentTypeClass)}`);
      }
      propClasses = propClasses.concat(this._propStyleClasses);
      if (props.type) {
        propClasses.push("type");
      }
      if (props.uistyle) {
        propClasses.push("uistyle");
      }
      for (let i = 0; i < propClasses.length; i++) {
        const modifier = propClasses[i];
        const modifierVal = this.props[modifier];
        if (modifierVal !== null && modifierVal !== undefined) {
          if (modifierVal === true) {
            classes.push(`p-${hyphenate(modifier)}`);
          } else if (
            typeof modifierVal === "string" ||
            typeof modifierVal === "number"
          ) {
            classes.push(
              `p-${hyphenate(modifier)}-${hyphenate(String(modifierVal))}`
            );
          }
        }
      }
      if (isPlainObject(props.classes)) {
        for (const className in props.classes) {
          if (
            props.classes.hasOwnProperty(className) &&
            props.classes[className] === true
          ) {
            classes.push(className);
          }
        }
      }
      const { styles } = props;
      if (isPlainObject(styles)) {
        addStylesClass(styles);
      }
      function addStylesClass(_styles, className) {
        className = className || "";
        if (isPlainObject(_styles)) {
          for (const style in _styles) {
            if (_styles.hasOwnProperty(style)) {
              addStylesClass(_styles[style], `${className}-${style}`);
            }
          }
        } else if (Array.isArray(_styles)) {
          for (let i = 0; i < _styles.length; i++) {
            if (isString(_styles[i]) || isNumeric(_styles)) {
              classes.push(`u${className}-${_styles[i]}`);
            } else if (_styles[i] === true) {
              classes.push(`u${className}`);
            }
          }
        } else if (isString(_styles) || isNumeric(_styles)) {
          classes.push(`u${className}-${_styles}`);
        } else if (_styles === true) {
          classes.push(`u${className}`);
        }
      }
      if (classes.length) {
        const classNames = classes.join(" ");
        this.element.setAttribute("class", classNames);
      }
    }
    _processClick() {
      const { onClick, selectable, expandable } = this.props;
      if (
        onClick ||
        (selectable && selectable.byClick === true) ||
        (expandable && expandable.byClick && !expandable.byIndicator)
      ) {
        this.setProps({ attrs: { onclick: this.__handleClick } });
      }
    }
    __handleClick(event) {
      if (
        this.props._shouldHandleClick &&
        this.props._shouldHandleClick.call(this, this) === false
      ) {
        return;
      }
      if (this.props.disabled === true) {
        return;
      }
      const { onClick, selectable, expandable } = this.props;
      onClick && this._callHandler(onClick, null, event);
      if (selectable && selectable.byClick === true) {
        this.toggleSelect(event);
      }
      if (
        expandable &&
        expandable.byClick === true &&
        !expandable.byIndicator
      ) {
        this.toggleExpand();
      }
    }
    _processHover() {
      const { onClick, selectable, expandable } = this.props;
      if (
        onClick ||
        (selectable && selectable.byHover === true) ||
        (expandable && expandable.byHover && !expandable.byIndicator)
      ) {
        this.setProps({
          attrs: {
            onmouseenter: this.__handleMouseEnter,
            onmouseleave: this.__handleMouseLeave,
          },
        });
      }
    }
    __handleMouseEnter() {
      const {
        _shouldHandleClick,
        disabled,
        selectable,
        expandable,
      } = this.props;
      if (_shouldHandleClick && _shouldHandleClick.call(this, this) === false) {
        return;
      }
      if (disabled === true) {
        return;
      }
      if (selectable && selectable.byHover === true) {
        this.select();
      }
      if (expandable && expandable.byHover === true) {
        this.expand();
      }
    }
    __handleMouseLeave() {
      const {
        _shouldHandleClick,
        disabled,
        selectable,
        expandable,
      } = this.props;
      if (_shouldHandleClick && _shouldHandleClick.call(this, this) === false) {
        return;
      }
      if (disabled === true) {
        return;
      }
      if (selectable && selectable.byHover === true) {
        this.unselect();
      }
      if (expandable && expandable.byHover === true) {
        this.collapse();
      }
    }
    _callHandler(handler, argObj, event) {
      argObj = isPlainObject(argObj) ? argObj : {};
      event && (argObj.event = event);
      argObj.sender = this;
      if (handler) {
        if (isFunction(handler)) {
          return handler(argObj);
        }
        if (isString(handler) && isFunction(this.props[handler])) {
          return this.props[handler](argObj);
        }
      }
    }
    _setStyle(style) {
      const { element } = this;
      if (typeof style !== "object") {
        // New style is a string, let engine deal with patching.
        element.style.cssText = style;
      } else {
        // `old` is missing or a string, `style` is an object.
        element.style.cssText = ""; // Add new style properties
        for (const key in style) {
          const value = style[key];
          if (value != null)
            element.style.setProperty(normalizeKey(key), String(value));
        }
      }
    }
    _getComponentTypeClasses(instance) {
      const classArray = [];
      let ctor = instance.constructor;
      while (ctor && ctor.name !== "Component") {
        classArray.unshift(ctor.name);
        ctor = ctor.__proto__.prototype.constructor;
      }
      return classArray;
    }
    _on(event, callback) {
      /* if (context) {
              callback = callback.bind(context)
          }
          else {
              callback = callback.bind(this)
          } */ const cache =
        this.__htmlEvents || (this.__htmlEvents = {});
      const list = cache[event] || (cache[event] = []);
      list.push(callback);
      this.element.addEventListener(event, callback, false);
    }
    _off(event, callback) {
      let cache;
      let i; // No events, or removing *all* events.
      if (!(cache = this.__htmlEvents)) return this;
      if (!(event || callback)) {
        for (const key in this.__htmlEvents) {
          if (this.__htmlEvents.hasOwnProperty(key)) {
            const _list = this.__htmlEvents[key];
            if (!_list) continue;
            for (i = _list.length - 1; i >= 0; i -= 1) {
              this.element.removeEventListener(key, _list[i], false);
            }
          }
        }
        delete this.__htmlEvents;
        return this;
      }
      const list = cache[event];
      if (!list) return;
      if (!callback) {
        delete cache[event];
        return;
      }
      for (i = list.length - 1; i >= 0; i -= 1) {
        if (list[i] === callback) {
          list.splice(i, 1);
          this.element.removeEventListener(event, callback, false);
        }
      }
    } //  context 
    _handleContext(props) {
      if (props.context) {
        this._componentContext = isFunction(props.context)
          ? props.context.call(this, this)
          : props.context; // 
        registerComponentContext(this, this._componentContext);
      }
    }
    /**
     * context
     * @param {string|string[]} contextKeys 
     * @returns {any|Object} 
     */ getContext(contextKeys) {
      // 
      const keys = Array.isArray(contextKeys) ? contextKeys : [contextKeys];
      const result = {}; // 1. Context
      for (const key of keys) {
        if (
          this._componentContext &&
          this._componentContext[key] !== undefined
        ) {
          result[key] = this._componentContext[key];
        }
      } // key
      if (Object.keys(result).length === keys.length) {
        return Array.isArray(contextKeys) ? result : result[contextKeys];
      }
      const visited = new Set(); // 
      let current = this.parent;
      while (current && !visited.has(current)) {
        visited.add(current); // context
        const context = nomGlobalContexts.get(current);
        if (context) {
          for (const key of keys) {
            if (result[key] === undefined && context[key] !== undefined) {
              result[key] = context[key]; // key
              if (Object.keys(result).length === keys.length) {
                return Array.isArray(contextKeys)
                  ? result
                  : result[contextKeys];
              }
            }
          }
        } // Popupopener
        current = current.opener || current.parent;
      }
      return Array.isArray(contextKeys) ? result : result[contextKeys];
    }
    /**
     *  context 
     * @param {Object} contextData  context 
     */ setContext(contextData) {
      if (!isPlainObject(contextData)) {
        throw new Error("setContext ");
      }
      const sender = this;
      const visited = new Set(); // 
      let current = this; //  contextData  key
      for (const [key, value] of ((target) =>
        Object.keys(target).map((key) => [key, target[key]]))(contextData)) {
        let contextSet = false;
        let targetRef = null; // 
        // 
        while (current && !visited.has(current)) {
          visited.add(current);
          if (
            current._componentContext &&
            current._componentContext[key] !== undefined
          ) {
            current._componentContext[key] = value;
            contextSet = true;
            targetRef = current;
            break;
          }
          const globalContext = nomGlobalContexts.get(current);
          if (globalContext && globalContext[key] !== undefined) {
            globalContext[key] = value;
            contextSet = true;
            targetRef = current;
            break;
          }
          current = current.opener || current.parent;
        }
        if (!contextSet) {
          console.warn(` key  "${key}"  context`);
        } //  targetRef 
        if (nomuiContextWatchers[key]) {
          nomuiContextWatchers[key].forEach(({ callback, ref, watcher }) => {
            if (ref === targetRef) {
              try {
                callback({ key, value, ref: targetRef, sender, watcher });
              } catch (e) {
                console.error("contextChange global listener error:", e);
              }
            }
          });
        }
        current = this;
      }
    }
    /**
     * popupkeycontextcontext
     * @param {string|string[]} contextKeys
     * @param {function} callback
     */ addContextListener(contextKeys, callback) {
      const keys = Array.isArray(contextKeys) ? contextKeys : [contextKeys];
      keys.forEach((key) => {
        let current = this;
        const visited = new Set();
        let foundRef = null;
        while (current && !visited.has(current)) {
          visited.add(current);
          if (
            current._componentContext &&
            current._componentContext[key] !== undefined
          ) {
            foundRef = current;
            break;
          }
          const globalContext = nomGlobalContexts.get(current);
          if (globalContext && globalContext[key] !== undefined) {
            foundRef = current;
            break;
          }
          current = current.opener || current.parent;
        }
        if (foundRef) {
          if (!nomuiContextWatchers[key]) {
            nomuiContextWatchers[key] = [];
          }
          nomuiContextWatchers[key].push({
            watcher: this,
            callback,
            ref: foundRef,
          });
        }
      });
    }
    /**
     * context
     * @param {string|string[]} contextKeys
     * @param {function} callback
     */ removeContextListener(contextKeys, callback) {
      const keys = Array.isArray(contextKeys) ? contextKeys : [contextKeys];
      keys.forEach((key) => {
        if (nomuiContextWatchers[key]) {
          nomuiContextWatchers[key] = nomuiContextWatchers[key].filter(
            (item) => item.watcher !== this || item.callback !== callback
          );
        }
      });
    }
    _removeContextWatcher() {
      // context
      // 1. thiswatcher
      for (const key in nomuiContextWatchers) {
        if (!Array.isArray(nomuiContextWatchers[key])) continue; // 
        nomuiContextWatchers[key] = nomuiContextWatchers[key].filter(
          (item) => item.watcher !== this
        ); // targetRef
        nomuiContextWatchers[key] = nomuiContextWatchers[key].filter(
          (item) => item.ref !== this
        ); // key
        if (nomuiContextWatchers[key].length === 0) {
          delete nomuiContextWatchers[key];
        }
      }
    }
    _trigger(eventName) {
      const event = new Event(eventName);
      this.element.dispatchEvent(event);
    }
    _addPropStyle(...props) {
      props.forEach((value) => {
        this._propStyleClasses.push(value);
      });
    }
    _mixin(mixins) {
      for (let i = 0; i < mixins.length; i++) {
        const mixin = mixins[i];
        if (isPlainObject(mixin) && isPlainObject(mixin.methods)) {
          for (const key in mixin.methods) {
            if (mixin.methods.hasOwnProperty(key)) {
              if (!this[key]) {
                this[key] = mixin.methods[key];
              }
            }
          }
        }
      }
      this.mixins = [...this.mixins, ...mixins];
    }
    static create(componentProps, ...mixins) {
      let componentType = componentProps.component;
      if (isString(componentType)) {
        componentType = components[componentType];
      }
      if (componentType === undefined || componentType === null) {
        componentType = Component;
      }
      return new componentType(componentProps, ...mixins);
    }
    static register(component, name) {
      if (name !== undefined) {
        components[name] = component;
      } else {
        components[component.name] = component;
      }
    }
    static extendProps(...args) {
      return extend(true, {}, ...args);
    }
    static mixin(mixin) {
      MIXINS.push(mixin);
    } //  key  context
    static getContextByKey(key) {
      return nomGlobalContexts.get(key);
    } // 
    static getComponentStack() {
      return [...nomComponentStack];
    } //  context 
    static findNearestContext(key) {
      for (let i = nomComponentStack.length - 1; i >= 0; i--) {
        const componentRef = nomComponentStack[i];
        const component = componentRef.deref();
        if (!component) {
          nomComponentStack.splice(i, 1); // 
          continue;
        }
        const context = nomGlobalContexts.get(component);
        if (context && context[key]) {
          return context[key];
        }
      }
      return null;
    }
  }
  Component.normalizeTemplateProps = function (props) {
    if (props === null || props === undefined) {
      return null;
    }
    let templateProps = {};
    if (isString(props)) {
      templateProps.children = props;
    } else {
      templateProps = props;
    }
    return templateProps;
  };
  Component.components = components;
  Component.mixins = MIXINS;
  Object.assign(Component.prototype, Events.prototype);
  Object.defineProperty(Component.prototype, "children", {
    get: function () {
      return this.getChildren();
    },
  });
  function n$1(tagOrComponent, props, children, mixins) {
    if (arguments.length === 2) {
      return new ComponentDescriptor(null, tagOrComponent, null, props);
    }
    return new ComponentDescriptor(tagOrComponent, props, children, mixins);
  }
  let zIndex = 6666;
  function getzIndex() {
    zIndex++;
    return ++zIndex;
  }
  /* eslint-disable no-shadow */ let cachedScrollbarWidth;
  const { max } = Math;
  const { abs } = Math;
  const rhorizontal = /left|center|right/;
  const rvertical = /top|center|bottom/;
  const roffset = /[\+\-]\d+(\.[\d]+)?%?/;
  const rposition = /^\w+/;
  const rpercent = /%$/;
  function getOffsets(offsets, width, height) {
    return [
      parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
      parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1),
    ];
  }
  function parseCss(element, property) {
    return parseInt(getComputedStyle(element)[property], 10) || 0;
  }
  function isWindow(obj) {
    return obj != null && obj === obj.window;
  }
  function getScrollTop(el) {
    const hasScrollTop = "scrollTop" in el;
    return hasScrollTop
      ? el.scrollTop
      : isWindow(el)
      ? el.pageYOffset
      : el.defaultView.pageYOffset;
  }
  function getScrollLeft(el) {
    const hasScrollLeft = "scrollLeft" in el;
    return hasScrollLeft
      ? el.scrollLeft
      : isWindow(el)
      ? el.pageXOffset
      : el.defaultView.pageXOffset;
  }
  function getOffsetParent(el) {
    return el.offsetParent || el;
  }
  function setOffset(elem, coordinates, offset) {
    if (!offset) {
      offset = [0, 0];
    }
    const parentOffset = getOffsetParent(elem).getBoundingClientRect();
    let props = {
      top: coordinates.top - parentOffset.top,
      left: coordinates.left - parentOffset.left,
    };
    if (getOffsetParent(elem).tagName.toLowerCase() === "body") {
      props = { top: coordinates.top, left: coordinates.left };
    }
    if (getComputedStyle(elem).position === "static")
      props.position = "relative";
    elem.style.top = `${props.top + (offset[1] || 0)}px`;
    elem.style.left = `${props.left + (offset[0] || 0)}px`;
    elem.style.position = props.position;
  }
  function getOffset$1(elem) {
    if (
      document.documentElement !== elem &&
      !document.documentElement.contains(elem)
    )
      return { top: 0, left: 0 };
    const obj = elem.getBoundingClientRect();
    return {
      left: obj.left + window.pageXOffset,
      top: obj.top + window.pageYOffset,
      width: Math.round(obj.width),
      height: Math.round(obj.height),
    };
  }
  function getDimensions(elem) {
    if (elem.nodeType === 9) {
      return {
        width: elem.documentElement.scrollWidth,
        height: elem.documentElement.scrollHeight,
        offset: { top: 0, left: 0 },
      };
    }
    if (isWindow(elem)) {
      return {
        width: elem.innerWidth,
        height: elem.innerHeight,
        offset: { top: elem.pageYOffset, left: elem.pageXOffset },
      };
    }
    if (elem.preventDefault) {
      return {
        width: 0,
        height: 0,
        offset: { top: elem.pageY, left: elem.pageX },
      };
    }
    const elemOffset = elem.getBoundingClientRect();
    return {
      width: elem.offsetWidth,
      height: elem.offsetHeight,
      offset: {
        left: elemOffset.left + window.pageXOffset,
        top: elemOffset.top + window.pageYOffset,
      },
    };
  }
  const positionTool = {
    scrollbarWidth: function () {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      const scrollDiv = document.createElement("div");
      scrollDiv.className = "modal-scrollbar-measure";
      document.body.appendChild(scrollDiv);
      const scrollbarWidth =
        scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      cachedScrollbarWidth = scrollbarWidth;
      return cachedScrollbarWidth;
    },
    getScrollInfo: function (within) {
      const overflowX =
        within.isWindow || within.isDocument
          ? ""
          : getComputedStyle(within.element).overflowX;
      const overflowY =
        within.isWindow || within.isDocument
          ? ""
          : getComputedStyle(within.element).overflowY;
      const hasOverflowX =
        overflowX === "scroll" ||
        (overflowX === "auto" && within.width < within.element.scrollWidth);
      const hasOverflowY =
        overflowY === "scroll" ||
        (overflowY === "auto" && within.height < within.element.scrollHeight);
      return {
        width: hasOverflowY ? positionTool.scrollbarWidth() : 0,
        height: hasOverflowX ? positionTool.scrollbarWidth() : 0,
      };
    },
    getWithinInfo: function (element) {
      const withinElement = element || window;
      const isElemWindow = isWindow(withinElement);
      const isDocument = !!withinElement && withinElement.nodeType === 9;
      const hasOffset = !isElemWindow && !isDocument;
      return {
        element: withinElement,
        isWindow: isElemWindow,
        isDocument: isDocument,
        offset: hasOffset ? getOffset$1(element) : { left: 0, top: 0 },
        scrollLeft: getScrollLeft(withinElement),
        scrollTop: getScrollTop(withinElement),
        width: isWindow ? withinElement.innerWidth : withinElement.offsetWidth,
        height: isWindow
          ? withinElement.innerHeight
          : withinElement.offsetHeight,
      };
    },
  };
  const positionFns = {
    fit: {
      left: function (position, data) {
        const { within } = data;
        const withinOffset = within.isWindow
          ? within.scrollLeft
          : within.offset.left;
        const outerWidth = within.width;
        const collisionPosLeft =
          position.left - data.collisionPosition.marginLeft;
        const overLeft = withinOffset - collisionPosLeft;
        const overRight =
          collisionPosLeft + data.collisionWidth - outerWidth - withinOffset;
        let newOverRight; // Element is wider than within
        if (data.collisionWidth > outerWidth) {
          // Element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight =
              position.left +
              overLeft +
              data.collisionWidth -
              outerWidth -
              withinOffset;
            position.left += overLeft - newOverRight; // Element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset; // Element is initially over both left and right sides of within
          } else if (overLeft > overRight) {
            position.left = withinOffset + outerWidth - data.collisionWidth;
          } else {
            position.left = withinOffset;
          } // Too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft; // Too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight; // Adjust based on position and margin
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function (position, data) {
        const { within } = data;
        const withinOffset = within.isWindow
          ? within.scrollTop
          : within.offset.top;
        const outerHeight = data.within.height;
        const collisionPosTop = position.top - data.collisionPosition.marginTop;
        const overTop = withinOffset - collisionPosTop;
        const overBottom =
          collisionPosTop + data.collisionHeight - outerHeight - withinOffset;
        let newOverBottom; // Element is taller than within
        if (data.collisionHeight > outerHeight) {
          // Element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom =
              position.top +
              overTop +
              data.collisionHeight -
              outerHeight -
              withinOffset;
            position.top += overTop - newOverBottom; // Element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset; // Element is initially over both top and bottom of within
          } else if (overTop > overBottom) {
            position.top = withinOffset + outerHeight - data.collisionHeight;
          } else {
            position.top = withinOffset;
          } // Too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop; // Too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom; // Adjust based on position and margin
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      },
    },
    flip: {
      left: function (position, data) {
        const { within } = data;
        const withinOffset = within.offset.left + within.scrollLeft;
        const outerWidth = within.width;
        const offsetLeft = within.isWindow
          ? within.scrollLeft
          : within.offset.left;
        const collisionPosLeft =
          position.left - data.collisionPosition.marginLeft;
        const overLeft = collisionPosLeft - offsetLeft;
        const overRight =
          collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft;
        const myOffset =
          data.my[0] === "left"
            ? -data.elemWidth
            : data.my[0] === "right"
            ? data.elemWidth
            : 0;
        const atOffset =
          data.at[0] === "left"
            ? data.targetWidth
            : data.at[0] === "right"
            ? -data.targetWidth
            : 0;
        const offset = -2 * data.offset[0];
        let newOverRight;
        let newOverLeft;
        if (overLeft < 0) {
          newOverRight =
            position.left +
            myOffset +
            atOffset +
            offset +
            data.collisionWidth -
            outerWidth -
            withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
          position.offsetX = myOffset + atOffset + offset;
        } else if (overRight > 0) {
          newOverLeft =
            position.left -
            data.collisionPosition.marginLeft +
            myOffset +
            atOffset +
            offset -
            offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
          position.offsetX = myOffset + atOffset + offset;
        }
      },
      top: function (position, data) {
        const { within } = data;
        const withinOffset = within.offset.top + within.scrollTop;
        const outerHeight = within.height;
        const offsetTop = within.isWindow
          ? within.scrollTop
          : within.offset.top;
        const collisionPosTop = position.top - data.collisionPosition.marginTop;
        const overTop = collisionPosTop - offsetTop;
        const overBottom =
          collisionPosTop + data.collisionHeight - outerHeight - offsetTop;
        const top = data.my[1] === "top";
        const myOffset = top
          ? -data.elemHeight
          : data.my[1] === "bottom"
          ? data.elemHeight
          : 0;
        const atOffset =
          data.at[1] === "top"
            ? data.targetHeight
            : data.at[1] === "bottom"
            ? -data.targetHeight
            : 0;
        const offset = -2 * data.offset[1];
        let newOverTop;
        let newOverBottom;
        if (overTop < 0) {
          newOverBottom =
            position.top +
            myOffset +
            atOffset +
            offset +
            data.collisionHeight -
            outerHeight -
            withinOffset;
          if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
            position.top += myOffset + atOffset + offset;
          }
          position.offsetY = myOffset + atOffset + offset;
        } else if (overBottom > 0) {
          newOverTop =
            position.top -
            data.collisionPosition.marginTop +
            myOffset +
            atOffset +
            offset -
            offsetTop;
          if (newOverTop > 0 || abs(newOverTop) < overBottom) {
            position.top += myOffset + atOffset + offset;
          }
          position.offsetY = myOffset + atOffset + offset;
        }
      },
    },
    flipfit: {
      left: function () {
        positionFns.flip.left.apply(this, arguments);
        positionFns.fit.left.apply(this, arguments);
      },
      top: function () {
        positionFns.flip.top.apply(this, arguments);
        positionFns.fit.top.apply(this, arguments);
      },
    },
  };
  function position(elem, options) {
    if (!options || !options.of) {
      return;
    } // Make a copy, we don't want to modify arguments
    options = extend({}, options);
    const target = options.of;
    const within = positionTool.getWithinInfo(options.within);
    const scrollInfo = positionTool.getScrollInfo(within);
    const collision = (options.collision || "flip").split(" ");
    const offsets = {};
    const dimensions = getDimensions(target);
    if (target.preventDefault) {
      // Force left top to allow flipping
      options.at = "left top";
    }
    const targetWidth = dimensions.width;
    const targetHeight = dimensions.height;
    const targetOffset = dimensions.offset; // Clone to reuse original targetOffset later
    const basePosition = extend({}, targetOffset); // Force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    ["my", "at"].forEach(function (item) {
      let pos = (options[item] || "").split(" ");
      if (pos.length === 1) {
        pos = rhorizontal.test(pos[0])
          ? pos.concat(["center"])
          : rvertical.test(pos[0])
          ? ["center"].concat(pos)
          : ["center", "center"];
      }
      pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
      pos[1] = rvertical.test(pos[1]) ? pos[1] : "center"; // Calculate offsets
      const horizontalOffset = roffset.exec(pos[0]);
      const verticalOffset = roffset.exec(pos[1]);
      offsets[item] = [
        horizontalOffset ? horizontalOffset[0] : 0,
        verticalOffset ? verticalOffset[0] : 0,
      ]; // Reduce to just the positions without the offsets
      options[item] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
    }); // Normalize collision option
    if (collision.length === 1) {
      collision[1] = collision[0];
    }
    if (options.at[0] === "right") {
      basePosition.left += targetWidth;
    } else if (options.at[0] === "center") {
      basePosition.left += targetWidth / 2;
    }
    if (options.at[1] === "bottom") {
      basePosition.top += targetHeight;
    } else if (options.at[1] === "center") {
      basePosition.top += targetHeight / 2;
    }
    const atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[0];
    basePosition.top += atOffset[1];
    const elemWidth = elem.offsetWidth;
    const elemHeight = elem.offsetHeight;
    const marginLeft = parseCss(elem, "marginLeft");
    const marginTop = parseCss(elem, "marginTop");
    const collisionWidth =
      elemWidth + marginLeft + parseCss(elem, "marginRight") + scrollInfo.width;
    const collisionHeight =
      elemHeight +
      marginTop +
      parseCss(elem, "marginBottom") +
      scrollInfo.height;
    const position = extend({}, basePosition);
    const myOffset = getOffsets(
      offsets.my,
      elem.offsetWidth,
      elem.offsetHeight
    );
    if (options.my[0] === "right") {
      position.left -= elemWidth;
    } else if (options.my[0] === "center") {
      position.left -= elemWidth / 2;
    }
    if (options.my[1] === "bottom") {
      position.top -= elemHeight;
    } else if (options.my[1] === "center") {
      position.top -= elemHeight / 2;
    }
    position.left += myOffset[0];
    position.top += myOffset[1];
    const collisionPosition = { marginLeft: marginLeft, marginTop: marginTop };
    ["left", "top"].forEach(function (dir, i) {
      if (positionFns[collision[i]]) {
        positionFns[collision[i]][dir](position, {
          targetWidth: targetWidth,
          targetHeight: targetHeight,
          elemWidth: elemWidth,
          elemHeight: elemHeight,
          collisionPosition: collisionPosition,
          collisionWidth: collisionWidth,
          collisionHeight: collisionHeight,
          offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
          my: options.my,
          at: options.at,
          within: within,
          elem: elem,
        });
      }
    }); // dom
    elem.setAttribute("offset-x", position.offsetX || "0");
    elem.setAttribute("offset-y", position.offsetY || "0");
    setOffset(elem, position, options.offset);
  }
  class PanelBody extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(PanelBody);
  class PanelFooter extends Component {
    // constructor(props, ...mixins) {
    //     super(props, ...mixins)
    // }
  }
  Component.register(PanelFooter);
  class Icon extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Icon.defaults, props), ...mixins);
    }
    _config() {
      this.setProps({
        // eslint-disable-next-line prefer-template
        children: Icon.svgs[this.props.type]
          ? "#" + Icon.svgs[this.props.type].svg
          : null,
      });
    }
  }
  Icon.defaults = { type: "", tag: "i" };
  Icon.svgs = {};
  Icon.add = function (type, svg, cat) {
    Icon.svgs[type] = { type, svg, cat };
  };
  Component.normalizeIconProps = function (props) {
    if (props === null || props === undefined) {
      return null;
    }
    let iconProps = {};
    if (isString(props)) {
      iconProps.type = props;
    } else if (isPlainObject(props)) {
      iconProps = props;
    } else {
      return null;
    }
    if (!iconProps.component) {
      iconProps.component = Icon;
    }
    return iconProps;
  };
  Component.register(Icon);
  /* Direction */ let cat = "Direction";
  Icon.add(
    "prev",
    `<svg t="1648458859637" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3969" width="1em" height="1em" fill="currentColor"><path d="M378.24 512l418.88 418.88L704 1024 192 512l512-512 93.12 93.12z" fill="currentColor" p-id="3970"></path></svg>`,
    cat
  );
  Icon.add(
    "next",
    `<svg t="1648458872022" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4111" width="1em" height="1em" fill="currentColor"><path d="M610.88 512L192 93.12 285.12 0l512 512-512 512L192 930.88z" fill="currentColor" p-id="4112"></path></svg>`,
    cat
  );
  Icon.add(
    "angle-up",
    `<svg t="1648459016487" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4253" width="1em" height="1em" fill="currentColor"><path d="M512 378.24l-418.88 418.88L0 704l512-512 512 512-93.12 93.12z" fill="currentColor" p-id="4254"></path></svg>`,
    cat
  );
  Icon.add(
    "angle-down",
    `<svg t="1648459032734" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4395" width="1em" height="1em" fill="currentColor"><path d="M512 610.88L930.88 192 1024 285.12l-512 512-512-512L93.12 192z" fill="currentColor" p-id="4396"></path></svg>`,
    cat
  );
  Icon.add(
    "up",
    `<svg focusable="false" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16"><path d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/></svg>`,
    cat
  );
  Icon.add(
    "down",
    `<svg focusable="false" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16"><path d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>`,
    cat
  );
  Icon.add(
    "left",
    `<svg focusable="false" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>`,
    cat
  );
  Icon.add(
    "right",
    `<svg focusable="false" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>`,
    cat
  );
  Icon.add(
    "double-left",
    `<svg t="1736157642143" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3204" width="1em" height="1em" fill="currentColor"><path d="M893.76 132.8l-45.12-45.12L448 489.28a32 32 0 0 0 0 45.44l400.64 401.6 45.12-45.12L514.56 512z" p-id="3205"></path><path d="M573.76 132.8l-45.12-45.12L128 489.28a32 32 0 0 0 0 45.44l400.64 401.6 45.12-45.12L194.56 512z" p-id="3206"></path></svg>`,
    cat
  );
  Icon.add(
    "double-right",
    `<svg t="1736157698135" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6415" width="1em" height="1em" fill="currentColor"><path d="M576 489.28L173.76 87.68 128 132.8 507.52 512 128 891.2l45.12 45.12L576 534.72a32 32 0 0 0 0-45.44z" p-id="6416"></path><path d="M896 489.28L493.76 87.68 448 132.8 827.52 512 448 891.2l45.12 45.12L896 534.72a32 32 0 0 0 0-45.44z" p-id="6417"></path></svg>`,
    cat
  );
  Icon.add(
    "swap",
    `<svg t="1623828423357" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3532" width="1em" height="1em" fill="currentColor"><path d="M922.345786 372.183628l-39.393195 38.687114L676.138314 211.079416l0 683.909301-54.713113 0L621.425202 129.010259l53.320393 0L922.345786 372.183628zM349.254406 894.989741 101.654214 651.815349l39.393195-38.687114 206.814276 199.792349L347.861686 129.010259l54.713113 0 0 765.978459L349.254406 894.988718z" p-id="3533"></path></svg>`,
    cat
  );
  Icon.add(
    "refresh",
    `<svg t="1611710311642" viewBox="0 0 1204 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9191" width="1em" height="1em" fill="currentColor"><path d="M822.704457 813.250853a384.466659 384.466659 0 0 1-225.260731 68.644008 419.812302 419.812302 0 0 1-31.552158-1.625779c-4.214983-0.361284-8.429966-1.083853-12.705163-1.565566a430.048689 430.048689 0 0 1-24.326473-3.73327c-4.937551-0.903211-9.754675-2.167706-14.571798-3.251558-7.827825-1.806421-15.535223-3.673057-23.182407-5.900977-3.673057-1.144067-7.225685-2.408562-10.898741-3.612842a375.916265 375.916265 0 0 1-26.07268-9.453605c-1.926849-0.782783-3.793485-1.685993-5.66012-2.52899a388.862284 388.862284 0 0 1-29.324239-14.029871l-1.324709-0.602141a388.380572 388.380572 0 0 1-111.757262-91.284488c-1.505351-1.806421-3.010702-3.853699-4.516053-5.720334a376.518405 376.518405 0 0 1-84.359873-237.243325h89.23721c2.288134 0 4.516053-1.204281 5.720334-3.371987a6.081618 6.081618 0 0 0-0.30107-6.442902l-149.932965-222.671528a6.563331 6.563331 0 0 0-10.838527 0L1.023639 491.467012a6.202046 6.202046 0 0 0-0.30107 6.503116c1.204281 2.107491 3.4322 3.311772 5.720334 3.311773H95.740327a494.357286 494.357286 0 0 0 89.598495 283.969422c0.722569 1.144067 1.204281 2.348348 1.926849 3.4322 5.900976 8.309538 12.343879 15.896507 18.666353 23.724333 2.288134 3.010702 4.516053 6.021404 6.924615 8.911678a511.819358 511.819358 0 0 0 29.083382 31.672586c1.023639 1.023639 1.866635 2.047277 2.83006 2.950488a499.294837 499.294837 0 0 0 153.967306 103.929437c3.070916 1.324709 6.081618 2.769846 9.272962 4.094555 10.718099 4.395625 21.677055 8.18911 32.756439 11.862166 5.238622 1.806421 10.417029 3.612843 15.655651 5.178408 9.754675 2.83006 19.629778 5.178408 29.504881 7.586969 6.623545 1.505351 13.247089 3.13113 19.991062 4.395625 2.709632 0.60214 5.419264 1.384923 8.128895 1.806422 9.393391 1.685993 18.846995 2.589204 28.240386 3.73327 3.371986 0.361284 6.743973 0.963425 10.115959 1.324709 16.920146 1.625779 33.719864 2.709632 50.579796 2.709632 102.905798 0 203.282606-31.13066 289.4489-90.923204a59.792544 59.792544 0 0 0 14.933082-83.697518 61.117253 61.117253 0 0 0-84.660943-14.75244z m285.595202-311.908738a494.4175 494.4175 0 0 0-89.176996-283.307069c-0.842997-1.384923-1.445137-2.769846-2.288134-4.03434-7.045043-9.875103-14.632012-19.087851-22.158768-28.3006l-2.649417-3.371987a500.318476 500.318476 0 0 0-189.072093-140.539574l-5.96119-2.709632a599.009291 599.009291 0 0 0-35.586499-12.885805c-4.395625-1.445137-8.670822-3.010702-13.066447-4.275197A492.731507 492.731507 0 0 0 716.547101 13.789016C710.525697 12.404093 704.684935 10.958956 698.723745 9.814889c-3.010702-0.60214-5.780548-1.445137-8.731037-1.987064-7.948254-1.384923-16.016935-1.987063-24.025402-3.010702-5.539692-0.662354-11.01917-1.505351-16.558862-2.107491a540.481242 540.481242 0 0 0-40.162766-1.987063c-2.408562 0-4.817123-0.361284-7.225685-0.361285l-1.324709 0.120428a505.797954 505.797954 0 0 0-289.027402 90.501706 59.73233 59.73233 0 0 0-14.933083 83.697518c19.268493 27.216747 57.20334 33.840292 84.660944 14.75244A384.466659 384.466659 0 0 1 604.789839 120.789368c11.500882 0.060214 22.760908 0.60214 33.840292 1.62578l10.236387 1.324709c9.152534 1.083853 18.244855 2.408562 27.156533 4.154768 3.913913 0.722569 7.827825 1.746207 11.681524 2.589204 8.79125 1.987063 17.522286 4.094555 26.132894 6.623545 2.709632 0.842997 5.35905 1.806421 8.008468 2.709632 9.875103 3.13113 19.449136 6.623545 28.90274 10.477243l2.890274 1.204281c56.6012 24.145831 106.277784 61.297895 144.995413 107.662707l0.722569 0.963425a376.458191 376.458191 0 0 1 87.430789 241.157239h-89.23721a6.503117 6.503117 0 0 0-5.720334 3.371986 6.141832 6.141832 0 0 0 0.30107 6.442902l149.993179 222.671528a6.442903 6.442903 0 0 0 5.419263 2.83006c2.22792 0 4.214983-1.083853 5.419264-2.83006l149.932965-222.671528a6.202046 6.202046 0 0 0 0.30107-6.442902 6.503117 6.503117 0 0 0-5.720334-3.371986h-89.176996z" p-id="9192"></path></svg>`,
    cat
  );
  /* Prompt */ cat = "Prompt";
  Icon.add(
    "square",
    `<svg t="1715850174291" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3594" width="1em" height="1em" fill="currentColor"><path d="M950.857143 237.714286v548.571428q0 68-48.285714 116.285715T786.285714 950.857143H237.714286q-68 0-116.285715-48.285714T73.142857 786.285714V237.714286q0-68 48.285714-116.285715T237.714286 73.142857h548.571428q68 0 116.285715 48.285714T950.857143 237.714286z" p-id="3595"></path></svg>`,
    cat
  );
  Icon.add(
    "check-light",
    `<svg t="1715913686615" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2943" width="1em" height="1em" fill="currentColor"><path d="M887.904 298.208c-12.864-12.064-33.152-11.488-45.216 1.408L415.936 753.984l-233.12-229.696C170.208 511.872 149.952 512 137.536 524.608c-12.416 12.576-12.256 32.864 0.352 45.248l256.48 252.672c0.096 0.096 0.224 0.128 0.32 0.224 0.096 0.096 0.128 0.224 0.224 0.32 2.016 1.92 4.448 3.008 6.784 4.288 1.152 0.672 2.144 1.664 3.36 2.144 3.776 1.472 7.776 2.24 11.744 2.24 4.192 0 8.384-0.832 12.288-2.496 1.312-0.544 2.336-1.664 3.552-2.368 2.4-1.408 4.896-2.592 6.944-4.672 0.096-0.096 0.128-0.256 0.224-0.352 0.064-0.096 0.192-0.128 0.288-0.224l449.184-478.208C901.44 330.592 900.768 310.336 887.904 298.208z" p-id="2944"></path></svg>`,
    cat
  );
  Icon.add(
    "info-circle",
    `<svg viewBox="64 64 896 896" focusable="false" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path><path d="M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z"></path></svg>`,
    cat
  );
  Icon.add(
    "question-circle",
    `<svg viewBox="64 64 896 896" focusable="false" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path><path d="M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z"></path></svg>`,
    cat
  );
  Icon.add(
    "exclamation-circle",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="exclamation-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path><path d="M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"></path></svg>`,
    cat
  );
  Icon.add(
    "close-circle",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="close-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z"></path><path d="M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path></svg>`,
    cat
  );
  Icon.add(
    "check-circle",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="check-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"></path><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path></svg>`,
    cat
  );
  Icon.add(
    "check-circle-fill",
    `<svg t="1722934427688" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9277" width="1em" height="1em" fill="currentColor"><path d="M844.8 179.2C757.333333 91.733333 635.733333 42.666667 512 42.666667h-2.133333C388.266667 42.666667 266.666667 91.733333 179.2 179.2 91.733333 266.666667 42.666667 388.266667 42.666667 512c0 123.733333 49.066667 245.333333 136.533333 332.8C266.666667 932.266667 388.266667 981.333333 512 981.333333c123.733333 0 243.2-49.066667 330.666667-136.533333C932.266667 757.333333 981.333333 635.733333 981.333333 512c0-123.733333-49.066667-245.333333-136.533333-332.8z m-89.6 234.666667l-256 256c-8.533333 8.533333-19.2 12.8-29.866667 12.8s-21.333333-4.266667-29.866666-12.8l-128-128c-17.066667-17.066667-17.066667-42.666667 0-59.733334 17.066667-17.066667 42.666667-17.066667 59.733333 0l98.133333 98.133334 226.133334-226.133334c17.066667-17.066667 42.666667-17.066667 59.733333 0 17.066667 17.066667 17.066667 42.666667 0 59.733334z"  p-id="9278"></path></svg>`,
    cat
  );
  Icon.add(
    "info-circle-fill",
    `<svg t="1722934495976" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9434" width="1em" height="1em" fill="currentColor"><path d="M844.8 179.2C757.333333 91.733333 635.733333 42.666667 512 42.666667h-2.133333C388.266667 42.666667 266.666667 91.733333 179.2 179.2 91.733333 266.666667 42.666667 388.266667 42.666667 512c0 123.733333 49.066667 245.333333 136.533333 332.8C266.666667 932.266667 388.266667 981.333333 512 981.333333c123.733333 0 243.2-49.066667 330.666667-136.533333C932.266667 757.333333 981.333333 635.733333 981.333333 512c0-123.733333-49.066667-245.333333-136.533333-332.8zM512 234.666667c29.866667 0 53.333333 23.466667 53.333333 53.333333S541.866667 341.333333 512 341.333333s-53.333333-23.466667-53.333333-53.333333S482.133333 234.666667 512 234.666667z m85.333333 533.333333h-149.333333c-23.466667 0-42.666667-19.2-42.666667-42.666667s19.2-42.666667 42.666667-42.666666h32V469.333333c-23.466667 0-42.666667-19.2-42.666667-42.666666s19.2-42.666667 42.666667-42.666667h42.666667c23.466667 0 42.666667 19.2 42.666666 42.666667v256H597.333333c23.466667 0 42.666667 19.2 42.666667 42.666666s-19.2 42.666667-42.666667 42.666667z"  p-id="9435"></path></svg>`,
    cat
  );
  Icon.add(
    "warning-circle-fill",
    `<svg t="1722934530200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9591" width="1em" height="1em" fill="currentColor"><path d="M844.8 179.2C757.333333 91.733333 635.733333 42.666667 512 42.666667h-2.133333C388.266667 42.666667 266.666667 91.733333 179.2 179.2 91.733333 266.666667 42.666667 388.266667 42.666667 512c0 123.733333 49.066667 245.333333 136.533333 332.8C266.666667 932.266667 388.266667 981.333333 512 981.333333c123.733333 0 243.2-49.066667 330.666667-136.533333C932.266667 757.333333 981.333333 635.733333 981.333333 512c0-123.733333-49.066667-245.333333-136.533333-332.8zM469.333333 256c0-23.466667 19.2-42.666667 42.666667-42.666667s42.666667 19.2 42.666667 42.666667v341.333333c0 23.466667-19.2 42.666667-42.666667 42.666667s-42.666667-19.2-42.666667-42.666667V256z m42.666667 533.333333c-29.866667 0-53.333333-23.466667-53.333333-53.333333S482.133333 682.666667 512 682.666667s53.333333 23.466667 53.333333 53.333333S541.866667 789.333333 512 789.333333z"  p-id="9592"></path></svg>`,
    cat
  );
  Icon.add(
    "help-circle-fill",
    `<svg t="1722934561710" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9748" width="1em" height="1em" fill="currentColor"><path d="M844.8 179.2C757.333333 91.733333 635.733333 42.666667 512 42.666667h-2.133333C388.266667 42.666667 266.666667 91.733333 179.2 179.2 91.733333 266.666667 42.666667 388.266667 42.666667 512c0 123.733333 49.066667 245.333333 136.533333 332.8C266.666667 932.266667 388.266667 981.333333 512 981.333333c123.733333 0 243.2-49.066667 330.666667-136.533333C932.266667 757.333333 981.333333 635.733333 981.333333 512c0-123.733333-49.066667-245.333333-136.533333-332.8zM512 802.133333c-29.866667 0-53.333333-23.466667-53.333333-53.333333s23.466667-53.333333 53.333333-53.333333 53.333333 23.466667 53.333333 53.333333-23.466667 53.333333-53.333333 53.333333z m42.666667-238.933333v49.066667c0 23.466667-19.2 42.666667-42.666667 42.666666s-42.666667-19.2-42.666667-42.666666v-85.333334c0-23.466667 19.2-42.666667 42.666667-42.666666 46.933333 0 85.333333-38.4 85.333333-85.333334s-38.4-85.333333-85.333333-85.333333-85.333333 38.4-85.333333 85.333333c0 23.466667-19.2 42.666667-42.666667 42.666667s-42.666667-19.2-42.666667-42.666667c0-93.866667 76.8-170.666667 170.666667-170.666666s170.666667 76.8 170.666667 170.666666c0 76.8-55.466667 145.066667-128 164.266667z"  p-id="9749"></path></svg>`,
    cat
  );
  Icon.add(
    "close-circle-fill",
    `<svg t="1722934591637" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9905" width="1em" height="1em" fill="currentColor"><path d="M512 42.666667C253.866667 42.666667 42.666667 253.866667 42.666667 512s211.2 469.333333 469.333333 469.333333 469.333333-211.2 469.333333-469.333333S770.133333 42.666667 512 42.666667z m170.666667 578.133333c17.066667 17.066667 17.066667 42.666667 0 59.733333-8.533333 8.533333-19.2 12.8-29.866667 12.8s-21.333333-4.266667-29.866667-12.8L512 571.733333 403.2 682.666667c-17.066667 17.066667-42.666667 17.066667-59.733333 0-17.066667-17.066667-17.066667-42.666667 0-59.733334l108.8-108.8-110.933334-110.933333c-17.066667-17.066667-17.066667-42.666667 0-59.733333 17.066667-17.066667 42.666667-17.066667 59.733334 0l108.8 108.8 108.8-108.8c17.066667-17.066667 42.666667-17.066667 59.733333 0 17.066667 17.066667 17.066667 42.666667 0 59.733333l-106.666667 108.8 110.933334 108.8z"  p-id="9906"></path></svg>`,
    cat
  );
  Icon.add(
    "up-circle",
    `<svg t="1716282684077" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3453" width="1em" height="1em" fill="currentColor"><path d="M512 828.40625c-171.386719 0-316.40625-138.42773438-316.40625-316.40625 0-171.386719 138.42773438-316.40625 316.40625-316.40625 171.386719 0 316.40625 138.42773438 316.40625 316.40625 0 171.386719-145.019531 316.40625-316.40625 316.40625zM512 116.4921875C294.47070312 116.4921875 116.4921875 294.47070312 116.4921875 512s177.97851563 395.5078125 395.5078125 395.5078125 395.5078125-177.97851563 395.5078125-395.5078125-177.97851563-395.5078125-395.5078125-395.5078125z m32.95898463 276.85546875c-13.183594-13.183594-46.14257787-13.183594-59.32617188 0L340.613281 531.77539063c-19.77539063 13.183594-19.77539063 46.14257787 0 59.32617187 13.183594 13.183594 46.14257787 13.183594 59.32617187 0L512 485.63281275l112.06054713 112.06054637c6.59179662 6.59179662 19.77539063 13.183594 32.95898387 13.18359401s19.77539063-6.59179662 32.95898462-13.18359401c6.59179662-6.59179662 13.183594-19.77539063 13.18359401-32.95898387s-6.59179662-19.77539063-13.18359401-32.95898462L544.95898463 393.34765625z" p-id="3454"></path></svg>`,
    cat
  );
  Icon.add(
    "down-circle",
    `<svg t="1716283207226" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3610" width="1em" height="1em" fill="currentColor"><path d="M614.39257813 446.609375L512.3515625 548.65039063 410.22265625 446.609375c-15.38085938-15.29296875-40.16601563-15.29296875-55.45898438 0-7.64648438 7.64648438-11.51367188 17.66601563-11.51367187 27.7734375s3.8671875 20.12695313 11.51367187 27.7734375l129.81445313 129.81445313c7.3828125 7.3828125 17.40234375 11.51367188 27.7734375 11.51367187s20.390625-4.13085938 27.7734375-11.51367188l129.81445313-129.81445312c15.29296875-15.38085938 15.29296875-40.16601563-1e-8-55.546875-15.46875-15.29296875-40.25390625-15.29296875-55.546875 0z"  p-id="3611"></path><path d="M832.09765625 282.78125c-23.11523438-32.25585938-50.9765625-60.8203125-82.6171875-84.81445313-31.9921875-24.2578125-67.5-43.33007813-105.20507813-56.86523437-42.45117188-15.20507813-87.01171875-22.8515625-132.36328124-22.8515625-53.0859375 0-104.765625 10.37109375-153.28125001 30.9375-46.84570313 19.86328125-89.03320313 48.1640625-125.15624999 84.375-36.12304688 36.12304688-64.51171875 78.31054688-84.375 125.15625C128.70898437 407.32226562 118.25 458.82617187 118.25 511.91210937c0 44.47265625 7.3828125 88.2421875 21.97265625 129.99023438 13.27148438 37.96875 32.34375 73.74023438 56.51367188 106.08398438 23.99414063 31.9921875 52.55859375 60.02929688 84.90234374 83.40820312 67.32421875 48.60351563 146.953125 74.26757813 230.18554688 74.26757813 53.0859375 0 104.765625-10.37109375 153.28125-30.93750001 46.84570313-19.86328125 89.03320313-48.1640625 125.15625-84.37499999 36.12304688-36.12304688 64.51171875-78.22265625 84.375-125.15625 20.390625-48.1640625 30.76171875-99.31640625 30.9375-151.96289063v-2.63671875c-0.17578125-82.265625-25.57617188-161.10351563-73.4765625-227.8125zM511.91210937 827.26367188c-133.9453125 0-253.56445313-84.90234375-297.77343749-211.28906251-11.6015625-33.31054688-17.49023438-68.29101563-17.49023438-104.06249999 0-173.84765625 141.50390625-315.3515625 315.3515625-315.35156251 36.47460938 0 72.0703125 6.15234375 105.99609375 18.28125001 125.15625 44.6484375 209.26757813 164.00390625 209.26757813 297.07031249 0 173.93554688-141.41601563 315.3515625-315.35156251 315.35156251z" p-id="3612"></path></svg>`,
    cat
  );
  Icon.add(
    "check",
    `<svg viewBox="64 64 896 896"  focusable="false" data-icon="check" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474c-6.1-7.7-15.3-12.2-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1 0.4-12.8-6.3-12.8z" p-id="4091"></path></svg>`,
    cat
  );
  Icon.add(
    "question-circle",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="question-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"></path><path d="M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z"></path></svg>`,
    cat
  );
  Icon.add(
    "close",
    `<svg t="1729508782060" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4342" width="1em" height="1em" fill="currentColor"><path d="M892.48 138.24a32 32 0 0 1 0 45.248L556.416 519.530667l328.533333 328.533333a32 32 0 0 1-45.269333 45.226667L511.168 564.8 183.488 892.48a32 32 0 0 1-45.248-45.248l327.68-327.701333L130.688 184.32a32 32 0 0 1 45.269333-45.269333L511.146667 474.282667 847.232 138.24a32 32 0 0 1 45.248 0z" p-id="4343"></path></svg>`,
    cat
  );
  Icon.add(
    "ellipsis",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="ellipsis" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z"></path></svg>`,
    cat
  );
  Icon.add(
    "eye",
    `<svg focusable="false" class="" data-icon="eye" width="1em" height="1em" fill="currentColor" aria-hidden="true" viewBox="64 64 896 896"><path d="M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z"></path></svg>`,
    cat
  );
  Icon.add(
    "eye-invisible",
    `<svg focusable="false" class="" data-icon="eye-invisible" width="1em" height="1em" fill="currentColor" aria-hidden="true" viewBox="64 64 896 896"><path d="M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z"></path><path d="M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z"></path></svg>`,
    cat
  );
  Icon.add(
    "pin",
    `<svg t="1639617300925" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6674"  fill="currentColor" width="1em" height="1em" fill="currentColor"><path d="M631.637333 178.432a64 64 0 0 1 19.84 13.504l167.616 167.786667a64 64 0 0 1-19.370666 103.744l-59.392 26.304-111.424 111.552-8.832 122.709333a64 64 0 0 1-109.098667 40.64l-108.202667-108.309333-184.384 185.237333-45.354666-45.162667 184.490666-185.344-111.936-112.021333a64 64 0 0 1 40.512-109.056l126.208-9.429333 109.44-109.568 25.706667-59.306667a64 64 0 0 1 84.181333-33.28z m-25.450666 58.730667l-30.549334 70.464-134.826666 135.04-149.973334 11.157333 265.408 265.6 10.538667-146.474667 136.704-136.874666 70.336-31.146667-167.637333-167.765333z" p-id="6675"></path></svg>`,
    cat
  );
  Icon.add(
    "pin-fill",
    `<svg t="1639617366341" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6806"  fill="currentColor" width="1em" height="1em" fill="currentColor"><path d="M631.637333 178.432a64 64 0 0 1 19.84 13.504l167.616 167.786667a64 64 0 0 1-19.370666 103.744l-59.392 26.304-111.424 111.552-8.832 122.709333a64 64 0 0 1-109.098667 40.64l-108.202667-108.309333-184.384 185.237333-45.354666-45.162667 184.490666-185.344-111.936-112.021333a64 64 0 0 1 40.512-109.056l126.208-9.429333 109.44-109.568 25.706667-59.306667a64 64 0 0 1 84.181333-33.28z" p-id="6807"></path></svg>`,
    cat
  );
  Icon.add(
    "drag",
    `<svg t="1640832231565" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4362" fill="currentColor" width="1em" height="1em" fill="currentColor"><path d="M362.666667 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4363"></path><path d="M661.333333 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4364"></path><path d="M362.666667 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4365"></path><path d="M661.333333 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4366"></path><path d="M362.666667 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4367"></path><path d="M661.333333 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" p-id="4368"></path></svg>`,
    cat
  );
  Icon.add(
    "sort",
    `<svg t="1648697046294" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2976" width="1em" height="1em" fill="currentColor"><path d="M788.8384 580.2496c31.6416 0 39.5776 32.768 18.944 53.9648l-267.776 275.968a40.2432 40.2432 0 0 1-56.1152 0l-267.7248-275.968c-20.5824-21.1968-12.5952-53.9648 18.944-53.9648z m-248.832-466.432l267.776 275.968c20.6336 21.1968 12.6976 53.9648-18.944 53.9648H235.1104c-31.5392 0-39.5264-32.768-18.944-53.9648l267.7248-275.968a40.2432 40.2432 0 0 1 56.1664 0z" fill="currentColor" p-id="2977"></path></svg>`,
    cat
  );
  Icon.add(
    "sort-down",
    `<svg t="1648705739912" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8280" width="1em" height="1em" fill="currentColor"><path d="M804.571429 402.285714a36.205714 36.205714 0 0 1-10.861715 25.709715l-256 256C530.870857 690.834286 521.691429 694.857143 512 694.857143s-18.870857-3.986286-25.709714-10.861714l-256-256A36.425143 36.425143 0 0 1 219.428571 402.285714c0-20.004571 16.566857-36.571429 36.571429-36.571428h512c20.004571 0 36.571429 16.566857 36.571429 36.571428z" fill="currentColor" p-id="8281"></path></svg>`,
    cat
  );
  Icon.add(
    "sort-up",
    `<svg t="1648705802934" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8415" width="1em" height="1em" fill="currentColor"><path d="M804.571429 694.857143c0 20.004571-16.566857 36.571429-36.571429 36.571428H256c-20.004571 0-36.571429-16.566857-36.571429-36.571428a36.205714 36.205714 0 0 1 10.861715-25.709714l256-256C493.129143 406.308571 502.308571 402.285714 512 402.285714s18.870857 3.986286 25.709714 10.861715l256 256A36.425143 36.425143 0 0 1 804.571429 694.857143z" fill="currentColor" p-id="8416"></path></svg>`,
    cat
  );
  Icon.add(
    "sort-right",
    `<svg t="1648705834389" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8550" width="1em" height="1em" fill="currentColor"><path d="M676.571429 512a36.205714 36.205714 0 0 1-10.861715 25.709714l-256 256A36.425143 36.425143 0 0 1 384 804.571429c-20.004571 0-36.571429-16.566857-36.571429-36.571429V256c0-20.004571 16.566857-36.571429 36.571429-36.571429a36.205714 36.205714 0 0 1 25.709714 10.861715l256 256A36.425143 36.425143 0 0 1 676.571429 512z" fill="currentColor" p-id="8551"></path></svg>`,
    cat
  );
  Icon.add(
    "sort-left",
    `<svg t="1648705869847" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8685" width="1em" height="1em" fill="currentColor"><path d="M676.571429 256v512c0 20.004571-16.566857 36.571429-36.571429 36.571429a36.205714 36.205714 0 0 1-25.709714-10.861715l-256-256C351.451429 530.870857 347.428571 521.691429 347.428571 512s3.986286-18.870857 10.861715-25.709714l256-256A36.425143 36.425143 0 0 1 640 219.428571c20.004571 0 36.571429 16.566857 36.571429 36.571429z" fill="currentColor" p-id="8686"></path></svg>`,
    cat
  );
  Icon.add(
    "filter",
    `<svg t="1621992626834" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3088" width="1em" height="1em" fill="currentColor" ><path d="M426.666667 597.333333L170.666667 213.333333V128h682.666666v85.333333l-256 384v256l-170.666666 85.333334z" p-id="3089"></path></svg>`,
    cat
  );
  Icon.add(
    "filter-remove",
    `<svg t="1621992691799" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3229" width="1em" height="1em" fill="currentColor" ><path d="M295.637333 21.973333L898.986667 625.365333l-60.330667 60.330667-163.114667-163.072L597.333333 640v298.666667h-170.666666v-298.666667L170.666667 256H128V170.666667h195.626667l-88.32-88.362667L295.637333 21.973333zM896 170.666667v85.333333h-42.666667l-81.706666 122.538667L563.754667 170.666667H896z" p-id="3230"></path></svg>`,
    cat
  );
  Icon.add(
    "setting",
    `<svg t="1615863726011" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3943" width="1em" height="1em" fill="currentColor"><path d="M785.183686 139.674311c-14.716642-25.494575-50.839308-46.344043-80.272592-46.344044H326.227815c-29.433284 0-65.55595 20.849468-80.272592 46.344044L56.618935 467.614608c-14.716642 25.494575-14.716642 67.193511 0 92.688087l189.336288 327.951c14.716642 25.494575 50.839308 46.344043 80.272592 46.344043h378.683279c29.433284 0 65.55595-20.849468 80.272592-46.344043L974.530677 560.302695c14.716642-25.494575 14.716642-67.193511 0-92.688087L785.183686 139.674311zM741.932814 813.332609c-14.716642 25.494575-50.839308 46.344043-80.272593 46.344043H369.478688c-29.433284 0-65.55595-20.849468-80.272592-46.344043l-146.074712-253.019211c-14.716642-25.494575-14.716642-67.193511 0-92.688087L289.206096 214.595397c14.716642-25.494575 50.839308-46.344043 80.272592-46.344043H661.660221c29.433284 0 65.55595 20.849468 80.272593 46.344043l146.096118 253.019211c14.716642 25.494575 14.716642 67.193511 0 92.688087L741.932814 813.332609z" fill="currentColor" p-id="3944"></path><path d="M515.574806 358.743567c-85.731129 0-155.225788 69.494659-155.225787 155.225787s69.494659 155.225788 155.225787 155.225788 155.225788-69.494659 155.225788-155.225788-69.494659-155.225788-155.225788-155.225787z m0 235.519786c-44.278362 0-80.304701-36.026339-80.304701-80.304702s36.026339-80.304701 80.304701-80.304701 80.304701 36.026339 80.304701 80.304701-36.026339 80.304701-80.304701 80.304702z" fill="currentColor" p-id="3945"></path></svg>`,
    cat
  );
  Icon.add(
    "resize-handler",
    `<svg t="1616466190070" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2516" width="1em" height="1em" fill="currentColor"><path d="M938.666667 938.666667 853.333333 938.666667 853.333333 853.333333 938.666667 853.333333 938.666667 938.666667M938.666667 768 853.333333 768 853.333333 682.666667 938.666667 682.666667 938.666667 768M768 938.666667 682.666667 938.666667 682.666667 853.333333 768 853.333333 768 938.666667M768 768 682.666667 768 682.666667 682.666667 768 682.666667 768 768M597.333333 938.666667 512 938.666667 512 853.333333 597.333333 853.333333 597.333333 938.666667M938.666667 597.333333 853.333333 597.333333 853.333333 512 938.666667 512 938.666667 597.333333Z"  fill="currentColor" p-id="2517"></path></svg>`,
    cat
  );
  Icon.add(
    "plus-square",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="plus-square" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"></path><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"></path></svg>`,
    cat
  );
  Icon.add(
    "minus-square",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="minus-square" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"></path><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"></path></svg>`,
    cat
  );
  /* Editor */ cat = "Editor";
  Icon.add(
    "form",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="form" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 512h-56c-4.4 0-8 3.6-8 8v320H184V184h320c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V520c0-4.4-3.6-8-8-8z"></path><path d="M355.9 534.9L354 653.8c-.1 8.9 7.1 16.2 16 16.2h.4l118-2.9c2-.1 4-.9 5.4-2.3l415.9-415c3.1-3.1 3.1-8.2 0-11.3L785.4 114.3c-1.6-1.6-3.6-2.3-5.7-2.3s-4.1.8-5.7 2.3l-415.8 415a8.3 8.3 0 00-2.3 5.6zm63.5 23.6L779.7 199l45.2 45.1-360.5 359.7-45.7 1.1.7-46.4z"></path></svg>`,
    cat
  );
  Icon.add(
    "plus",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="plus" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z"></path><path d="M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z"></path></svg>`,
    cat
  );
  Icon.add(
    "minus",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="minus" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M896 469.333333H128a42.666667 42.666667 0 0 0 0 85.333334h768a42.666667 42.666667 0 0 0 0-85.333334z" p-id="4498"></path></svg>`,
    cat
  );
  Icon.add(
    "edit",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="edit" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"></path></svg>`,
    cat
  );
  Icon.add(
    "delete",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="delete" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"></path></svg>`,
    cat
  );
  Icon.add(
    "blank-square",
    `<svg t="1609925372510" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1811" width="1em" height="1em" fill="currentColor"><path d="M845 179v666H179V179h666m0-64H179c-35.3 0-64 28.7-64 64v666c0 35.3 28.7 64 64 64h666c35.3 0 64-28.7 64-64V179c0-35.3-28.7-64-64-64z" p-id="1812"></path></svg>`,
    cat
  );
  Icon.add(
    "checked-square",
    `<svg t="1609925474194" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2089" width="1em" height="1em" fill="currentColor"><path d="M844 116H180c-35.3 0-64 28.7-64 64v664c0 35.3 28.7 64 64 64h664c35.3 0 64-28.7 64-64V180c0-35.3-28.7-64-64-64z m0 728H180V180h664v664z" p-id="2090"></path><path d="M433.4 670.6c6.2 6.2 14.4 9.4 22.6 9.4s16.4-3.1 22.6-9.4l272-272c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L456 602.7 342.6 489.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l136.1 135.9z" p-id="2091"></path></svg>`,
    cat
  );
  Icon.add(
    "half-square",
    `<svg t="1609936930955" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1365" width="1em" height="1em" fill="currentColor"><path d="M844 116H180c-35.3 0-64 28.7-64 64v664c0 35.3 28.7 64 64 64h664c35.3 0 64-28.7 64-64V180c0-35.3-28.7-64-64-64z m0 728H180V180h664v664z" p-id="1366"></path><path d="M320 544h384c17.7 0 32-14.3 32-32s-14.3-32-32-32H320c-17.7 0-32 14.3-32 32s14.3 32 32 32z" p-id="1367"></path></svg>`,
    cat
  );
  Icon.add(
    "times",
    `<svg t="1610503666305" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2041" width="1em" height="1em" fill="currentColor"><path d="M572.16 512l183.466667-183.04a42.666667 42.666667 0 1 0-60.586667-60.586667L512 451.84l-183.04-183.466667a42.666667 42.666667 0 0 0-60.586667 60.586667l183.466667 183.04-183.466667 183.04a42.666667 42.666667 0 0 0 0 60.586667 42.666667 42.666667 0 0 0 60.586667 0l183.04-183.466667 183.04 183.466667a42.666667 42.666667 0 0 0 60.586667 0 42.666667 42.666667 0 0 0 0-60.586667z" p-id="2042"></path></svg>`,
    cat
  );
  Icon.add(
    "search",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="search" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"></path></svg>`,
    cat
  );
  /* Logo */ cat = "Logo";
  Icon.add(
    "github",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg>`,
    cat
  );
  Icon.add(
    "nomui",
    `<svg width="1em" height="1em" version="1.1" id="_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 64 64" style="enable-background:new 0 0 64 64;" xml:space="preserve"><rect y="0" fill="none" width="64" height="64"/><g><polygon fill="currentColor" points="12.78,5.61 0,58.39 13.78,58.39 20.17,30.17 26.56,58.39 39.51,58.39 52.21,5.61 39.01,5.61 33.12,30.92 26.89,5.61"/><polygon fill="currentColor" points="56.85,32.83 50.88,58.39 64,58.39 	"/></g></svg>`,
    cat
  );
  /* Uncategorized */ cat = "Uncategorized";
  Icon.add(
    "clock",
    `<svg t="1614131772688" class="icon" viewBox="0 0 1024 1024" version="1.1" fill="currentColor" xmlns="http://www.w3.org/2000/svg" p-id="2901" width="1em" height="1em" fill="currentColor"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="2902"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="2903"></path></svg>`,
    cat
  );
  Icon.add(
    "calendar",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="calendar" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z"></path></svg>`,
    cat
  );
  Icon.add(
    "image",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="file-image" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M553.1 509.1l-77.8 99.2-41.1-52.4a8 8 0 00-12.6 0l-99.8 127.2a7.98 7.98 0 006.3 12.9H696c6.7 0 10.4-7.7 6.3-12.9l-136.5-174a8.1 8.1 0 00-12.7 0zM360 442a40 40 0 1080 0 40 40 0 10-80 0zm494.6-153.4L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z"></path></svg>`,
    cat
  );
  Icon.add(
    "table",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="table" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 208H676V232h212v136zm0 224H676V432h212v160zM412 432h200v160H412V432zm200-64H412V232h200v136zm-476 64h212v160H136V432zm0-200h212v136H136V232zm0 424h212v136H136V656zm276 0h200v136H412V656zm476 136H676V656h212v136z"></path></svg>`,
    cat
  );
  Icon.add(
    "profile",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="profile" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656zM492 400h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H492c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8zm0 144h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H492c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8zm0 144h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H492c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8zM340 368a40 40 0 1080 0 40 40 0 10-80 0zm0 144a40 40 0 1080 0 40 40 0 10-80 0zm0 144a40 40 0 1080 0 40 40 0 10-80 0z"></path></svg>`,
    cat
  );
  Icon.add(
    "user",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="user" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z"></path></svg>`,
    cat
  );
  Icon.add(
    "hospital",
    `<svg t="1638944150401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4298" id="mx_n_1638944150402" width="1em" height="1em" fill="currentColor"><path d="M597.333333 85.333333H187.733333a102.4 102.4 0 0 0-102.4 102.4v682.666667a68.266667 68.266667 0 0 0 68.266667 68.266667h512a34.133333 34.133333 0 0 0 34.133333-34.133334V187.733333a102.4 102.4 0 0 0-102.4-102.4z m2.56 68.352A34.133333 34.133333 0 0 1 631.466667 187.733333v682.666667H153.6V187.733333a34.133333 34.133333 0 0 1 34.133333-34.133333h409.6l2.56 0.085333z"  p-id="4299"></path><path d="M870.4 426.666667H665.6a34.133333 34.133333 0 0 0-34.133333 34.133333v443.733333a34.133333 34.133333 0 0 0 34.133333 34.133334h204.8a68.266667 68.266667 0 0 0 68.266667-68.266667V494.933333a68.266667 68.266667 0 0 0-68.266667-68.266666zM699.733333 870.4V494.933333h170.666667v375.466667H699.733333z"  p-id="4300"></path><path d="M426.666667 290.133333v136.533334h136.533333v68.266666h-136.533333v136.533334h-68.266667v-136.533334h-136.533333v-68.266666h136.533333v-136.533334h68.266667z" p-id="4301"></path></svg>`,
    cat
  );
  Icon.add(
    "company",
    `<svg t="1638944443633" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6346" width="1em" height="1em" fill="currentColor"><path d="M956.624449 922.846357h-29.442936V592.832598c0-17.701887-8.850944-41.545246-29.984829-50.396189l-267.334627-174.851297V93.747751l-2.890104-6.141471C614.869642 57.802081 588.316811 42.809667 555.622508 48.770506L136.376786 173.586876c-23.843359 8.850944-41.545246 32.694302-41.545246 59.427765v689.831716H64.84671c-18.243782 0-29.98483 14.992415-29.98483 29.98483 0 18.243782 12.102311 29.98483 29.98483 29.98483h891.777739c18.243782 0 29.98483-12.102311 29.98483-29.98483-0.180632-18.243782-12.282942-29.98483-29.98483-29.98483z m-89.231964-333.265126v333.265126H629.862057V435.683189l237.530428 153.898042zM153.536779 233.014641l415.994355-124.81637v814.648086H153.536779V233.014641z" p-id="6347"></path><path d="M450.856236 325.136708H272.753572c-18.243782 0-29.98483 11.741048-29.98483 29.98483 0 18.243782 12.102311 29.98483 29.98483 29.98483h178.102664c18.243782 0 29.98483-11.741048 29.984829-29.98483 0-18.424413-12.282942-29.98483-29.984829-29.98483zM450.856236 503.058741H272.753572c-18.243782 0-29.98483 12.102311-29.98483 29.984829v0.361263c0 18.243782 12.102311 29.98483 29.98483 29.98483h178.102664c18.243782 0 29.98483-12.102311 29.984829-29.98483v-0.180631-0.180632c0-18.243782-12.282942-29.98483-29.984829-29.984829zM450.856236 681.703299H272.753572c-18.243782 0-29.98483 11.741048-29.98483 29.984829v0.361263c0 18.243782 12.102311 29.98483 29.98483 29.98483h178.102664c18.243782 0 29.98483-11.741048 29.984829-29.98483v-0.180631-0.180632c0-18.243782-12.282942-29.98483-29.984829-29.984829zM688.747927 712.049391c0 18.243782 12.102311 29.98483 29.98483 29.98483h59.427765c18.243782 0 29.98483-11.741048 29.98483-29.98483v-0.180631-0.180632c0-18.243782-12.102311-29.98483-29.98483-29.984829h-59.427765c-18.243782 0-29.98483 11.741048-29.98483 29.984829v0.361263z" p-id="6348"></path></svg>`,
    cat
  );
  Icon.add(
    "image-pending",
    `<svg t="1655976918344" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4066" width="1em" height="1em" fill="currentColor"><path d="M766.112 289.888s103.328-1.024 103.328 101.28c0 0 9.568 99.04-103.328 101.216 0 0-101.152 2.176-100.128-101.216 0.032-0.064-1.088-91.744 100.128-101.28z m203.552-155.616S1024.032 138.528 1024.032 186.464v714.912s-3.232 51.136-54.368 52.256v-819.36zM0 901.44s2.176 52.256 52.256 52.256h917.408V802.4h-100l-203.68-206.752-153.44 154.432L303.712 492.32 98.08 800.288l-45.76 1.024-1.152-614.752H0.032l-0.032 714.88z m969.664-767.168H52.256S0 133.184 0 186.464h969.664v-52.192z" fill="currentColor" p-id="4067"></path></svg>`,
    cat
  );
  Icon.add(
    "image-fail",
    `<svg t="1655976783496" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2264" width="1em" height="1em" fill="currentColor"><path d="M696.43 465.25c40.61 0 73.53-32.72 73.53-73.09s-32.96-73.08-73.53-73.08-73.54 32.72-73.54 73.08 32.92 73.09 73.54 73.09zM535.74 650.62l-273.61-259.4a56.19 56.19 0 0 0-15.36 11.58l-114 119.63-6-222.77c-0.73-26.82 20.84-49.41 47.67-50.14l201.77-5.44 47.34-50-250.43 6.75C119 202.33 76.33 247.17 77.78 301l7.32 271.4 4.5 166.78C91.06 793 136.05 835.47 190.2 834l176-4.75 12-0.32 47.34-50 116.18-122.64z" p-id="2265" fill="currentColor"></path><path d="M861.71 214.8l-242.83-33.86-55.09 41.46L855 263a49.05 49.05 0 0 1 41.79 55.13l-54.33 389.59-120.87-159.05A59.86 59.86 0 0 0 638.06 537l-44 33.08 65.07 86.15L603.84 698l-79.57 60.1-54.92 41.48 34.17 4.76 270.73 37.76a97.55 97.55 0 0 0 109.88-79.6 22.37 22.37 0 0 0 0.65-3.44l60.53-434.16c7.44-53.32-29.95-102.62-83.6-110.1z" p-id="2266" fill="currentColor"></path></svg>`,
    cat
  );
  Icon.add(
    "sandbox",
    `<svg t="1653360277625" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2488" width="1em" height="1em" fill="currentColor"><path d="M709.6 210l0.4-0.2h0.2L512 96 313.9 209.8h-0.2l0.7 0.3L151.5 304v416L512 928l360.5-208V304l-162.9-94zM482.7 843.6L339.6 761V621.4L210 547.8V372.9l272.7 157.3v313.4zM238.2 321.5l134.7-77.8 138.9 79.7 139.1-79.9 135.2 78-273.9 158-274-158zM814 548.3l-128.8 73.1v139.1l-143.9 83V530.4L814 373.1v175.2z" p-id="2489"></path></svg>`
  );
  /* common */ cat = "Common";
  Icon.add(
    "cloud-upload",
    `<svg t="1655198146842" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2389" width="1em" height="1em" fill="currentColor"><path d="M767.9 441c-24.2-121.3-128-214-255.9-214-100.3 0-186.7 57.1-228.2 142.7C176.5 383.9 97 473.1 97 583.7c0 117.7 93.4 213.9 207.5 213.9H754c96.8 0 172.9-78.5 172.9-178.3 0.1-92.7-72.5-171.2-159-178.3zM581.2 542.3V672c0 7.2-5.8 13-13 13H455.8c-7.2 0-13-5.8-13-13V542.3h-73.1c-11.5 0-17.3-13.8-9.3-22l142.3-146.7c5.1-5.3 13.5-5.3 18.6 0l142.3 146.7c8 8.2 2.1 22-9.3 22h-73.1z" p-id="2390" fill="currentColor"></path></svg>`,
    cat
  );
  Icon.add(
    "upload",
    `<svg t="1648175489426" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8288" fill="currentColor" width="1em" height="1em" fill="currentColor"><path d="M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163c-3.2-4.1-9.4-4.1-12.6 0l-112 141.7c-4.1 5.3-0.4 13 6.3 13z" p-id="8289"></path><path d="M878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" p-id="8290"></path></svg>`,
    cat
  );
  Icon.add(
    "download",
    `<svg t="1648175417253" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6484" fill="currentColor" width="1em" height="1em" fill="currentColor"><path d="M505.7 661c3.2 4.1 9.4 4.1 12.6 0l112-141.7c4.1-5.2 0.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8z" p-id="6485"></path><path d="M878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" p-id="6486"></path></svg>`,
    cat
  );
  /** star */ Icon.add(
    "star",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg>`,
    cat
  );
  /* Loading */ cat = "Loading";
  Icon.add(
    "loading",
    `<svg width="1em" height="1em" viewBox="0 0 50 50" style="enable-background: new 0 0 50 50" xml:space="preserve"><path fill='#4263eb' d="M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform>`,
    cat
  );
  /* FileType */ cat = "FileType";
  Icon.add(
    "file-error",
    `<svg t="1609815861438" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2630" width="1em" height="1em" fill="currentColor"><path d="M960.002941 320.008822H576.004901V0h63.989218v256.003921H960.002941v64.004901zM339.197745 678.411175l300.796374-300.812057 44.808136 44.808136-300.796374 300.796373-44.808136-44.792452z" p-id="2631" ></path><path d="M339.197745 422.407254l44.808136-44.808136 300.796374 300.812057-44.808136 44.792452-300.796374-300.796373z" p-id="2632" ></path><path d="M870.355302 1024h-716.741971A89.616272 89.616272 0 0 1 64.012743 934.399412V89.600588A89.616272 89.616272 0 0 1 153.613331 0h486.380788l319.946087 249.604999v684.794413a89.616272 89.616272 0 0 1-89.584904 89.600588z m-716.741971-959.995099c-19.196765 0-25.595687 12.797844-25.595687 25.595687v844.798824a25.595687 25.595687 0 0 0 25.595687 25.61137h716.741971c19.196765 0 25.595687-12.797844 25.595687-25.595687V275.200686L620.797353 64.004901z" p-id="2633"></path></svg>`,
    cat
  );
  Icon.add(
    "folder",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="folder" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z"></path></svg>`,
    cat
  );
  Icon.add(
    "folder-filled",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="folder" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32z"></path></svg>`,
    cat
  );
  Icon.add(
    "file",
    `<svg viewBox="64 64 896 896" focusable="false" data-icon="file" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z"></path></svg>`,
    cat
  );
  class Caption extends Component {
    constructor(props, ...mixins) {
      const tagProp = props.href ? { tag: "a" } : {};
      super(Component.extendProps(Caption.defaults, props, tagProp), ...mixins);
    }
    _config() {
      this._addPropStyle("subtitleWrap");
      const { title, subtitle, icon, image, href, titleLevel } = this.props;
      const children = [];
      if (isPlainObject(image)) {
        children.push(
          Component.extendProps(
            { tag: "img", classes: { "nom-caption-image": true } },
            image
          )
        );
      } else if (isString(image)) {
        children.push({
          tag: "img",
          classes: { "nom-caption-image": true },
          attrs: { src: image },
        });
      } else if (icon) {
        children.push(
          Component.extendProps(
            { classes: { "nom-caption-icon": true } },
            Component.normalizeIconProps(icon)
          )
        );
      }
      const titleTag = `h${titleLevel}`;
      children.push({
        tag: titleTag,
        classes: { "nom-caption-title": true },
        children: [title, subtitle && { tag: "small", children: subtitle }],
      });
      if (href) {
        this.setProps({ attrs: { href: href } });
      }
      this.setProps({ children: children });
    }
  }
  Caption.defaults = {
    title: "",
    subtitle: "",
    icon: null,
    image: null,
    titleLevel: 5,
  };
  Component.register(Caption);
  class Col extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(Col);
  class Cols extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        wrap: false,
        items: [],
        itemDefaults: null,
        gutter: "sm",
        childDefaults: { component: Col },
        strechIndex: null,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = [
        "gutter",
        "align",
        "justify",
        "fills",
        "inline",
      ];
      const { items } = this.props;
      const children = [];
      if (Array.isArray(items) && items.length > 0) {
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          if (isString(item)) {
            item = { children: item };
          }
          item = Component.extendProps({}, this.props.itemDefaults, item);
          if (
            isNumeric(this.props.strechIndex) &&
            this.props.strechIndex === i
          ) {
            children.push({
              component: Col,
              classes: { "nom-col-strech": true },
              children: item,
            });
          } else {
            children.push({ component: Col, children: item });
          }
        }
        this.setProps({ children: children });
      } else if (this.props.showEmpty) {
        if (isPlainObject(this.props.showEmpty)) {
          this.setProps({
            children: Object.assign(
              { component: "Empty" },
              this.props.showEmpty
            ),
          });
        } else {
          this.setProps({ children: { component: "Empty" } });
        }
      }
    }
  }
  Component.register(Cols);
  class PanelHeaderCaption extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(PanelHeaderCaption);
  class PanelHeaderNav extends Component {
    // constructor(props, ...mixins) {
    //     super(props, ...mixins)
    // }
  }
  Component.register(PanelHeaderNav);
  class PanelHeaderTools extends Component {
    // constructor(props, ...mixins) {
    //     super(props, ...mixins)
    // }
  }
  Component.register(PanelHeaderTools);
  class PanelHeader extends Component {
    constructor(props, ...mixins) {
      const defaults = { caption: null, nav: null, tools: null };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const { caption, nav, tools } = this.props;
      let toolsProps, navProps;
      const captionProps = caption
        ? Component.extendProps({ component: Caption }, caption)
        : null;
      if (Array.isArray(nav)) {
        navProps = { component: Cols, items: nav };
      } else if (isPlainObject(nav)) {
        navProps = Component.extendProps({ component: Cols }, nav);
      }
      if (Array.isArray(tools)) {
        toolsProps = { component: Cols, items: tools };
      } else if (isPlainObject(tools)) {
        toolsProps = Component.extendProps({ component: Cols }, tools);
      }
      this.setProps({
        children: [
          captionProps && {
            component: PanelHeaderCaption,
            children: captionProps,
          },
          navProps && { component: PanelHeaderNav, children: navProps },
          toolsProps && { component: PanelHeaderTools, children: toolsProps },
        ],
      });
    }
  }
  Component.register(PanelHeader);
  class Panel extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Panel.defaults, props), ...mixins);
    }
    _config() {
      this._addPropStyle("fit");
      const { header, body, footer, startAddons, endAddons } = this.props;
      let footerProps;
      const headerProps =
        header !== false &&
        Component.extendProps({ component: PanelHeader }, header);
      const bodyProps = Component.extendProps({ component: PanelBody }, body);
      if (footer) {
        footerProps = Component.extendProps({ component: PanelFooter }, footer);
      }
      this.setProps({
        children: [
          headerProps,
          ...startAddons,
          bodyProps,
          ...endAddons,
          footerProps,
        ],
      });
    }
  }
  Panel.defaults = {
    header: null,
    body: null,
    footer: null,
    uistyle: "default", // splitline,outline,card,bordered,plain
    startAddons: [],
    endAddons: [],
    fit: false,
  };
  Component.register(Panel);
  Object.defineProperty(Component.prototype, "$modal", {
    get: function () {
      let cur = this;
      while (cur) {
        if (cur.__isModalContent === true) {
          return cur.modal;
        }
        cur = cur.parent;
      }
      return null;
    },
  });
  var ModalContentMixin = {
    _created: function () {
      this.modal = this.parent.modal;
      this.__isModalContent = true;
      this.parent.parent.modalContent = this;
    },
    _config: function () {
      this.setProps({
        classes: {
          "nom-modal-content": true,
          "nom-modal-content-animate-show": this.modal.props.animate,
        },
      });
    },
  };
  class ModalDialog extends Component {
    constructor(props, ...mixins) {
      const defaults = { children: { component: Panel, uistyle: "plain" } };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      const modal = (this.modal = this.parent);
      const { content } = this.modal.props;
      if (isString(content)) {
        this.modal.element &&
          this.modal.element.setAttribute("data-url", content);
        require([content], (contentConfig) => {
          let props = contentConfig;
          if (isFunction(props)) {
            const pNames = this.getParameterNames(props);
            if (pNames.length && pNames[0] === "{") {
              const args = modal.props.args || {};
              props = contentConfig({ modal: modal, args: args });
              if (props.then) {
                props.then((result) => {
                  props = result;
                  props = Component.extendProps(
                    this._getDefaultPanelContent(props),
                    props
                  );
                  if (isFunction(props.footer)) {
                    props.footer = props.footer.call(this.modal, this.modal);
                  }
                  this.update({
                    children: n$1(null, props, null, [ModalContentMixin]),
                  });
                });
              } else {
                props = Component.extendProps(
                  this._getDefaultPanelContent(props),
                  props
                );
                if (isFunction(props.footer)) {
                  props.footer = props.footer.call(this.modal, this.modal);
                }
                this.update({
                  children: n$1(null, props, null, [ModalContentMixin]),
                });
              }
            } else {
              props = contentConfig.call(this, modal);
              props = Component.extendProps(
                this._getDefaultPanelContent(props),
                props
              );
              if (isFunction(props.footer)) {
                props.footer = props.footer.call(this.modal, this.modal);
              }
              this.update({
                children: n$1(null, props, null, [ModalContentMixin]),
              });
            }
          }
        });
      }
    }
    _getDefaultPanelContent(contentProps) {
      const modal = this.modal;
      modal.setProps({
        okText: contentProps.okText,
        onOk: contentProps.onOk,
        cancelText: contentProps.cancelText,
        onCancel: contentProps.onCancel,
        okButton: contentProps.okButton,
      });
      const {
        okText,
        cancelText,
        fit,
        okButton = {},
        cancelButton = {},
        size,
        adaptToFit,
      } = modal.props;
      return {
        component: Panel,
        fit: fit || size === "full" || adaptToFit,
        uistyle: "plain",
        header: {
          nav: {},
          tools: [
            {
              component: "Button",
              icon: "close",
              styles: { border: "none" },
              onClick: function () {
                modal.close();
              },
            },
          ],
        },
        footer: {
          children: {
            component: "Cols",
            items: [
              okButton !== false &&
                Component.extendProps(
                  {
                    component: "Button",
                    type: "primary",
                    text: okText,
                    onClick: () => {
                      modal._handleOk();
                    },
                  },
                  okButton
                ),
              cancelButton !== false &&
                Component.extendProps(
                  {
                    component: "Button",
                    text: cancelText,
                    onClick: () => {
                      modal._handleCancel();
                    },
                  },
                  cancelButton
                ),
            ],
          },
        },
      };
    }
    _config() {
      const { content } = this.modal.props;
      if (isPlainObject(content)) {
        const extendContent = {};
        if (isFunction(content.footer)) {
          extendContent.footer = content.footer.call(this.modal, this.modal);
        }
        const contentProps = Component.extendProps(
          this._getDefaultPanelContent(content),
          content,
          extendContent
        );
        this.setProps({
          children: n$1(null, contentProps, null, [ModalContentMixin]),
        });
      }
      this.setProps({
        classes: { "nom-modal-dialog-centered": this.modal.props.centered },
      });
    }
    getParameterNames(fn) {
      const code = fn.toString();
      const result = code
        .slice(code.indexOf("(") + 1, code.indexOf(")"))
        .match(/([^\s,]+)/g);
      return result === null ? [] : result;
    }
  }
  Component.register(ModalDialog);
  class Modal extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Modal.defaults, props), ...mixins);
    }
    _created() {
      this._scoped = true;
      this.bodyElem = document.body;
    }
    _config() {
      this._propStyleClasses = ["size", "fit"];
      const { size, animate, adaptToFit } = this.props;
      let myWidth = null;
      if (size) {
        if (isPlainObject(size)) {
          if (size.width) {
            myWidth = isNumeric(size.width) ? `${size.width}px` : size.width;
          }
        }
      }
      this.setProps({
        classes: {
          "nom-modal-mask-animate-show": animate,
          "nom-modal-adapt-to-fit": adaptToFit,
        },
        children: {
          component: ModalDialog,
          attrs: { style: { width: myWidth || null } },
        },
      });
    }
    _show() {
      this.setzIndex();
      this.checkScrollbar();
      this.setScrollbar();
    }
    close(result) {
      const that = this;
      if (!this.rendered) {
        return;
      }
      if (this.element === undefined) {
        return;
      }
      if (result === undefined) {
        result = that.returnValue;
      }
      let { modalCount } = this.bodyElem;
      if (modalCount) {
        modalCount--;
        this.bodyElem.modalCount = modalCount;
        if (modalCount === 0) {
          this.resetScrollbar();
        }
      }
      this._callHandler(this.props.onClose, { result: result });
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.remove();
    }
    animateHide() {
      if (!this.element) return false;
      this.modalContent.addClass("nom-modal-content-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.addClass("nom-modal-mask-animate-hide");
        setTimeout(() => {
          if (!this.element) return false;
          this.remove();
        }, 90);
      }, 90);
    }
    setzIndex() {
      this.element.style.zIndex = getzIndex();
    }
    checkScrollbar() {
      const fullWindowWidth = window.innerWidth;
      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
      this.scrollbarWidth = positionTool.scrollbarWidth();
    }
    setScrollbar() {
      /* var bodyPad = parseInt((this.bodyElem.css('padding-right') || 0), 10);
          this.originalBodyPad = document.body.style.paddingRight || '';
          this.originalBodyOverflow = document.body.style.overflow || '';
          if (this.bodyIsOverflowing) {
              this.bodyElem.css('padding-right', bodyPad + this.scrollbarWidth);
          }
          this.bodyElem.css("overflow", "hidden");
          var modalCount = this.bodyElem.data('modalCount');
          if (modalCount) {
              modalCount++;
              this.bodyElem.data('modalCount', modalCount);
          }
          else {
              this.bodyElem.data('modalCount', 1);
          } */
    }
    resetScrollbar() {
      /* this.bodyElem.css('padding-right', this.originalBodyPad);
          this.bodyElem.css('overflow', this.originalBodyOverflow);
          this.bodyElem.removeData('modalCount'); */
    }
    _handleOk() {
      this._callHandler(this.props.onOk);
    }
    _handleCancel() {
      this._callHandler(this.props.onCancel);
    }
  }
  Modal.defaults = {
    content: {},
    closeOnClickOutside: false,
    fit: false,
    adaptToFit: false,
    okText: " ",
    cancelText: " ",
    onOk: (e) => {
      e.sender.close();
    },
    onCancel: (e) => {
      e.sender.close();
    },
    size: "small",
    centered: true,
  };
  Component.register(Modal);
  class Button extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "button",
        text: null,
        icon: null,
        rightIcon: null,
        type: "default", // null(default) primary,dashed,text,link
        ghost: false,
        danger: false,
        borderless: false,
        block: false,
        inline: false,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = [
        "ghost",
        "size",
        "shape",
        "danger",
        "block",
        "borderless",
      ];
      const {
        icon,
        text,
        rightIcon,
        href,
        target,
        inline,
        rightBadge,
      } = this.props;
      if (icon || rightIcon) {
        this.setProps({ classes: { "p-with-icon": true } });
        if (!text) {
          this.setProps({ classes: { "p-only-icon": true } });
        }
      }
      let badgeProps = null;
      if (rightBadge) {
        badgeProps = Component.extendProps(
          {
            component: "Badge",
            ref: (c) => {
              this.badgeRef = c;
            },
          },
          rightBadge
        );
      }
      this.setProps({
        children: [
          Component.normalizeIconProps(icon),
          text && { tag: "span", children: text },
          badgeProps,
          Component.normalizeIconProps(rightIcon),
        ],
      });
      if (inline) {
        this.setProps({ tag: "a", classes: { "nom-button-inline": true } });
      }
      if (href) {
        this.setProps({
          tag: "a",
          attrs: Object.assign({}, this.props.attrs, {
            href: href,
            target: target || "_self",
          }),
        });
      }
    }
    updateBadge(props) {
      this.badgeRef.update(props);
    }
    _disable() {
      this.element.setAttribute("disabled", "disabled");
    }
    _enable() {
      this.element.removeAttribute("disabled");
    }
  }
  Component.register(Button);
  class AlertContent extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        title: null,
        description: null,
        icon: null,
        type: null,
        okText: null,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const { title, description, type, okText, action } = this.props;
      let { icon } = this.props;
      const alertInst = this.modal;
      const iconMap = {
        info: "info-circle-fill",
        success: "check-circle-fill",
        error: "close-circle-fill",
        warning: "warning-circle-fill",
      };
      icon = icon || iconMap[type];
      const iconProps = icon
        ? Component.extendProps(Component.normalizeIconProps(icon), {
            classes: { "nom-alert-icon": true },
          })
        : null;
      const titleProps = title
        ? Component.extendProps(Component.normalizeTemplateProps(title), {
            classes: { "nom-alert-title": true },
          })
        : null;
      const descriptionProps = description
        ? Component.extendProps(Component.normalizeTemplateProps(description), {
            classes: { "nom-alert-description": true },
          })
        : null;
      const okButtonProps = {
        component: Button,
        type: "primary",
        text: okText,
        onClick: () => {
          alertInst._handleOk();
        },
      };
      let actionProps = { component: Cols, justify: "end" };
      if (!action) {
        actionProps.items = [okButtonProps];
      } else if (isPlainObject(action)) {
        actionProps = Component.extendProps(actionProps, action);
      } else if (Array.isArray(action)) {
        actionProps.items = action;
      }
      this.setProps({
        children: [
          {
            classes: { "nom-alert-body": true },
            children: [
              iconProps
                ? {
                    classes: { "nom-alert-body-icon": true },
                    children: iconProps,
                  }
                : undefined,
              {
                classes: { "nom-alert-body-content": true },
                children: [titleProps, descriptionProps],
              },
            ],
          },
          { classes: { "nom-alert-actions": true }, children: actionProps },
        ],
      });
    }
  }
  Component.register(AlertContent);
  class Alert extends Modal {
    constructor(props, ...mixins) {
      super(Component.extendProps(Alert.defaults, props), ...mixins);
    }
    _config() {
      const { type, icon, title, description, okText, action } = this.props;
      this.setProps({
        content: {
          component: AlertContent,
          type,
          icon,
          title,
          description,
          okText,
          action,
        },
      });
      super._config();
    }
  }
  Alert.defaults = {
    type: "default",
    icon: null,
    title: null,
    description: null,
    okText: "",
    onOk: (e) => {
      e.sender.close();
    },
    action: null,
  };
  Component.register(Alert);
  class Anchor extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Anchor.defaults, props), ...mixins);
    }
    _created() {
      this.container = isFunction(this.props.container)
        ? this.props.container()
        : this.props.container;
      this.containerElem = document;
      this.onWindowScroll = () => {
        this._fixPosition();
        this._onContainerScroll();
      };
      this.currentKey = null;
      this.itemsKeyList = [];
    }
    _config() {
      const that = this;
      const { items, border, width, itemDefaults, menuProps } = this.props;
      const myWidth = isNumeric(width) ? `${width}px` : width;
      this.itemKeyList = this._getItemKeyList();
      this.setProps({
        classes: {
          "nom-anchor-border-left": border === "left",
          "nom-anchor-border-right": border === "right",
          "nom-anchor-border-bottom": border === "bottom",
        },
        attrs: { style: { "min-width": myWidth } },
        children: Object.assign(
          {
            component: "Menu",
            ref: (c) => {
              that.menu = c;
            },
            itemSelectable: { byClick: true },
            items: items,
          },
          menuProps,
          {
            itemDefaults: Object.assign(
              {
                key: function () {
                  return this.props[that.props.keyField];
                },
              },
              itemDefaults,
              {
                onClick: function (args) {
                  const key = args.sender.key;
                  that.props.onItemClick &&
                    that._callHandler(that.props.onItemClick, key);
                  that._scrollToKey(key, true);
                },
              }
            ),
          }
        ),
      });
      if (this.props.activeKey) {
        setTimeout(() => {
          this.scrollToKey(this.props.activeKey);
        }, 500);
      }
    }
    _rendered() {
      const that = this;
      this.position = null;
      this.size = null;
      if (this.props.sticky) {
        if (this.props.sticky === true) {
          this.scrollParent = window;
          window.addEventListener("scroll", this.onWindowScroll);
        } else {
          if (isFunction(this.props.sticky)) {
            this.scrollParent = this.props.sticky();
          } else {
            this.scrollParent = this.props.sticky;
          }
          this.scrollParent._on("scroll", function () {
            that._fixPosition();
          });
        }
      }
      if (this.container !== window) {
        this._checkContainer();
      } else {
        // 
        let temp = 0;
        setTimeout(function judge() {
          const temp1 = document.getElementsByTagName("html")[0].scrollTop;
          if (temp !== temp1) {
            // 
            setTimeout(judge, 500);
            temp = temp1; // 
          } else {
            window.addEventListener("scroll", this.onWindowScroll);
            temp = null; // 
          }
        }, 500);
      }
    }
    scrollToItem(key) {
      this._scrollToKey(key);
    }
    getCurrentItem() {
      if (!this.currentKey) {
        return this.props.items.length
          ? this.props.items[0][this.props.keyField]
          : null;
      }
      return this.currentKey;
    }
    _bindScroll() {
      const that = this;
      this.container._on("scroll", function () {
        that.containerElem = that.container.element;
        that._onContainerScroll();
      });
    }
    _checkContainer() {
      this.intervalFunc = setInterval(() => {
        if (!this.props) {
          return;
        }
        this.container = isFunction(this.props.container)
          ? this.props.container()
          : this.props.container;
        if (this.container) {
          clearInterval(this.intervalFunc);
          this._bindScroll();
        }
      }, 500);
    }
    _getItemKeyList() {
      const me = this;
      const arr = [];
      function mapList(data) {
        data.forEach(function (item) {
          if (item.items) {
            mapList(item.items);
          }
          arr.push(item[me.props.keyField]);
        });
      }
      mapList(this.props.items);
      return arr;
    }
    scrollToKey(key) {
      this._scrollToKey(key);
    }
    _scrollToKey(target, skipScrollWatching) {
      const ele = this.containerElem.querySelector(
        `[anchor-key="${String(target).replace(/"/g, '\\"')}"]`
      );
      if (ele) {
        ele.style.position = "relative";
        let hk = ele.querySelector(".position-hook");
        if (!hk) {
          // 
          hk = document.createElement("div");
          hk.className = "position-hook";
          ele.appendChild(hk);
        }
        hk.style.position = "absolute";
        hk.style.top = `${0 - this.props.containerOffsetTop}px`;
        hk.scrollIntoView({ behavior: "smooth" }); // 
        if (skipScrollWatching) {
          this._skipScrollWatching = true; // 
          setTimeout(() => {
            this._skipScrollWatching = false;
          }, 1000);
        }
      }
    }
    _fixPosition() {
      this.element.style.transform = `translateY(0px)`;
      let pRect = null;
      if (this.props.sticky === true) {
        pRect = { top: this.props.offsetTop, height: window.innerHeight };
      } else {
        pRect = this.scrollParent.element.getBoundingClientRect();
      }
      const gRect = this.element.getBoundingClientRect();
      if (gRect.top < pRect.top) {
        this.element.style.transform = `translateY(${
          pRect.top - gRect.top - 2
        }px)`;
      }
    }
    _onContainerScroll() {
      if (this.menu.element.offsetParent === null) {
        return;
      }
      if (this._skipScrollWatching) {
        // 
        return;
      } // 
      const domlist = this.containerElem.getElementsByClassName(
        "nom-anchor-content"
      );
      if (!domlist.length) return; // 
      const list = [];
      for (let i = 0; i < domlist.length; i++) {
        if (
          domlist[i].offsetParent !== null &&
          this.itemKeyList.includes(domlist[i].getAttribute("anchor-key"))
        ) {
          list.push(domlist[i]);
        }
      }
      if (!list.length) return; // 
      const pRect =
        this.container === window
          ? { top: 0, bottom: window.innerHeight }
          : this.containerElem.getBoundingClientRect();
      const viewportHeight = pRect.bottom - pRect.top;
      const centerLine = pRect.top + viewportHeight / 2;
      const upperQuarter = pRect.top + viewportHeight / 4;
      const lowerQuarter = pRect.top + (viewportHeight * 3) / 4;
      let bestMatch = null;
      let maxScore = -Infinity; // 
      const firstItem = list[0];
      const firstItemRect = firstItem.getBoundingClientRect();
      const isAtTop =
        firstItemRect.top >= pRect.top && firstItemRect.top <= pRect.top + 10; // 10px
      // 
      const lastItem = list[list.length - 1];
      const lastItemRect = lastItem.getBoundingClientRect();
      const isAtBottom =
        lastItemRect.bottom <= pRect.bottom &&
        lastItemRect.bottom >= pRect.bottom - 10; // 
      if (isAtTop) {
        bestMatch = firstItem;
      } // 
      else if (isAtBottom) {
        bestMatch = lastItem;
      } else {
        // 
        for (let i = 0; i < list.length; i++) {
          const elem = list[i];
          const rect = elem.getBoundingClientRect(); // 
          if (rect.bottom <= pRect.top || rect.top >= pRect.bottom) continue; // 
          const visibleHeight =
            Math.min(rect.bottom, pRect.bottom) - Math.max(rect.top, pRect.top);
          const visibleRatio = visibleHeight / rect.height; // 
          const elementCenter = rect.top + rect.height / 2; // 0-1
          const centerDistanceScore =
            1 -
            Math.min(
              1,
              Math.abs(elementCenter - centerLine) / (viewportHeight / 2)
            ); // 1.21.00.8
          let positionWeight = 1.0;
          if (elementCenter < upperQuarter) positionWeight = 1.2;
          else if (elementCenter > lowerQuarter) positionWeight = 0.8; // 
          const isFirstItem = i === 0;
          const isLastItem = i === list.length - 1;
          const edgeBonus =
            isFirstItem || isLastItem ? Math.min(0.15, visibleRatio * 0.2) : 0; // 
          const score =
            visibleRatio * centerDistanceScore * positionWeight + edgeBonus; // 
          if (score > maxScore) {
            maxScore = score;
            bestMatch = elem;
          }
        } // 
        if (bestMatch && this.currentKey) {
          const currentIndex = this.itemKeyList.indexOf(this.currentKey);
          const newIndex = this.itemKeyList.indexOf(
            bestMatch.getAttribute("anchor-key")
          );
          if (Math.abs(newIndex - currentIndex) > 1) {
            const step = newIndex > currentIndex ? 1 : -1;
            let intermediateIndex = currentIndex + step;
            while (intermediateIndex !== newIndex) {
              const intermediateKey = this.itemKeyList[intermediateIndex];
              const intermediateElem = list.find(
                (el) => el.getAttribute("anchor-key") === intermediateKey
              );
              if (intermediateElem) {
                const rect = intermediateElem.getBoundingClientRect();
                if (rect.bottom > pRect.top && rect.top < pRect.bottom) {
                  const intermediateVisible =
                    Math.min(rect.bottom, pRect.bottom) -
                    Math.max(rect.top, pRect.top);
                  if (intermediateVisible >= 30) {
                    bestMatch = intermediateElem;
                    break;
                  }
                }
              }
              intermediateIndex += step;
            }
          }
        }
      } // 
      const result = bestMatch ? bestMatch.getAttribute("anchor-key") : null;
      if (result && result !== this.currentKey) {
        this._activeAnchor(result);
      }
    }
    _activeAnchor(key) {
      this.menu.selectItem(key, { scrollIntoView: false });
      if (this.currentKey && key !== this.currentKey && this.props.onChange) {
        this._callHandler(this.props.onChange, { key: key });
      }
      this.currentKey = key;
    }
    _remove() {
      window.removeEventListener("scroll", this.onWindowScroll);
    }
  }
  Anchor.defaults = {
    container: null,
    items: [],
    border: "left",
    onItemClick: null,
    width: 200,
    offsetTop: 0,
    containerOffsetTop: 0,
    sticky: false,
    itemDefaults: null,
    activeKey: null,
    onChange: null,
    menuProps: {},
    keyField: "key",
  };
  Component.register(Anchor);
  class AnchorContent extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(AnchorContent.defaults, props), ...mixins);
    }
    _rendered() {
      this.element.setAttribute("anchor-key", this.props[this.props.keyField]);
    }
  }
  AnchorContent.defaults = { key: null, keyField: "key" };
  Component.register(AnchorContent);
  class Route {
    constructor(defaultPath) {
      const that = this;
      this.hash = window.location.hash;
      if (!this.hash) {
        this.hash = `#${defaultPath}`;
      }
      this.path = this.hash.substring(1);
      this.paths = [];
      this.query = {};
      this.queryStr = "";
      const queryIndex = this.hash.indexOf("?");
      if (this.hash.length > 1) {
        if (queryIndex > -1) {
          this.path = this.hash.substring(1, queryIndex);
          const paramStr = (this.queryStr = this.hash.substring(
            queryIndex + 1
          ));
          const paramArr = paramStr.split("&");
          paramArr.forEach(function (e) {
            const item = e.split("=");
            const key = item[0];
            const val = item[1];
            if (key !== "") {
              that.query[key] = decodeURIComponent(val);
            }
          });
        }
      }
      const pathArr = this.path.split("!");
      this.maxLevel = pathArr.length - 1;
      pathArr.forEach(function (path, index) {
        let pathName = path;
        let pathQuery = null; // path--
        if (path.includes("--")) {
          const arr = path.split("--");
          pathName = arr[0];
          const queryPathName = pathName.substring(pathName.indexOf("/") + 1);
          pathQuery = arr[1];
          that.queryStr += `&${queryPathName}=${pathQuery}`;
          that.query[queryPathName] = pathQuery;
        }
        that.paths[index] = pathName;
      });
    }
    push(route) {
      if (isString(route)) {
        window.location.href = `#${route}`;
      } else {
        const pathname = route.pathname || this.path;
        let strQuery = parseToQueryString(route.query || {});
        if (strQuery) {
          strQuery = `?${strQuery}`;
        }
        window.location.href = `#${pathname}${strQuery}`;
      }
    }
    iterateHash(callback) {
      let hash = this.hash;
      let result = callback(hash);
      if (!(result === false)) {
        if (this.queryStr !== "") {
          hash = `#${this.path}`;
          result = callback(hash);
        }
        if (!(result === false)) {
          while (hash.indexOf("!") > 0) {
            hash = hash.substring(0, hash.lastIndexOf("!"));
            result = callback(`${hash}!`);
            if (result === false) {
              hash = "";
            }
          }
        }
      }
    }
  }
  class Router extends Component {
    constructor(props, ...mixins) {
      const defaults = { defaultPath: null };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.currentView = null;
      this.path = null;
      this.level = this.$app.lastLevel;
      this.$app.routers[this.level] = this;
      this.handleHashChange = this.handleHashChange.bind(this);
      this.$app.on("hashChange", this.handleHashChange, this);
    }
    render() {
      this._mountElement();
      this.routeView();
    }
    handleHashChange(changed) {
      if (!this.props) {
        return;
      }
      this._callHandler(this.props.onHashChange, changed); // 
      if (
        changed.queryChanged &&
        (changed.changedLevel === null || this.level < changed.changedLevel)
      ) {
        this._callHandler(this.props.onQueryChange, changed);
      }
      if (changed.changedLevel === null) {
        return;
      }
      if (this.level > changed.changedLevel) {
        this.remove();
      } else if (this.level === changed.changedLevel) {
        this.routeView();
      } else if (this.level === changed.changedLevel - 1) {
        this._callHandler(this.props.onSubpathChange, changed);
      }
    }
    getSubpath() {
      let subpath = null;
      const { paths } = this.$app.currentRoute;
      if (this.level < paths.length) {
        subpath = paths[this.level + 1];
      }
      return subpath;
    }
    _removeCore() {
      const el = this.element || this._placeHolderElement;
      return el;
    }
    remove() {
      this.$app.off("hashChange", this.handleHashChange);
      delete this.$app.routers[this.level];
      for (const p in this) {
        if (this.hasOwnProperty(p)) {
          delete this[p];
        }
      }
    }
    _removeSubRouter() {
      const subRouter = this.$app.routers[this.level + 1];
      if (subRouter) {
        subRouter._removeSubRouter();
        subRouter.remove();
      }
    }
    refreshView() {
      this._removeSubRouter();
      this.routeView();
    }
    routeView() {
      isFunction(this.props.onViewLeave) && this.props.onViewLeave.call(this);
      this.emptyChildren();
      this.$app.lastLevel = this.level + 1;
      const level = this.level;
      const defaultPath = this.props.defaultPath;
      const { paths } = this.$app.currentRoute;
      if (defaultPath) {
        if (!paths[level]) {
          paths[level] = defaultPath;
        }
      }
      let url = this.getRouteUrl(level);
      url = `${pathCombine(this.$app.props.viewsDir, url)}.js`;
      require([url], (viewPropsOrRouterPropsFunc) => {
        let routerProps = {};
        if (isFunction(viewPropsOrRouterPropsFunc)) {
          routerProps = viewPropsOrRouterPropsFunc.call(this, {
            route: this.$app.currentRoute,
            app: this.$app,
            router: this,
            context: this.$app.context,
          });
          if (routerProps.then) {
            routerProps.then((result) => {
              routerProps = result;
              this.processProps(routerProps);
            });
          } else if (isFunction(routerProps.onViewEnter)) {
            const onViewEnter = routerProps.onViewEnter.call(this);
            if (onViewEnter && onViewEnter.then) {
              onViewEnter.then(() => {
                this.processProps(routerProps);
              });
            } else {
              this.processProps(routerProps);
            }
          } else {
            this.processProps(routerProps);
          }
        } else {
          routerProps.view = viewPropsOrRouterPropsFunc;
          this.processProps(routerProps);
        }
      });
    }
    processProps(routerProps) {
      const that = this;
      const defaultPath = this.props.defaultPath;
      const element = this.element;
      Router.plugins.forEach((plugin) => {
        plugin(routerProps);
      });
      if (isString(routerProps.title)) {
        document.title = routerProps.title;
      }
      if (isFunction(routerProps.view)) {
        routerProps.view = routerProps.view.call(this);
      }
      if (routerProps.view && routerProps.view.then) {
        routerProps.view.then((result) => {
          routerProps.view = result;
          this._renderView(routerProps, defaultPath, element, that);
        });
      } else {
        this._renderView(routerProps, defaultPath, element, that);
      }
    }
    _renderView(routerProps, defaultPath, element, that) {
      const viewOptions = Component.extendProps(routerProps.view, {
        reference: element,
        placement: "replace",
      });
      this.currentView = Component.create(viewOptions, {
        _rendered: function () {
          that.element = this.element;
        },
      });
      delete this.props;
      this.props = { defaultPath: defaultPath };
      this.setProps(routerProps);
      this._callRendered();
    }
    getRouteUrl(level) {
      const paths = this.$app.currentRoute.paths;
      const maxLevel = this.$app.currentRoute.maxLevel;
      let path = paths[level];
      if (level < maxLevel) {
        path = pathCombine(path, "_layout");
      }
      path = prefix(path, level);
      function prefix(patharg, levelarg) {
        if (levelarg === 0) {
          return patharg;
        }
        if (patharg[0] !== "/") {
          patharg = pathCombine(paths[levelarg - 1], patharg);
          return prefix(patharg, levelarg - 1);
        }
        return patharg;
      }
      return path;
    }
    getParentRouter() {
      return this.$app.routers[this.level - 1];
    }
  }
  Router.plugins = [];
  Component.register(Router);
  /* eslint-disable no-shadow */ class App extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "body",
        placement: "replace",
        defaultPath: "!",
        viewsDir: "/",
        isFixedLayout: true,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.lastLevel = 0;
      this.previousRoute = null;
      this.currentRoute = new Route(this.props.defaultPath);
      this.routers = {};
      this.contextGetted = false;
      Object.defineProperty(Component.prototype, "$app", {
        get: function () {
          return this.root;
        },
      });
      Object.defineProperty(Component.prototype, "$route", {
        get: function () {
          return this.$app.currentRoute;
        },
      });
      const { context } = this.props;
      if (isFunction(context)) {
        const contextResult = context({ route: this.currentRoute });
        if (contextResult.then) {
          contextResult.then((result) => {
            this.context = result;
            this.contextGetted = true;
            this.update();
          });
        } else {
          this.context = context;
          this.contextGetted = true;
        }
      } else {
        this.context = context;
        this.contextGetted = true;
      }
    }
    _config() {
      if (this.contextGetted === true) {
        this.setProps({ children: { component: Router } });
        if (this.props.isFixedLayout === true) {
          document.documentElement.setAttribute("class", "app");
        }
      }
    }
    _rendered() {
      const that = this;
      window.addEventListener("hashchange", function () {
        that.handleRoute();
      });
    }
    handleRoute() {
      const route = new Route(this.props.defaultPath);
      /* console.info(JSON.stringify(route))

      route.iterateHash((hash) => {
        console.log(hash)
      }) */ let changedLevel = null;
      let queryChanged = false;
      this.previousRoute = this.currentRoute;
      this.currentRoute = route;
      if (this.previousRoute !== null) {
        const currentRoutePaths = this.currentRoute.paths;
        const previousRoutePaths = this.previousRoute.paths;
        const length = Math.min(
          previousRoutePaths.length,
          currentRoutePaths.length
        );
        for (let i = 0; i < length; i++) {
          if (previousRoutePaths[i] !== currentRoutePaths[i]) {
            changedLevel = i;
            break;
          }
        }
        if (
          (this.previousRoute.queryStr || "") !== this.currentRoute.queryStr
        ) {
          queryChanged = true;
        }
      }
      this.trigger("hashChange", {
        changedLevel,
        queryChanged,
        route: this.currentRoute,
        app: this,
      });
    }
    getLastRouter() {
      if (this.lastLevel > 0) {
        return this.routers[this.lastLevel - 1];
      }
    }
    /**
     * 
     */ refreshLastRouter() {
      const lastRouter = this.getLastRouter();
      if (lastRouter) {
        try {
          lastRouter.refreshView();
        } catch (error) {
          console.error("Failed to refresh last router view:", error);
        }
      }
    }
  }
  Component.register(App);
  class LayerBackdrop extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        zIndex: 2,
        classes: { "nom-layer-backdrop": true },
        attrs: {
          style: {
            position: "absolute",
            left: 0,
            top: 0,
            width: "100%",
            height: "100%",
            overflow: "hidden",
            userSelect: "none",
          },
        },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      this.setProps({
        attrs: { style: { zIndex: this.props.zIndex } },
        classes: {
          "nom-layer-mask-animate-show": this.props.animate,
          "nom-layer-backdrop-transparent": this.props.transparent,
        },
        onClick({ event }) {
          event.stopPropagation();
        },
      });
      if (this.referenceElement === document.body) {
        this.setProps({ attrs: { style: { position: "fixed" } } });
      }
    }
  }
  Component.register(LayerBackdrop);
  class Layer extends Component {
    constructor(props, ...mixins) {
      const defaults = { within: window };
      super(Component.extendProps(defaults, Layer.defaults, props), ...mixins);
    }
    _created() {
      this.relativeElements = [];
      this._onDocumentMousedown = this._onDocumentMousedown.bind(this);
      this._onWindowResize = this._onWindowResize.bind(this);
      this.attachTo = this.props.attachTo;
      this.attachTo &&
        this.attachTo.on("remove", () => {
          this.remove();
        });
    }
    _config() {
      if (this.props.placement === "replace") {
        this.props.position = null;
      }
      this._normalizePosition();
      this._zIndex = getzIndex();
      this.setProps({ attrs: { style: { zIndex: this._zIndex } } });
      if (this.props.align || this.props.position) {
        this.setProps({
          attrs: {
            style: {
              position: this.props.fixed ? "fixed" : "absolute",
              left: 0,
              top: 0,
            },
          },
        });
      }
      this.props.animate && this.animateInit();
    }
    _rendered() {
      const that = this;
      this.addRel(this.element);
      if (this.props.backdrop) {
        this.backdrop = new LayerBackdrop({
          zIndex: this._zIndex - 1,
          reference: this.props.reference,
          transparent: this.props.backdrop.transparent,
          animate: this.props.animate,
        });
        if (this.props.closeOnClickBackdrop) {
          this.backdrop._on("click", function (e) {
            if (e.target !== e.currentTarget) {
              return;
            }
            that.props.animate && that.animateHide();
            !that.props.animate && that.hide();
          });
        }
      }
    }
    animateInit() {
      this.nomappOverflow();
      this.setProps({ classes: { "nom-layer-animate-show": true } });
    }
    animateHide() {
      if (!this.element) return false;
      this.addClass("nom-layer-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
      }, 90);
    }
    _show() {
      const { props } = this;
      this.setPosition();
      this._docClickHandler();
      if (props.animate) {
        this.addClass("nom-layer-animate-show");
      }
      if (props.align) {
        window.removeEventListener("resize", this._onWindowResize, false);
        if (!this.props.ignoreResize) {
          window.addEventListener("resize", this._onWindowResize, false);
        }
      }
      this.props.onShow && this._callHandler(this.props.onShow);
    }
    _hide(forceRemove) {
      window.removeEventListener("resize", this._onWindowResize, false);
      document.removeEventListener(
        "mousedown",
        this._onDocumentMousedown,
        false
      );
      if (this.props.animate) {
        this.removeClass("nom-layer-animate-show");
        this.removeClass("nom-layer-animate-hide");
      }
      if (forceRemove === true || this.props.closeToRemove) {
        this.props.onClose && this._callHandler(this.props.onClose);
        this.remove();
      }
      this.backdrop && this.backdrop.remove();
    }
    _remove() {
      window.removeEventListener("resize", this._onWindowResize, false);
      document.removeEventListener(
        "mousedown",
        this._onDocumentMousedown,
        false
      );
      if (this.backdrop) {
        this.backdrop.remove();
      }
    }
    _onWindowResize() {
      if (this.props.hidden === false) {
        this.setPosition();
      }
    }
    _onDocumentMousedown(e) {
      for (let i = 0; i < this.relativeElements.length; i++) {
        const el = this.relativeElements[i];
        if (el === e.target || el.contains(e.target)) {
          return;
        }
      }
      const closestLayer = e.target.closest(".nom-layer");
      if (closestLayer !== null) {
        const idx = closestLayer.component._zIndex;
        if (idx < this._zIndex) {
          this.hide();
        }
      } else {
        this.hide();
      }
    }
    nomappOverflow() {
      if (!window.nomapp) return;
      window.nomapp.element.style.overflow = "hidden";
      setTimeout(() => {
        window.nomapp.element.style.overflow = "inherit";
      }, 300);
    }
    setPosition() {
      if (this.props.position) {
        position(this.element, this.props.position);
      }
    }
    addRel(elem) {
      this.relativeElements.push(elem);
    }
    _docClickHandler() {
      const that = this;
      if (that.props.closeOnClickOutside) {
        document.addEventListener(
          "mousedown",
          this._onDocumentMousedown,
          false
        );
      }
    }
    _normalizePosition() {
      const { props } = this;
      if (props.align) {
        props.position = {
          of: window,
          collision: props.collision,
          within: props.within,
        };
        if (props.alignTo) {
          props.position.of = this.getElement(props.alignTo);
        }
        if (props.alignTo && props.alignOuter === true) {
          const arr = props.align.split(" ");
          if (arr.length === 1) {
            arr[1] = "center";
          }
          const myArr = ["center", "center"];
          const atArr = ["center", "center"];
          if (arr[1] === "left") {
            myArr[0] = "left";
            atArr[0] = "left";
          } else if (arr[1] === "right") {
            myArr[0] = "right";
            atArr[0] = "right";
          } else if (arr[1] === "top") {
            myArr[1] = "top";
            atArr[1] = "top";
          } else if (arr[1] === "bottom") {
            myArr[1] = "bottom";
            atArr[1] = "bottom";
          }
          if (arr[0] === "top") {
            myArr[1] = "bottom";
            atArr[1] = "top";
          } else if (arr[0] === "bottom") {
            myArr[1] = "top";
            atArr[1] = "bottom";
          } else if (arr[0] === "left") {
            myArr[0] = "right";
            atArr[0] = "left";
          } else if (arr[0] === "right") {
            myArr[0] = "left";
            atArr[0] = "right";
          }
          props.position.my = `${myArr[0]} ${myArr[1]}`;
          props.position.at = `${atArr[0]} ${atArr[1]}`;
        } else {
          const rhorizontal = /left|center|right/;
          const rvertical = /top|center|bottom/;
          let pos = props.align.split(" ");
          if (pos.length === 1) {
            pos = rhorizontal.test(pos[0])
              ? pos.concat(["center"])
              : rvertical.test(pos[0])
              ? ["center"].concat(pos)
              : ["center", "center"];
          }
          pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
          pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
          props.position.my = `${pos[0]} ${pos[1]}`;
          props.position.at = `${pos[0]} ${pos[1]}`;
        }
      }
      if (props.offset) {
        props.position = Object.assign({}, props.position, {
          offset: props.offset,
        });
      }
    }
  }
  Layer.defaults = {
    align: null,
    alignTo: null,
    alignOuter: false,
    within: window,
    collision: "flipfit",
    onClose: null,
    onHide: null,
    onShow: null,
    offset: null,
    closeOnClickOutside: false,
    closeToRemove: false,
    ignoreResize: false,
    position: null,
    hidden: false,
    backdrop: false,
    closeOnClickBackdrop: false,
  };
  Component.register(Layer);
  class Tooltip extends Layer {
    constructor(props, ...mixins) {
      super(Component.extendProps(Tooltip.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this._showHandler = this._showHandler.bind(this);
      this._hideHandler = this._hideHandler.bind(this);
      this._onOpenerFocusinHandler = this._onOpenerFocusinHandler.bind(this);
      this._onOpenerFocusoutHandler = this._onOpenerFocusoutHandler.bind(this);
      this._openerFocusing = false;
      this.opener = this.props.trigger;
      this.props.alignTo = this.props.alignTo || this.opener.element;
      this.showTimer = null;
      this.hideTimer = null;
      this.delay = 100;
      this.addRel(this.opener.element);
      if (!this.props.ignoreMouseEvent) {
        this._bindHover();
      }
    }
    _config() {
      this.setProps({
        attrs: { "tooltip-align": this.props.align },
        children: [
          this.props.children,
          {
            ref: (c) => {
              this.arrow = c;
            },
            classes: { "nom-tooltip-arrow": true },
            children: `#<svg aria-hidden="true" width="24" height="6" viewBox="0 0 24 7" fill="currentColor" xmlns="http://www.w3.org/2000/svg" ><path d="M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z"></path></svg>`,
          },
        ],
      });
      super._config();
    }
    _rendered() {
      const bg = getComputedStyle(this.element)["background-color"];
      this.arrow.element.style.color = bg;
    }
    _checkVisible() {
      let currentElement = this.element;
      let overflowAncestor = null;
      while (currentElement !== null && currentElement instanceof Element) {
        const style = window.getComputedStyle(currentElement);
        if (style.overflowY !== "visible") {
          overflowAncestor = currentElement;
          break;
        }
        currentElement = currentElement.parentNode;
      }
      if (overflowAncestor) {
        const parentRect = overflowAncestor.getBoundingClientRect();
        const elementRect = this.element.getBoundingClientRect();
        if (elementRect.top < parentRect.top || this.shouldFixPosition) {
          this.shouldFixPosition = true;
          this.props.position = Object.assign({}, this.props.position, {
            offset: [0, 25],
          });
          this.setPosition();
        }
      }
    }
    _fixDirection() {
      if (!this.element) return false;
      if (this.props.align === "top" || this.props.align === "bottom") {
        if (this.element.getAttribute("offset-y") !== "0") {
          this.element.setAttribute(
            "tooltip-align",
            this.props.align === "top" ? "bottom" : "top"
          );
        } else {
          this.element.setAttribute("tooltip-align", this.props.align);
        }
      } else if (this.props.align === "left" || this.props.align === "right") {
        if (this.element.getAttribute("offset-x") !== "0") {
          this.element.setAttribute(
            "tooltip-align",
            this.props.align === "left" ? "right" : "left"
          );
        } else {
          this.element.setAttribute("tooltip-align", this.props.align);
        }
      }
      if (this.props.animate) {
        this.addClass(`nom-tooltip-animate-show`);
      }
    }
    _remove() {
      this.opener._off("mouseenter", this._showHandler);
      this.opener._off("mouseleave", this._hideHandler);
      this.opener._off("focusin", this._onOpenerFocusinHandler);
      this.opener._off("focusout", this._onOpenerFocusoutHandler);
      this._off("mouseenter");
      this._off("mouseleave");
      clearTimeout(this.showTimer);
      this.showTimer = null;
      clearTimeout(this.hideTimer);
      this.hideTimer = null;
      super._remove();
    }
    _bindHover() {
      this.opener._on("mouseenter", this._showHandler);
      this.opener._on("mouseleave", this._hideHandler);
      this.opener._on("focusin", this._onOpenerFocusinHandler);
      this.opener._on("focusout", this._onOpenerFocusoutHandler);
    }
    _onOpenerFocusinHandler() {
      this._openerFocusing = true;
      this._showHandler();
    }
    _onOpenerFocusoutHandler() {
      this._openerFocusing = false;
      this._hideHandler();
    }
    _showHandler() {
      clearTimeout(this.hideTimer);
      this.hideTimer = null;
      this.showTimer = setTimeout(() => {
        this.show();
      }, this.delay);
    }
    _hideHandler() {
      if (
        this._openerFocusing === true &&
        this.opener.componentType !== "Button"
      ) {
        return;
      }
      clearTimeout(this.showTimer);
      this.showTimer = null;
      if (this.props.hidden === false) {
        this.hideTimer = setTimeout(() => {
          this.props && this.props.animate && this.animateHide();
          this.props && !this.props.animate && this.hide();
        }, this.delay);
      }
    }
    animateHide() {
      if (!this.element) return false;
      this.addClass("nom-tooltip-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
        this.removeClass("nom-tooltip-animate-hide");
      }, 90);
    }
    _show() {
      super._show();
      if (!this.props.ignoreMouseEvent) {
        this._off("mouseenter");
        this._on("mouseenter", function () {
          clearTimeout(this.hideTimer);
        });
        this._off("mouseleave", this._hideHandler);
        this._on("mouseleave", this._hideHandler);
      }
      const docTop = this.getScrollTop();
      if (docTop !== 0) {
        this.element.style.top = `${
          this.element.style.top.replace("px", "") - docTop
        }px`;
      }
      this._fixDirection();
      if (this.props.align === "top" && this.props.isInvalidTip) {
        this._checkVisible();
      }
    }
    getScrollTop() {
      let scroll_top = 0;
      if (document.documentElement && document.documentElement.scrollTop) {
        scroll_top = document.documentElement.scrollTop;
      } else if (document.body) {
        scroll_top = document.body.scrollTop;
      }
      return scroll_top;
    }
  }
  Tooltip.defaults = {
    trigger: null,
    align: "top",
    alignOuter: true,
    ignoreMouseEvent: false,
    closeOnClickOutside: true,
    autoRender: false,
    hidden: false,
  };
  Component.mixin({
    _rendered: function () {
      if (this.props.tooltip) {
        if (isString(this.props.tooltip)) {
          this.tooltip = new Tooltip({
            trigger: this,
            children: this.props.tooltip,
          });
        } else {
          this.tooltip = new Tooltip(
            Component.extendProps({}, this.props.tooltip, { trigger: this })
          );
        }
      }
    },
  });
  Component.register(Tooltip);
  /* eslint-disable no-useless-escape */ const RuleManager = {};
  RuleManager.ruleTypes = {
    required: {
      validate: function (value) {
        return !isEmpty(value);
      },
      message: "",
    },
    number: {
      validate: function (value) {
        return !isEmpty(value)
          ? /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value)
          : true;
      },
      message: "",
    },
    digits: {
      validate: function (value) {
        return !isEmpty(value) ? /^\d+$/.test(value) : true;
      },
      message: "",
    },
    regex: {
      validate: function (value, ruleValue) {
        return !isEmpty(value)
          ? new RegExp(ruleValue.pattern, ruleValue.attributes).test(value)
          : true;
      },
    },
    email: {
      validate: function (value) {
        return !isEmpty(value)
          ? /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(
              value
            )
          : true;
      },
      message: " Email ",
    },
    url: {
      validate: function (value) {
        return !isEmpty(value)
          ? /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(
              value
            )
          : true;
      },
      message: " URL",
    },
    min: {
      validate: function (value, ruleValue) {
        return !isEmpty(value)
          ? Number(value.replace(/,/g, "")) >= ruleValue
          : true;
      },
      message: " {0}",
    },
    max: {
      validate: function (value, ruleValue) {
        return !isEmpty(value)
          ? Number(value.replace(/,/g, "")) <= ruleValue
          : true;
      },
      message: " {0}",
    },
    range: {
      validate: function (value, ruleValue) {
        return !isEmpty(value)
          ? Number(value.replace(/,/g, "")) >= ruleValue[0] &&
              Number(value.replace(/,/g, "")) <= ruleValue[1]
          : true;
      },
      message: " {0}  {1} ",
    },
    minlength: {
      validate: function (value, ruleValue) {
        if (!isEmpty(value)) {
          let length = 0;
          if (Array.isArray(value)) {
            length = value.length;
          } else {
            length = value.trim().length;
          }
          return length >= ruleValue;
        }
        return true;
      },
      message: " {0} ",
    },
    maxlength: {
      validate: function (value, ruleValue) {
        if (!isEmpty(value)) {
          let length = 0;
          if (Array.isArray(value)) {
            length = value.length;
          } else {
            length = value.trim().length;
          }
          return length <= ruleValue;
        }
        return true;
      },
      message: " {0} ",
    },
    rangelength: {
      validate: function (value, ruleValue) {
        if (!isEmpty(value)) {
          let length = 0;
          if (Array.isArray(value)) {
            length = value.length;
          } else {
            length = value.trim().length;
          }
          return ruleValue[0] <= length && length <= ruleValue[1];
        }
        return true;
      },
      message: " {0}  {1} ",
    },
    remote: {
      validate: function (value, ruleValue) {
        const data = {};
        data[ruleValue[1]] = value;
        const response = $.ajax({
          url: ruleValue[0],
          dataType: "json",
          data: data,
          async: false,
          cache: false,
          type: "post",
        }).responseText;
        return response === "true";
      },
      message: "Please fix this field",
    },
    date: {
      validate: function () {
        return true;
      },
      message: ".",
    },
    identifier: {
      validate: function (value) {
        return !isEmpty(value) ? /^[a-zA-Z][a-zA-Z0-9_]*$/.test(value) : true;
      },
      message: "",
    },
    phoneNumber: {
      validate: function (value) {
        return !isEmpty(value) ? /^1[1-9][0-9]{9}$/.test(value) : true;
      },
      message: "",
    },
    telephone: {
      validate: function (value) {
        return !isEmpty(value)
          ? /^((\d{3,4}\-)|)\d{7,8}(|([-\u8f6c]{1}\d{1,5}))$/.test(value)
          : true;
      },
      message: "",
    },
    IDCard: {
      validate: function (value) {
        return !isEmpty(value) ? checkIDCard(value) : true;
      },
      message: "",
    },
    noScript: {
      validate: function (value) {
        return !isEmpty(value) ? !hasScriptLabel(value) : true;
      },
      message: '"<script>""</script>"',
    },
    func: {
      validate: function (value, ruleValue) {
        if (isFunction(ruleValue)) {
          return ruleValue(value);
        }
        return true;
      },
    },
  };
  RuleManager.validate = function (rules, controlValue) {
    for (let i = 0; i < rules.length; i++) {
      const checkResult = checkRule(rules[i], controlValue);
      if (checkResult !== true) {
        return checkResult;
      }
    }
    return true;
  };
  function isEmpty(val) {
    return (
      val === undefined ||
      val === null ||
      val === "" ||
      (Array.isArray(val) && !val.length)
    );
  }
  function checkRule(ruleSettings, controlValue) {
    const rule = RuleManager.ruleTypes[ruleSettings.type];
    if (rule) {
      let ruleValue = ruleSettings.value || null;
      if (!rule.validate(controlValue, ruleValue)) {
        let message = ruleSettings.message || rule.message;
        if (ruleValue !== null) {
          if (!Array.isArray(ruleValue)) {
            ruleValue = [ruleValue];
          }
          for (let i = 0; i < ruleValue.length; i++) {
            message = message.replace(
              new RegExp(`\\{${i}\\}`, "g"),
              ruleValue[i]
            );
          }
        }
        return message;
      }
    }
    return true;
  }
  function checkIDCard(idcode) {
    // 
    const weight_factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]; // 
    const check_code = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
    const code = `${idcode}`;
    const last = idcode[17];
    const seventeen = code.substring(0, 17); // 
    const arr = seventeen.split("");
    const len = arr.length;
    let num = 0;
    for (let i = 0; i < len; i++) {
      num += arr[i] * weight_factor[i];
    }
    const resisue = num % 11;
    const last_no = check_code[resisue];
    /*
    0
    0-9
    1920
    01-12
    01-31
    0-9
    0-9X
    */ const idcard_patter = /^[1-9][0-9]{5}([1][9][0-9]{2}|[2][0][0|1][0-9])([0][1-9]|[1][0|1|2])([0][1-9]|[1|2][0-9]|[3][0|1])[0-9]{3}([0-9]|[X])$/;
    const format = idcard_patter.test(idcode); // 
    return !!(last === last_no && format);
  }
  function hasScriptLabel(str) {
    return new RegExp(".*?script[^>]*?.*?(</.*?script.*?>)*", "ig").test(str);
  }
  var FieldActionMixin = {
    _created: function () {
      this.field = this.parent;
      this.field.action = this;
    },
  };
  var ControlActionMixin = {
    _created: function () {
      this.field = this.parent.field;
      this.field.controlAction = this;
    },
  };
  var ControlAfterMixin = {
    _created: function () {
      this.field = this.parent.field;
      this.field.controlAfter = this;
    },
  };
  var ControlBeforeMixin = {
    _created: function () {
      this.field = this.parent.field;
      this.field.controlBefore = this;
    },
  };
  var ControlMixin = {
    _created: function () {
      this.field = this.parent.field;
      this.field.control = this;
      this.form = this.field.form;
      this.__isControl = true;
    },
  };
  class FieldContent extends Component {
    // eslint-disable-next-line no-useless-constructor
    constructor(props, ...mixins) {
      super(props, ...mixins);
    }
    _created() {
      this.field = this.parent;
      this.field.content = this;
    }
    _config() {
      const {
        control,
        controlBefore,
        controlAfter,
        controlAction,
        extra,
        controlWidth,
      } = this.field.props;
      let controlProps = control;
      if (isNumeric(controlWidth)) {
        controlProps = Component.extendProps(controlProps, {
          attrs: {
            style: {
              width: `${controlWidth}px`,
              maxWidth: `${controlWidth}px`,
              flexBasis: `${controlWidth}px`,
            },
          },
        });
      }
      let controlAfterProps = null;
      if (controlAfter) {
        controlAfterProps = {
          component: "List",
          classes: { "nom-control-after": true },
        };
        if (Array.isArray(controlAfter)) {
          controlAfterProps = Component.extendProps(controlAfterProps, {
            items: controlAfter,
          });
        } else {
          controlAfterProps = Component.extendProps(
            controlAfterProps,
            controlAfter
          );
        }
      }
      let controlBeforeProps = null;
      if (controlBefore) {
        controlBeforeProps = {
          component: "List",
          classes: { "nom-control-before": true },
        };
        if (Array.isArray(controlAfter)) {
          controlBeforeProps = Component.extendProps(controlBeforeProps, {
            items: controlBefore,
          });
        } else {
          controlBeforeProps = Component.extendProps(
            controlBeforeProps,
            controlBefore
          );
        }
      }
      let controlActionProps = null;
      if (controlAction) {
        controlActionProps = {
          component: "List",
          gutter: "sm",
          classes: { "nom-control-action": true },
        };
        if (Array.isArray(controlAction)) {
          controlActionProps = Component.extendProps(controlActionProps, {
            items: controlAction,
          });
        } else {
          controlActionProps = Component.extendProps(
            controlActionProps,
            controlAction
          );
        }
      }
      this.setProps({
        children: [
          controlBeforeProps && n$1(controlBeforeProps, [ControlBeforeMixin]),
          n$1(
            null,
            Component.extendProps(controlProps, {
              classes: { "nom-control": true },
            }),
            null,
            [ControlMixin]
          ),
          extra && {
            tag: "div",
            classes: { "nom-control-extra": true },
            children: extra,
          },
          controlAfterProps && n$1(controlAfterProps, [ControlAfterMixin]),
          controlActionProps && n$1(controlActionProps, [ControlActionMixin]),
        ],
      });
    }
  }
  Component.register(FieldContent);
  class FieldLabel extends Component {
    // constructor(props, ...mixins) {
    //   super(props)
    // }
    _created() {
      this.field = this.parent;
    }
    _config() {
      this._addPropStyle("uistyle");
      const { labelExpandable, labelActions } = this.props;
      const children = [
        {
          tag: "label",
          classes: { "nom-label": true },
          children: this.field.props.label,
        },
      ];
      if (labelActions) {
        children.push(labelActions);
        this.setProps({ classes: { "has-actions": true } });
      }
      if (labelExpandable) {
        children.push({
          component: "Button",
          ref: (c) => {
            this.field.expandBtnRef = c;
          },
          type: "text",
          size: "small",
          expanded: labelExpandable.expanded !== false,
          expandable: {
            byClick: true,
            target: () => {
              return this.field.content;
            },
            expandedProps: { rightIcon: "up" },
            collapsedProps: { rightIcon: "down" },
          },
        });
      }
      this.setProps({ children: children });
    }
  }
  Component.register(FieldLabel);
  let nameSeq$1 = 0;
  class Field extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Field.defaults, props), ...mixins);
    }
    _created() {
      const { name, defaultValue } = this.props;
      if (isNullish(this.props.value) && !isNullish(defaultValue)) {
        this.props.value = defaultValue;
      } else if (
        isPlainObject(this.props.value) &&
        !isNullish(defaultValue) &&
        isPlainObject(defaultValue)
      ) {
        this.props.value = Object.assign({}, defaultValue, this.props.value);
      }
      this.oldValue = null;
      this.currentValue = this.props.value;
      this.initValue = clone(this.currentValue) || null;
      if (name) {
        this.name = name;
        this._autoName = false;
      } else {
        this._autoName = true;
        this.name = `__field${++nameSeq$1}`;
      }
      this.group = this.props.__group || null;
      if (this.parent && this.parent.__isControl === true) {
        this.group = this.parent.field;
      }
      this.rootField = this.group === null ? this : this.group.rootField;
      this.rules = [];
      if (this.props.enableReadMode) {
        this.isReadMode = true;
      }
    }
    _config() {
      delete this.errorTip;
      this._addPropStyle(
        "required",
        "requiredMark",
        "labelAlign",
        "controlWidth",
        "plain",
        "variant"
      );
      if (this.props.labelAlign !== "top" || !this.props.label) {
        this.props.labelExpandable = false;
      }
      if (this.props.readonly) {
        this.props.enableReadMode = false;
      }
      const {
        label,
        labelAlign,
        labelWidth,
        span,
        notShowLabel,
        required,
        requiredMessage,
        rules = [],
        action,
        labelActions,
        labelExpandable,
        labelUiStyle,
        actionAlign,
        enableReadMode,
      } = this.props;
      const showLabel =
        notShowLabel === false && label !== undefined && label !== null; // 
      if (
        Array.isArray(this.props.dependencies) &&
        this.props.dependencies.length
      ) {
        this._handleDependencies();
      }
      this.rules = this.rules.concat(rules);
      if (required === true) {
        this.rules.unshift({ type: "required", message: requiredMessage });
      }
      if (span) {
        this.setProps({ styles: { col: span } });
      }
      let labelProps = showLabel
        ? {
            component: FieldLabel,
            labelActions: labelActions,
            labelExpandable: labelExpandable,
            uistyle: labelUiStyle,
          }
        : null;
      if (labelProps && labelWidth && labelAlign !== "top") {
        if (labelWidth === "auto") {
          labelProps = Component.extendProps(labelProps, {
            attrs: { style: { maxWidth: `unset`, flexBasis: `auto` } },
          });
        } else {
          labelProps = Component.extendProps(labelProps, {
            attrs: {
              style: {
                width: `${labelWidth}px`,
                maxWidth: `${labelWidth}px`,
                flexBasis: `${labelWidth}px`,
              },
            },
          });
        }
      }
      let actionProps = null;
      if (action) {
        actionProps = {
          component: "List",
          classes: { "nom-field-action": true },
          gutter: "sm",
        };
        if (Array.isArray(action)) {
          actionProps = Component.extendProps(actionProps, { items: action });
        } else {
          actionProps = Component.extendProps(actionProps, action);
        }
      }
      let toggleReadonlyProps = null;
      if (enableReadMode) {
        toggleReadonlyProps = {
          classes: { "nom-field-read-mode-btns": true },
          children: [
            {
              component: "Button",
              ref: (c) => {
                this.enableReadModeBtnRef = c;
              },
              icon: this.isReadMode ? "edit" : "check",
              type: "text",
              onClick: () => {
                if (this.isReadMode) {
                  this._setReadMode(false);
                } else {
                  this._setReadMode(true);
                  if (this.props.enableReadMode.onChange) {
                    this._callHandler(this.props.enableReadMode.onChange, {
                      newValue: this.currentValue,
                      oldValue: this.oldValue,
                    });
                  }
                }
              },
            },
            {
              component: "Button",
              type: "text",
              icon: "close",
              classes: { "nom-field-read-mode-btns-reset": true },
              onClick: () => {
                this.reset();
                this._setReadMode(true);
              },
            },
          ],
        };
      }
      this.setProps({
        attrs: { "data-field-name": this.name },
        classes: {
          "s-readonly": this.props.readonly,
          "s-compact": this.props.compact,
          [`nom-field-action-align-${actionAlign || "default"}`]: true,
          "nom-field-with-action": !!actionProps,
          "s-read-mode": !!enableReadMode && this.isReadMode === true,
          "s-allow-read-mode": !!enableReadMode,
          "s-allow-read-mode-hover":
            enableReadMode && enableReadMode.hover === true,
        },
        children: [
          labelProps,
          {
            component: FieldContent,
            value: this.props.value,
            hidden:
              this.props.labelExpandable &&
              this.props.labelExpandable.expanded === false,
          },
          toggleReadonlyProps,
          actionProps && n$1(actionProps, [FieldActionMixin]),
        ],
      });
    }
    _rendered() {
      if (this.props.readonly) {
        const postion = this.element.style.position;
        if (!postion || !postion.length || postion === "static") {
          this.element.style.position = "relative";
        }
      }
    }
    _setReadMode(isReadMode) {
      if (isReadMode) {
        this.enableReadModeBtnRef.update({ icon: "edit" });
        this.isReadMode = true;
        this.element.classList.add("s-read-mode");
      } else {
        this.enableReadModeBtnRef.update({ icon: "check" });
        this.isReadMode = false;
        this.element.classList.remove("s-read-mode");
      }
    }
    _handleDependencies() {
      const { dependencies } = this.props;
      dependencies.forEach((item) => {
        const field = this.rootField.getField(item);
        if (field) {
          field._addRelatedField(this);
        }
      });
    }
    _onSourceValueChange(args) {
      for (const item in this._relatedFields) {
        const field = this._relatedFields[item];
        if (field) {
          field._onDependencyValueChange(args, this);
        }
      }
    }
    _onDependencyValueChange(args, field) {
      this._callHandler(
        this.props.onDependencyValueChange,
        Object.assign({}, args, { source: field })
      );
    }
    _addRelatedField(field) {
      if (!this._relatedFields) {
        this._relatedFields = {};
      }
      this._relatedFields[field.name] = field;
    }
    _update() {
      this.rules = [];
    }
    toggleReadonly(param) {
      if (this.element.classList.contains("s-readonly")) {
        if (param !== true) {
          this.element.classList.remove("s-readonly");
        }
      } else if (param !== false) {
        this.element.classList.add("s-readonly");
      }
    }
    expand() {
      if (this.expandBtnRef) {
        this.expandBtnRef.expand();
      }
    }
    collapse() {
      if (this.expandBtnRef) {
        this.expandBtnRef.collapse();
      }
    }
    toggleExpand() {
      if (!this.props.labelExpandable) {
        return;
      }
      this.expandBtnRef.props.expanded === true
        ? this.collapse()
        : this.expand();
    }
    getValue(options) {
      const value = isFunction(this._getValue) ? this._getValue(options) : null;
      return value;
    }
    setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      isFunction(this._setValue) && this._setValue(value, options);
    }
    getValueText(options, value) {
      return isFunction(this._getValueText)
        ? this._getValueText(options, value)
        : this.getValue();
    }
    validate(options) {
      this.validateTriggered = true;
      const valid = this._validate(options);
      if (this.expandBtnRef && !valid) {
        this.expand();
      }
      return valid;
    }
    _validate(options) {
      const { disabled, hidden } = this.props;
      if (disabled || hidden) {
        return true;
      }
      let rules = this.rules;
      const value = this._getRawValue ? this._getRawValue() : this.getValue();
      if (Array.isArray(rules) && rules.length > 0) {
        if (options && options.ignoreRequired) {
          rules = rules.filter((item) => {
            return item.type !== "required";
          });
        }
        const validationResult = RuleManager.validate(rules, value);
        if (validationResult === true) {
          this.removeClass("s-invalid");
          this.trigger("valid");
          if (this.errorTip) {
            this.errorTip.remove();
            delete this.errorTip;
          }
          return true;
        }
        this.addClass("s-invalid");
        this.trigger("invalid", validationResult);
        this._invalid(validationResult);
        return false;
      }
      return true;
    }
    _invalid(message) {
      if (!this.errorTip) {
        this.errorTip = new Tooltip(
          extend(
            {},
            {
              trigger: this,
              classes: { "nom-field-invalid-tooltip": true },
              isInvalidTip: true,
              reference: this.content,
              alignTo: this.content,
              hidden: true,
              offset:
                !this.props.invalidTip.align ||
                this.props.invalidTip.align === "top"
                  ? [0, 10]
                  : null,
              styles: { color: "danger" },
              children: message,
            },
            this.props.invalidTip
          )
        );
        if (this.element.contains(document.activeElement)) {
          this.errorTip.show();
        }
      } else {
        this.errorTip.update({ children: message });
      }
    } // rootFieldfield()
    focusField(target) {
      if (!this._debounceTimer) {
        target.focus();
        if (!isTargetInViewport(target)) {
          target.element.scrollIntoView({ block: "center" });
        }
      }
      clearTimeout(this._debounceTimer);
      this._debounceTimer = setTimeout(() => {
        this._debounceTimer = null;
      }, 100);
    }
    focus() {
      isFunction(this._focus) && this._focus();
      this.element.focus();
    }
    blur() {
      isFunction(this._blur) && this._blur();
    }
    reset() {
      isFunction(this._reset) && this._reset();
    }
    clear() {
      isFunction(this._clear) && this._clear();
    }
    after(props) {
      if (props) {
        props.__group = this.group;
      }
      return super.after(props);
    }
    _reset() {
      this._resetValidStatus();
      this.setValue(this.initValue);
    }
    _clear() {
      this._resetValidStatus();
      this.setValue(null);
    }
    _resetValidStatus() {
      this.removeClass("s-invalid");
      if (this.errorTip) {
        this.errorTip.remove();
        delete this.errorTip;
      }
      this.validateTriggered = false;
      if (this.fields && this.fields.length) {
        for (let i = 0; i < this.fields.length; i++) {
          this.fields[i]._resetValidStatus &&
            this.fields[i]._resetValidStatus();
        }
      }
    }
    triggerEdit() {
      const element = this.control.element;
      const event = new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
      });
      element.dispatchEvent(event);
      this.focus();
    }
    _remove() {
      if (this.group && Array.isArray(this.group.fields)) {
        const fields = this.group.fields;
        for (let i = 0; i < fields.length; i++) {
          if (fields[i] === this) {
            delete fields[i];
            fields.splice(i, 1);
          }
        }
      }
    }
    _triggerDependencyValueChange() {
      const args = {
        name: this.props.name,
        oldValue: this.oldValue,
        newValue: this.currentValue,
      };
      this._onSourceValueChange(args);
    } // 
    _onValueChange(args) {
      const that = this;
      this.oldValue = clone(this.currentValue);
      this.currentValue = clone(this.getValue());
      this.props.value = this.currentValue;
      args = extend(true, args, {
        name: this.props.name,
        oldValue: this.oldValue,
        newValue: this.currentValue,
      });
      setTimeout(function () {
        that.props &&
          that.props.onValueChange &&
          that._callHandler(that.props.onValueChange, args);
        that.group &&
          that.group._onValueChange({
            changedField: args.changedField || that,
          });
        isFunction(that._valueChange) && that._valueChange(args);
        if (that.validateTriggered) {
          that._validate();
        }
      }, 0);
      this._triggerDependencyValueChange();
    }
  }
  Field.defaults = {
    label: null,
    labelAlign: "right",
    invalidTip: {},
    uistyle: "default",
    value: null,
    defaultValue: null,
    flatValue: false,
    span: null,
    notShowLabel: false,
    rules: [],
    extra: null,
    tabindex: null,
    compact: false,
    labelExpanded: true,
  };
  Object.defineProperty(Field.prototype, "fields", {
    get: function () {
      if (!this.control) return [];
      return this.control.getChildren().filter((x) => {
        return !!x;
      });
    },
  });
  Component.register(Field);
  class Input extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "input",
        attrs: { type: "text", autocomplete: "off" },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.capsLock = false;
    }
    _config() {
      this.setProps({
        attrs: {
          value: this.props.value,
          oninput: () => {
            if (!this.capsLock) {
              this.textbox._onValueChange();
              this.textbox._onInput && this.textbox._onInput();
            }
          },
          onblur: () => {
            this.textbox.trigger("blur");
            this.textbox._onBlur();
          },
          oncompositionstart: () => {
            this.capsLock = true;
          },
          oncompositionend: () => {
            this.capsLock = false;
            this.element.dispatchEvent(new Event("input"));
          },
        },
      });
    }
    _rendered() {
      if (this.textbox.props.autofocus === true) {
        this.focus();
      }
    }
    getText() {
      return this.element.value;
    }
    setText(text) {
      this.element.value = text;
    }
    focus() {
      this.element.focus();
    }
    blur() {
      this.element.blur();
    }
    disable() {
      this.element.setAttribute("disabled", "disabled");
    }
    enable() {
      this.element.removeAttribute("disabled", "disabled");
    }
  }
  class Textbox extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Textbox.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const {
        allowClear,
        clearProps,
        leftIcon,
        prefix,
        rightIcon,
        suffix,
        minlength,
        maxlength,
        showWordLimit,
        placeholder,
        value,
        htmlType,
        button,
        readonly,
        disabled,
        restrictInput,
      } = this.props;
      if (
        minlength &&
        minlength > 0 &&
        this.rules.findIndex((rule) => rule.type === "minlength") === -1
      ) {
        this.setProps({
          rules: [{ type: "minlength", value: minlength }, ...this.props.rules],
        });
      } // icon
      let leftIconProps = Component.normalizeIconProps(leftIcon);
      if (leftIconProps != null) {
        leftIconProps = Component.extendProps(leftIconProps, {
          classes: { "nom-textbox-left-icon": true },
        });
      } // icon
      let rightIconProps = Component.normalizeIconProps(rightIcon);
      if (rightIconProps != null) {
        rightIconProps = Component.extendProps(rightIconProps, {
          classes: { "nom-textbox-right-icon": true },
        });
      }
      const buttonProps = isPlainObject(button)
        ? Component.extendProps(
            { component: Button, classes: { "nom-textbox-button": true } },
            button
          )
        : null;
      const inputProps = {
        component: Input,
        name: "input", // readonly: restrictInput,
        attrs: {
          value: value,
          placeholder: placeholder,
          maxlength,
          minlength,
          type: htmlType,
          readonly: readonly || restrictInput ? "readonly" : null,
        },
        hidden: !!this.props.displayValue,
        _created: function () {
          this.textbox = that;
          this.textbox.input = this;
        },
      };
      const textRefProps = this.props.displayValue
        ? {
            component: Input,
            name: "input", // readonly: restrictInput,
            attrs: {
              value: isString(this.props.displayValue)
                ? this.props.displayValue
                : "",
              placeholder: placeholder,
              maxlength,
              minlength,
              type: htmlType,
              readonly: readonly || restrictInput ? "readonly" : null,
            },
            _created: function () {
              this.textbox = that;
              this.textbox.displayTextRef = this;
            },
          }
        : undefined;
      const selfClearProps = {
        component: Icon,
        type: "times",
        classes: { "nom-textbox-clear": true, "nom-field-clear-handler": true },
        hidden: !this.props.value,
        ref: (c) => {
          this.clearIcon = c;
        },
        onClick: (args) => {
          this.setValue(null);
          this.props.onClear && this._callHandler(this.props.onClear);
          this.props.allowClear && this.clearIcon.hide();
          args.event && args.event.stopPropagation();
        },
      }; // 
      const getAffixSpan = (affix, type = "prefix") => ({
        tag: "span",
        classes: { "nom-input-affix": true, [`nom-input-${type}`]: true },
        children: affix,
      });
      const getSuffix = () => {
        const child = []; // 
        if (allowClear && !disabled) {
          if (this._ignoreReadonlyClear()) {
            child.push(clearProps || selfClearProps);
          } else if (!readonly) {
            child.push(clearProps || selfClearProps);
          }
        }
        if (rightIcon) {
          child.push(rightIconProps);
        } else if (suffix && isString(suffix)) {
          child.push(suffix);
        }
        return {
          tag: "div",
          classes: { "nom-input-affix": true, "nom-input-suffix": true },
          children: child,
        };
      }; // 
      const getWordLimitSpan = () => ({
        tag: "span",
        classes: { "nom-input-affix": true, [`nom-input-count`]: true },
        ref: (c) => {
          this.wordLimitRef = c;
        },
        children: `${(value || "").length}/${maxlength}`,
      });
      this.hasWordLimit =
        htmlType === "text" &&
        showWordLimit &&
        maxlength &&
        !readonly &&
        !disabled; // icon prefixx || icon suffix
      const affixWrapper =
        allowClear ||
        leftIcon ||
        prefix ||
        rightIcon ||
        suffix ||
        this.hasWordLimit;
      const baseTextProps = [
        leftIcon && leftIconProps,
        !leftIcon && prefix && isString(prefix) && getAffixSpan(prefix),
        inputProps,
        textRefProps,
        getSuffix(),
        this.hasWordLimit && getWordLimitSpan(),
      ];
      this.setProps({
        attrs: { readonly: readonly || null },
        classes: {
          "p-with-button": buttonProps !== null,
          "p-auto-width": !!this.props.autoWidth,
        },
        control: {
          disabled: disabled,
          children: affixWrapper
            ? [
                {
                  //  wrapper
                  classes: { "nom-textbox-affix-wrapper": true },
                  children: baseTextProps,
                },
                buttonProps,
              ]
            : [...baseTextProps, buttonProps],
        },
      });
      super._config();
    } //  readonly 
    _ignoreReadonlyClear() {
      return ["DatePicker", "TimePicker", "PartialDatePicker"].includes(
        this.componentType
      );
    }
    _rendered() {
      const that = this;
      if (this.props.autoWidth) {
        this._initAutoWidth();
      }
      if (this.props.onEnter) {
        this.input._on("keydown", function (event) {
          if (event.keyCode && event.keyCode === 13) {
            that._callHandler(that.props.onEnter, { value: that.getValue() });
          }
        });
      }
    }
    _setDisplayValue(value) {
      this.displayTextRef &&
        this.displayTextRef.props &&
        this.displayTextRef.setText(value);
      if (isNullish(value)) {
        this.displayValue = "";
      } else {
        this.displayValue = value;
      }
    }
    _updateWodLimit() {
      this.wordLimitRef.update({
        children: `${this.getText().length}/${this.props.maxlength}`,
      });
    }
    getText() {
      return this.input.getText();
    }
    _getValue() {
      const { trimValue } = this.props;
      let inputText = this.getText();
      inputText = trimValue ? inputText.trimLeft().trimRight() : inputText;
      if (inputText === "") {
        return null;
      }
      return inputText;
    }
    _valueChange(changed) {
      if (!this.props || !this.clearIcon) return;
      changed.newValue
        ? this.props.allowClear && this.clearIcon.show()
        : this.props.allowClear && this.clearIcon.hide();
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      this.input.setText(value);
      const newValue = this.getValue();
      this.oldValue = this.currentValue;
      if (options.triggerChange) {
        if (newValue !== this.oldValue) {
          super._onValueChange();
        }
      }
      this.currentValue = newValue;
      if (this.props.autoWidth) {
        this._updateAutoWidth();
      }
    }
    focus() {
      this.input.focus();
    }
    blur() {
      this.input.blur();
    }
    _onInput() {
      if (this.hasWordLimit) {
        this._updateWodLimit();
      }
      if (this.props.autoWidth) {
        this._updateAutoWidth();
      }
    }
    _onBlur() {
      this._callHandler(this.props.onBlur);
    }
    _disable() {
      this.input.disable();
    }
    _enable() {
      this.input.enable();
    }
    _initAutoWidth() {
      const inputEl = this.input.element;
      this.measureSpan = document.createElement("span");
      this.measureSpan.style.cssText = `
      position:absolute;
      visibility:hidden;
      white-space:pre;
      font-size:${window.getComputedStyle(inputEl).fontSize};
      font-family:${window.getComputedStyle(inputEl).fontFamily};
    `;
      document.body.appendChild(this.measureSpan);
      this._updateAutoWidth();
    }
    _updateAutoWidth() {
      const text = this.getText() || this.props.placeholder || "";
      this.measureSpan.textContent = text;
      const width = this.measureSpan.offsetWidth + 12;
      const minWidth = this.props.autoWidth.minWidth || 200;
      this.input.element.style.width = `${Math.max(width, minWidth)}px`;
    }
  }
  Textbox.defaults = {
    leftIcon: null,
    prefix: null, // 
    rightIcon: null,
    suffix: null, // 
    maxlength: null,
    minlength: null,
    showWordLimit: false,
    autofocus: false,
    restrictInput: false,
    placeholder: null,
    value: null,
    autoWidth: false, // 
    htmlType: "text",
    onEnter: null,
    allowClear: true,
    trimValue: true, // getValue 
  };
  Component.register(Textbox);
  class Empty extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Empty.defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = ["size"];
      const { image, imageStyle, description } = this.props;
      let imageNode = image;
      if (typeof image === "string" && !image.startsWith("#")) {
        imageNode = { tag: "img", attrs: { src: image, alt: description } };
      }
      const { children } = this.props;
      this.setProps({
        classes: {
          [`nom-empty-normal`]: image === Empty.PRESENTED_IMAGE_SIMPLE,
        },
        children: [
          {
            classes: { [`nom-empty-image`]: true },
            attrs: { style: imageStyle },
            children: imageNode,
          },
          description
            ? {
                classes: { [`nom-empty-description`]: true },
                children: description,
              }
            : undefined,
          children
            ? { classes: { [`nom-empty-footer`]: true }, children: children }
            : undefined,
        ],
      });
    }
  }
  Empty.PRESENTED_IMAGE_SIMPLE = `#<svg t="1619148284824" class="nom-empty-img-simple"  width="64" height="64" viewBox="0 0 1351 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2122" width="200" height="200"><path d="M467.21267 479.648s2.688 2.688 8.096 2.688h393.44c2.688 0 5.376-2.688 8.096-2.688V358.4h409.6c-2.688-8.096-2.688-13.472-8.096-21.568L1014.25267 59.264H335.18067L71.08467 336.832c-5.376 2.688-8.096 10.784-8.096 21.568h409.6v121.248h-5.376z m-409.6-61.952v476.96c0 37.728 40.416 70.048 88.928 70.048h1053.632c48.512 0 88.928-32.352 88.928-70.048V412.288H936.07667v64.672c0 32.352-29.632 59.296-61.984 59.296h-393.44c-35.04 0-61.984-26.944-61.984-59.296v-64.672H62.95667v5.376zM1200.20467 1024H146.57267C65.74067 1024 1.06867 964.704 1.06867 894.656v-476.96c-2.688-48.512-2.688-94.304 29.632-123.968L313.64467 0h724.896l282.944 293.728c32.352 29.632 29.632 83.552 29.632 142.816v455.424C1345.74067 964.736 1278.34867 1024 1200.20467 1024z" p-id="2123" fill="#d9d9d9"></path></svg>`;
  Empty.PRESENTED_IMAGE_DEFAULT = `#<svg t="1619147741727" class="nom-empty-img-normal"  width="184" height="152" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4197" width="200" height="200"><path d="M0 933.456842a456.737684 85.342316 0 1 0 913.475368 0 456.737684 85.342316 0 1 0-913.475368 0Z" fill="#F5F5F7" fill-opacity=".8" p-id="4198"></path><path d="M822.130526 682.738526L660.944842 484.372211c-7.733895-9.337263-19.038316-14.989474-30.942316-14.989474h-346.543158c-11.897263 0-23.201684 5.652211-30.935579 14.989474L91.351579 682.738526v103.632842h730.778947V682.738526z" fill="#AEB8C2" p-id="4199"></path><path d="M775.390316 794.165895L634.543158 624.990316c-6.743579-8.131368-16.889263-12.577684-27.270737-12.577684H305.071158c-10.374737 0-20.527158 4.446316-27.270737 12.577684L136.953263 794.165895v92.914526h638.437053V794.165895z" fill="#000000" p-id="4200"></path><path d="M227.907368 213.355789h457.653895a26.947368 26.947368 0 0 1 26.947369 26.947369v628.843789a26.947368 26.947368 0 0 1-26.947369 26.947369H227.907368a26.947368 26.947368 0 0 1-26.947368-26.947369V240.303158a26.947368 26.947368 0 0 1 26.947368-26.947369z" fill="#F5F5F7" p-id="4201"></path><path d="M287.514947 280.407579h338.438737a13.473684 13.473684 0 0 1 13.473684 13.473684V462.012632a13.473684 13.473684 0 0 1-13.473684 13.473684H287.514947a13.473684 13.473684 0 0 1-13.473684-13.473684V293.881263a13.473684 13.473684 0 0 1 13.473684-13.473684z m1.765053 268.220632h334.908632a15.238737 15.238737 0 0 1 0 30.477473H289.28a15.238737 15.238737 0 0 1 0-30.477473z m0 79.245473h334.908632a15.245474 15.245474 0 0 1 0 30.484211H289.28a15.245474 15.245474 0 0 1 0-30.484211z m531.354947 293.066105c-5.221053 20.688842-23.558737 36.109474-45.372631 36.109474H138.206316c-21.813895 0-40.151579-15.427368-45.365895-36.109474a49.300211 49.300211 0 0 1-1.495579-12.058947V682.745263h177.300211c19.584 0 35.368421 16.491789 35.368421 36.513684v0.269474c0 20.015158 15.966316 36.176842 35.550315 36.176842h234.341053c19.584 0 35.550316-16.309895 35.550316-36.331789V719.292632c0-20.021895 15.784421-36.554105 35.368421-36.554106h177.30021v226.149053a49.381053 49.381053 0 0 1-1.488842 12.05221z" fill="#DCE0E6" p-id="4202"></path><path d="M842.920421 224.282947l-46.012632 17.852632a6.736842 6.736842 0 0 1-8.872421-8.286316l13.049264-41.815579c-17.441684-19.833263-27.681684-44.018526-27.681685-70.117052C773.402947 54.581895 841.566316 0 925.655579 0 1009.724632 0 1077.894737 54.581895 1077.894737 121.916632c0 67.334737-68.163368 121.916632-152.245895 121.916631-30.504421 0-58.906947-7.181474-82.728421-19.550316z" fill="#DCE0E6" p-id="4203"></path><path d="M985.626947 106.004211c10.597053 0 19.193263 8.488421 19.193264 18.96421s-8.596211 18.964211-19.193264 18.964211c-10.597053 0-19.193263-8.488421-19.193263-18.964211s8.596211-18.964211 19.193263-18.96421z m-119.619368 2.371368l18.863158 33.185684h-38.386526l19.523368-33.185684z m76.43621 0v33.185684h-33.583157v-33.185684h33.583157z" fill="#FFFFFF" p-id="4204"></path></svg>`;
  Empty.defaults = {
    description: "",
    image: Empty.PRESENTED_IMAGE_DEFAULT,
    imageStyle: {},
    size: "xsmall",
  };
  Component.register(Empty);
  class LayoutAsider extends Component {
    // constructor(props, ...mixins) {
    //   super(props)
    // }
  }
  Component.register(LayoutAsider);
  class LayoutBody extends Component {
    // constructor(props, ...mixins) {
    //     super(props)
    // }
  }
  Component.register(LayoutBody);
  class LayoutFooter extends Component {
    // constructor(props, ...mixins) {
    //     super(props);
    // }
  }
  Component.register(LayoutFooter);
  class LayoutHeader extends Component {
    // constructor(props, ...mixins) {
    //   super(props)
    // }
  }
  Component.register(LayoutHeader);
  class LayoutSider extends Component {
    // constructor(props, ...mixins) {
    //   super(props)
    // }
  }
  Component.register(LayoutSider);
  class Layout extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Layout.defaults, props), ...mixins);
    }
    _config() {
      const { header, body, footer, sider, asider } = this.props;
      this._addPropStyle("fit");
      this.setProps({
        tag: "div",
        header: header && { component: LayoutHeader },
        body: body && { component: LayoutBody },
        footer: footer && { component: LayoutFooter },
        sider: sider && { component: LayoutSider },
        asider: asider && { component: LayoutAsider },
      });
      if (sider || asider) {
        this.setProps({
          classes: { "p-has-sider": true },
          children: [this.props.sider, this.props.body, this.props.asider],
        });
      } else {
        this.setProps({
          children: [this.props.header, this.props.body, this.props.footer],
        });
      }
    }
  }
  Layout.defaults = {
    header: null,
    body: null,
    footer: null,
    sider: null,
    asider: null,
    fit: true,
  };
  Component.register(Layout);
  class Popup extends Layer {
    constructor(props, ...mixins) {
      const defaults = {
        trigger: null,
        triggerAction: "click",
        align: "bottom left",
        alignOuter: true,
        closeOnClickOutside: true,
        placement: "append",
        autoRender: false,
        hidden: true,
        content: null,
        uistyle: "default",
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this._showHandler = this._showHandler.bind(this);
      this._hideHandler = this._hideHandler.bind(this);
      this._onOpenerClickHandler = this._onOpenerClickHandler.bind(this);
      this.opener = this.props.trigger;
      this.opener.on("remove", () => {
        this.remove();
      });
      this.props.alignTo = this.opener.element;
      this.showTimer = null;
      this.hideTimer = null;
      this.addRel(this.opener.element);
      this._bindTrigger();
    }
    _config() {
      if (this.props.content && this.componentType === "Popup") {
        this.setProps({
          classes: { "nom-popup-adapt-to-screen": true },
          children: { children: this.props.content },
        });
      }
      super._config();
    }
    setPosition() {
      super.setPosition();
      if (this.props.content) {
        const t = this.element.style.top || 10;
        const h = `calc(100vh - ${parseInt(t, 10) + 20}px)`;
        this.element.style.maxHeight = h;
      }
    }
    _bindTrigger() {
      const { triggerAction } = this.props;
      if (triggerAction === "click") {
        this._bindClick();
      }
      if (triggerAction === "hover") {
        this._bindHover();
      }
      if (triggerAction === "both") {
        this._bindClick();
        this._bindHover();
      }
    }
    _bindClick() {
      this.opener._on("click", this._onOpenerClickHandler);
    }
    _bindHover() {
      this.opener._on("mouseenter", this._showHandler);
      this.opener._on("mouseleave", this._hideHandler);
    }
    _onOpenerClickHandler() {
      if (this.opener.props.disabled !== true) {
        this.toggleHidden();
      }
    }
    _showHandler() {
      if (this.opener.props.disabled !== true) {
        clearTimeout(this.hideTimer);
        this.hideTimer = null;
        this.showTimer = setTimeout(() => {
          this.show();
        }, this.delay);
      }
    }
    _hideHandler() {
      if (this.opener.props.disabled !== true) {
        clearTimeout(this.showTimer);
        this.showTimer = null;
        if (this.props.hidden === false) {
          this.hideTimer = setTimeout(() => {
            this.hide();
          }, this.delay);
        }
      }
    }
    _show() {
      super._show();
      if (this.props.triggerAction === "hover") {
        this._off("mouseenter");
        this._on("mouseenter", () => {
          clearTimeout(this.hideTimer);
        });
        this._off("mouseleave");
        this._on("mouseleave", this._hideHandler);
      }
    }
  }
  Component.mixin({
    _rendered: function () {
      if (this.props.popup) {
        this.props.popup.trigger = this;
        const refName = this.props.popup.refName || "popup";
        this[refName] = new Popup(this.props.popup);
      }
    },
  });
  Component.register(Popup);
  /* eslint-disable */ function t(t) {
    return "object" == typeof t && null != t && 1 === t.nodeType;
  }
  function e(t, e) {
    return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t;
  }
  function n(t, n) {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
      var r = getComputedStyle(t, null);
      return (
        e(r.overflowY, n) ||
        e(r.overflowX, n) ||
        (function (t) {
          var e = (function (t) {
            if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
            try {
              return t.ownerDocument.defaultView.frameElement;
            } catch (t) {
              return null;
            }
          })(t);
          return (
            !!e &&
            (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth)
          );
        })(t)
      );
    }
    return !1;
  }
  function r(t, e, n, r, i, o, l, d) {
    return (o < t && l > e) || (o > t && l < e)
      ? 0
      : (o <= t && d <= n) || (l >= e && d >= n)
      ? o - t - r
      : (l > e && d < n) || (o < t && d > n)
      ? l - e + i
      : 0;
  }
  function compute(e, i) {
    var o = window,
      l = i.scrollMode,
      d = i.block,
      u = i.inline,
      h = i.boundary,
      a = i.skipOverflowHiddenElements,
      c =
        "function" == typeof h
          ? h
          : function (t) {
              return t !== h;
            };
    if (!t(e)) throw new TypeError("Invalid target");
    for (
      var f = document.scrollingElement || document.documentElement,
        s = [],
        p = e;
      t(p) && c(p);

    ) {
      if ((p = p.parentElement) === f) {
        s.push(p);
        break;
      }
      (null != p &&
        p === document.body &&
        n(p) &&
        !n(document.documentElement)) ||
        (null != p && n(p, a) && s.push(p));
    }
    for (
      var m = o.visualViewport ? o.visualViewport.width : innerWidth,
        g = o.visualViewport ? o.visualViewport.height : innerHeight,
        w = window.scrollX || pageXOffset,
        v = window.scrollY || pageYOffset,
        W = e.getBoundingClientRect(),
        b = W.height,
        H = W.width,
        y = W.top,
        E = W.right,
        M = W.bottom,
        V = W.left,
        x = "start" === d || "nearest" === d ? y : "end" === d ? M : y + b / 2,
        I = "center" === u ? V + H / 2 : "end" === u ? E : V,
        C = [],
        T = 0;
      T < s.length;
      T++
    ) {
      var k = s[T],
        B = k.getBoundingClientRect(),
        D = B.height,
        O = B.width,
        R = B.top,
        X = B.right,
        Y = B.bottom,
        L = B.left;
      if (
        "if-needed" === l &&
        y >= 0 &&
        V >= 0 &&
        M <= g &&
        E <= m &&
        y >= R &&
        M <= Y &&
        V >= L &&
        E <= X
      )
        return C;
      var S = getComputedStyle(k),
        j = parseInt(S.borderLeftWidth, 10),
        q = parseInt(S.borderTopWidth, 10),
        z = parseInt(S.borderRightWidth, 10),
        A = parseInt(S.borderBottomWidth, 10),
        F = 0,
        G = 0,
        J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0,
        K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
      if (f === k)
        (F =
          "start" === d
            ? x
            : "end" === d
            ? x - g
            : "nearest" === d
            ? r(v, v + g, g, q, A, v + x, v + x + b, b)
            : x - g / 2),
          (G =
            "start" === u
              ? I
              : "center" === u
              ? I - m / 2
              : "end" === u
              ? I - m
              : r(w, w + m, m, j, z, w + I, w + I + H, H)),
          (F = Math.max(0, F + v)),
          (G = Math.max(0, G + w));
      else {
        (F =
          "start" === d
            ? x - R - q
            : "end" === d
            ? x - Y + A + K
            : "nearest" === d
            ? r(R, Y, D, q, A + K, x, x + b, b)
            : x - (R + D / 2) + K / 2),
          (G =
            "start" === u
              ? I - L - j
              : "center" === u
              ? I - (L + O / 2) + J / 2
              : "end" === u
              ? I - X + z + J
              : r(L, X, O, j, z + J, I, I + H, H));
        var N = k.scrollLeft,
          P = k.scrollTop;
        (x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K)))),
          (I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J))));
      }
      C.push({ el: k, top: F, left: G });
    }
    return C;
  }
  function isOptionsObject(options) {
    return options === Object(options) && Object.keys(options).length !== 0;
  }
  function defaultBehavior(actions, behavior) {
    if (behavior === void 0) {
      behavior = "auto";
    }
    var canSmoothScroll = "scrollBehavior" in document.body.style;
    actions.forEach(function (_ref) {
      var el = _ref.el,
        top = _ref.top,
        left = _ref.left;
      if (el.scroll && canSmoothScroll) {
        el.scroll({ top: top, left: left, behavior: behavior });
      } else {
        el.scrollTop = top;
        el.scrollLeft = left;
      }
    });
  }
  function getOptions(options) {
    if (options === false) {
      return { block: "end", inline: "nearest" };
    }
    if (isOptionsObject(options)) {
      return options;
    }
    return { block: "start", inline: "nearest" };
  }
  function scrollIntoView(target, options) {
    var targetIsDetached = !target.ownerDocument.documentElement.contains(
      target
    );
    if (isOptionsObject(options) && typeof options.behavior === "function") {
      return options.behavior(targetIsDetached ? [] : compute(target, options));
    }
    if (targetIsDetached) {
      return;
    }
    var computeOptions = getOptions(options);
    return defaultBehavior(
      compute(target, computeOptions),
      computeOptions.behavior
    );
  }
  var ListItemContentMixin = {
    _created: function () {
      this.parent.content = this;
    },
    _config: function () {
      const { onSelect, onUnselect, selected } = this.props;
      const listProps = this.parent.parent.parent.props;
      const selectedItems =
        listProps.selectedItems !== null &&
        listProps.selectedItems !== undefined
          ? Array.isArray(listProps.selectedItems)
            ? listProps.selectedItems
            : [listProps.selectedItems]
          : [];
      this.setProps({
        classes: { "nom-list-item-content": true },
        selected: selected === true || selectedItems.indexOf(this.key) !== -1,
        selectable: {
          byClick: listProps.itemSelectable.byClick,
          canRevert: listProps.itemSelectable.multiple === true,
        },
        _shouldHandleClick: function () {
          if (listProps.disabled === true) {
            return false;
          }
        },
        onSelect: () => {
          const list = this.parent.parent.parent;
          if (listProps.itemSelectable.multiple === false) {
            listProps.selectedItems = this.key;
            if (list.selectedItem !== null) {
              list.selectedItem.unselect({ triggerSelectionChange: false });
            }
            list.selectedItem = this;
            list._onItemSelected(this.parent.props.data);
          }
          this._callHandler(onSelect);
        },
        onUnselect: () => {
          const list = this.parent.parent.parent;
          if (listProps.selectedItems === this.key) {
            listProps.selectedItems = null;
          }
          if (list.selectedItem === this) {
            list.selectedItem = null;
          }
          this._callHandler(onUnselect);
        },
        onSelectionChange: () => {
          const list = this.parent.parent.parent;
          list._onItemSelectionChange();
        },
      });
    },
    _rendered: function () {
      const list = this.parent.parent.parent;
      const listProps = list.props;
      if (listProps.itemSelectable.multiple === false) {
        if (this.props.selected) {
          list.selectedItem = this;
          if (listProps.itemSelectable.multiple.scrollIntoValue) {
            list.scrollTo(list.selectedItem);
          }
        }
      }
    },
  };
  class ListItem extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ListItem.defaults, props), ...mixins);
    }
    _created() {
      this.list = this.parent.list;
      const { dataFields = { key: "key" } } = this.list.props;
      const { data } = this.props;
      Object.keys(dataFields).forEach((dataField) => {
        this.props[dataField] = data[dataFields[dataField]];
      });
      this._setKey();
      this.list.itemRefs[this.key] = this;
    }
    _config() {
      const {
        itemRender = ({ itemData }) => {
          return { children: itemData };
        },
      } = this.list.props;
      const { data } = this.props;
      this.setProps({
        selectable: { byClick: false },
        children: itemRender({ itemData: data, list: this.list, item: this }),
        childDefaults: n$1(null, null, null, [ListItemContentMixin]),
      });
    }
    _remove() {
      delete this.list.itemRefs[this.key];
    }
    select(selectOption) {
      this.content.select(selectOption);
    }
    unselect() {
      this.content.unselect();
    }
  }
  ListItem.defaults = { tag: "li", data: null };
  Component.register(ListItem);
  var ListItemMixin = {
    _created: function () {
      this.wrapper = this.parent;
      this.wrapper.item = this;
      this.list = this.wrapper.list;
      this.list.itemRefs[this.key] = this;
    },
    _config: function () {
      const { onSelect, onUnselect, selected } = this.props;
      const listProps = this.list.props;
      const selectedItems =
        listProps.selectedItems !== null &&
        listProps.selectedItems !== undefined
          ? Array.isArray(listProps.selectedItems)
            ? listProps.selectedItems
            : [listProps.selectedItems]
          : [];
      this.setProps({
        classes: { "nom-list-item": true },
        selected: selected === true || selectedItems.indexOf(this.key) !== -1,
        selectable: {
          byClick: listProps.itemSelectable.byClick,
          canRevert:
            listProps.itemSelectable.canRevert ||
            listProps.itemSelectable.multiple === true,
        },
        _shouldHandleClick: function () {
          if (listProps.disabled === true) {
            return false;
          }
        },
        onSelect: () => {
          if (listProps.itemSelectable.multiple === false) {
            listProps.selectedItems = this.key;
            if (this.list.selectedItem !== null) {
              this.list.selectedItem.unselect({
                triggerSelectionChange: false,
              });
            }
            this.list.selectedItem = this;
          }
          this._callHandler(onSelect);
        },
        onUnselect: () => {
          if (listProps.selectedItems === this.key) {
            listProps.selectedItems = null;
          }
          if (this.list.selectedItem === this) {
            this.list.selectedItem = null;
          }
          this._callHandler(onUnselect);
        },
        onSelectionChange: () => {
          this.list._onItemSelectionChange();
        },
      });
    },
    _rendered: function () {
      const listProps = this.list.props;
      if (listProps.itemSelectable.multiple === false) {
        if (this.props.selected) {
          this.list.selectedItem = this;
          if (listProps.itemSelectable.multiple.scrollIntoValue) {
            this.list.scrollTo(this.list.selectedItem);
          }
        }
      }
    },
    _remove: function () {
      delete this.list.itemRefs[this.key];
    },
  };
  class ListItemWrapper extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ListItemWrapper.defaults, props), ...mixins);
    }
    _created() {
      this.list = this.parent.list || this.parent.parent.parent.parent.list;
    }
    _config() {
      this._addPropStyle("span");
      const { item, span } = this.props;
      const { itemDefaults } = this.list.props;
      if (this.props.disabled) {
        item.disabled = true;
      }
      if (!span && item.span) {
        this.setProps({ span: item.span });
      }
      this.setProps({
        selectable: false,
        children: item,
        childDefaults: n$1(null, itemDefaults, null, [ListItemMixin]),
      });
    }
  }
  ListItemWrapper.defaults = { tag: "li", item: {} };
  Component.register(ListItemWrapper);
  class ListContent extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ListContent.defaults, props), ...mixins);
    }
    _created() {
      this.list = this.parent;
      this.list.content = this;
    }
    _config() {
      this._addPropStyle("gutter", "line", "align", "justify", "cols");
      const {
        items,
        wrappers,
        wrapperDefaults,
        virtual,
        data,
      } = this.list.props;
      const children = [];
      if (Array.isArray(data) && data.length > 0) {
        for (let i = 0; i < data.length; i++) {
          const itemData = data[i];
          children.push({
            component: ListItem,
            data: itemData,
            classes: Object.assign({}, this._getDragClassNames(itemData)),
          });
        }
      } else if (Array.isArray(wrappers) && wrappers.length > 0) {
        for (let i = 0; i < wrappers.length; i++) {
          let wrapper = wrappers[i];
          wrapper = Component.extendProps(
            {},
            {
              component: ListItemWrapper,
              classes: Object.assign({}, this._getDragClassNames(wrappers[i])),
            },
            wrapperDefaults,
            wrapper
          );
          children.push(wrapper);
        }
      } else if (Array.isArray(items) && items.length > 0) {
        for (let i = 0; i < items.length; i++) {
          if (
            this.list.props.disabledItems.length &&
            this.list.props.disabledItems.includes(items[i].key)
          ) {
            children.push({
              component: ListItemWrapper,
              item: items[i],
              disabled: true,
              classes: Object.assign({}, this._getDragClassNames(items[i])),
            });
          } else {
            children.push({
              component: ListItemWrapper,
              item: items[i],
              classes: Object.assign({}, this._getDragClassNames(items[i])),
            });
          }
        }
      } // 
      if (
        (virtual === true || typeof virtual === "number") &&
        children.length > 20
      ) {
        this.list.virtual.listData = children;
        this.setProps({
          classes: { "nom-virtual-list-content": true },
          children: this.list.virGetList(this.list.virVisibleData()),
          childDefaults: wrapperDefaults,
        });
      } else {
        this._processLoadMore(children);
        this.setProps({ children: children, childDefaults: wrapperDefaults });
      }
    } // 
    _processLoadMore(children) {
      const { loadMoreRef } = this.list;
      if (loadMoreRef && loadMoreRef.hidden === true) return;
      const { loadMore } = this.list.props;
      if (loadMore && loadMore.resolve) {
        children.push({
          component: "Button",
          type: "link",
          text: loadMore.text || this.list.props.loadmoreText,
          _created: (inst) => {
            this.list.loadMoreRef = inst;
          },
          onClick: ({ sender }) => {
            const loading = new nomui.Loading({ container: sender });
            const result = loadMore.resolve();
            if (result && result.then) {
              return result
                .then((value) => {
                  loading && loading.remove();
                  this._processLoadResult(value);
                })
                .catch(() => {
                  loading && loading.remove();
                });
            }
            loading && loading.remove();
            this._processLoadResult(result);
          },
        });
      }
    }
    _processLoadResult(result) {
      if (!result || !result.length) return this.list.loadMoreRef.hide();
      const { data, items } = this.list.props;
      const isDataType = data && data.length; // result 
      if (isDataType) {
        this.list.setProps({ data: data.concat(result) });
      } else {
        this.list.setProps({ items: items.concat(result) });
      }
      this.update();
    }
    _rendered() {
      const { sortable, virtual } = this.list.props;
      const that = this; // 
      if (sortable && !virtual) {
        const _options = {
          group: this.key,
          animation: 150,
          fallbackOnBody: true,
          swapThreshold: 0.65,
          handle: sortable.handleClassName,
          filter: ".s-disabled",
          draggable: ".could-drag",
          onEnd: function (event) {
            // const data = { oldIndex: evt.oldIndex, newIndex: evt.newIndex }
            that.list.handleDrag(event);
          },
        };
        if (sortable.draggableClassName) {
          _options.draggable = sortable.draggableClassName;
        }
        new Sortable(this.element, _options);
      }
    }
    getItem(param) {
      let retItem = null;
      if (param instanceof Component) {
        return param;
      }
      if (isFunction(param)) {
        for (const key in this.itemRefs) {
          if (this.itemRefs.hasOwnProperty(key)) {
            if (param.call(this.itemRefs[key]) === true) {
              retItem = this.itemRefs[key];
              break;
            }
          }
        }
      } else {
        return this.itemRefs[param];
      }
      return retItem;
    }
    selectItem(param, selectOption) {
      const item = this.getItem(param);
      item && item.select(selectOption);
    }
    selectItems(param, selectOption) {
      selectOption = extend(
        { triggerSelect: true, triggerSelectionChange: true },
        selectOption
      );
      let itemSelectionChanged = false;
      param = Array.isArray(param) ? param : [param];
      for (let i = 0; i < param.length; i++) {
        itemSelectionChanged =
          this.selectItem(param[i], {
            triggerSelect: selectOption.triggerSelect,
            triggerSelectionChange: false,
          }) || itemSelectionChanged;
      }
      if (
        selectOption.triggerSelectionChange === true &&
        itemSelectionChanged
      ) {
        this._onItemSelectionChange();
      }
      return itemSelectionChanged;
    }
    selectAllItems(selectOption) {
      const children = this.getChildren();
      if (this.list.loadMoreRef) children.pop();
      return this.selectItems(children, selectOption);
    }
    unselectItem(param, unselectOption) {
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      const item = this.getItem(param);
      item && item.unselect(unselectOption);
    }
    unselectItems(param, unselectOption) {
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      let itemSelectionChanged = false;
      if (Array.isArray(param)) {
        for (let i = 0; i < param.length; i++) {
          itemSelectionChanged =
            this.unselectItem(param[i], {
              triggerUnselect: unselectOption.triggerUnselect,
              triggerSelectionChange: false,
            }) || itemSelectionChanged;
        }
      }
      if (unselectOption.triggerSelectionChange && itemSelectionChanged) {
        this._onItemSelectionChange();
      }
      return itemSelectionChanged;
    }
    unselectAllItems(unselectOption) {
      return this.unselectItems(this.getAllItems(), unselectOption);
    }
    getAllItems() {
      const items = [];
      const children = this.getChildren();
      if (this.list.loadMoreRef) children.pop();
      for (let i = 0; i < children.length; i++) {
        const itemWrapper = children[i];
        items.push(itemWrapper.item);
      }
      return items;
    }
    _onItemSelectionChange() {
      this._callHandler(this.props.onItemSelectionChange);
    }
    getSelectedItem() {
      return this.selectedItem;
    }
    getSelectedItems() {
      const selectedItems = [];
      const children = this.getChildren();
      for (let i = 0; i < children.length; i++) {
        const { item } = children[i];
        if (item.props.selected) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    }
    _getDragClassNames(item) {
      const { sortable } = this.list.props;
      if (!sortable) return {};
      const dragClasses = {};
      const { disabledDragKeys } = sortable;
      if (!disabledDragKeys || !disabledDragKeys.includes(item.key)) {
        dragClasses[sortable.draggableClassName || "could-drag"] = true;
      }
      return dragClasses;
    }
    appendItem(itemProps) {
      itemProps = Component.extendProps({}, this.props.itemDefaults, itemProps);
      const itemWrapperProps = {
        component: ListItemWrapper,
        item: itemProps,
        classes: Object.assign({}, this._getDragClassNames(itemProps)),
      };
      this.appendChild(itemWrapperProps);
    }
    appendDataItem(itemData) {
      const itemProps = {
        component: ListItem,
        data: itemData,
        classes: Object.assign({}, this._getDragClassNames(itemData)),
      };
      this.appendChild(itemProps);
    }
    prependDataItem(itemData) {
      const itemProps = {
        component: ListItem,
        data: itemData,
        classes: Object.assign({}, this._getDragClassNames(itemData)),
      };
      this.prependChild(itemProps);
    }
    removeItem(param) {
      const item = this.getItem(param);
      if (item !== null) {
        item.wrapper.remove();
      }
    }
    removeItems(param) {
      if (Array.isArray(param)) {
        for (let i = 0; i < param.length; i++) {
          this.removeItem(param[i]);
        }
      }
    }
  }
  ListContent.defaults = { tag: "ul" };
  Component.register(ListContent);
  class List extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        virtualSupport: {
          height: typeof props.virtual === "number" ? props.virtual : 300, // 
          size: 30, // 
          bufferScale: 1, // 
        },
      };
      super(Component.extendProps(List.defaults, defaults, props), ...mixins);
    }
    _update(props) {
      if ((props && props.data) || this.props.items) {
        this.loadMoreRef = null;
      }
    }
    _config() {
      const { virtual, vertical } = this.props;
      this.itemRefs = {};
      this.selectedItem = null;
      this._addPropStyle(
        "gutter",
        "line",
        "align",
        "justify",
        "cols",
        "overflow"
      );
      let empty = null;
      if (isPlainObject(this.props.showEmpty)) {
        empty = Object.assign({ component: "Empty" }, this.props.showEmpty);
      } else {
        empty = { component: "Empty" };
      }
      const children =
        !this.props.items.length && this.props.showEmpty
          ? empty
          : { component: ListContent };
      if (
        this.props.items.length > 20 &&
        (virtual === true || typeof virtual === "number")
      ) {
        if (!this.virtual || this.firstRender) {
          this.virCreated();
        }
        this.virChildren(children);
      } else {
        this.setProps({
          classes: { "nom-list-vertical": vertical },
          children: children,
        });
      }
    }
    getItem(param) {
      let retItem = null;
      if (param instanceof Component) {
        return param;
      }
      if (isFunction(param)) {
        for (const key in this.itemRefs) {
          if (this.itemRefs.hasOwnProperty(key)) {
            if (param.call(this.itemRefs[key]) === true) {
              retItem = this.itemRefs[key];
              break;
            }
          }
        }
      } else {
        return this.itemRefs[param] || null;
      }
      return retItem;
    }
    selectItem(param, selectOption) {
      const item = this.getItem(param);
      item && item.select(selectOption);
      if (this.props.itemSelectable.scrollIntoView) {
        this.scrollTo(item);
      }
    }
    selectItems(param, selectOption) {
      selectOption = extend(
        { triggerSelect: true, triggerSelectionChange: true },
        selectOption
      );
      let itemSelectionChanged = false;
      param = Array.isArray(param) ? param : [param];
      for (let i = 0; i < param.length; i++) {
        itemSelectionChanged =
          this.selectItem(param[i], {
            triggerSelect: selectOption.triggerSelect,
            triggerSelectionChange: false,
          }) || itemSelectionChanged;
      }
      if (
        selectOption.triggerSelectionChange === true &&
        itemSelectionChanged
      ) {
        this._onItemSelectionChange();
      }
      return itemSelectionChanged;
    }
    selectAllItems(selectOption) {
      return this.selectItems(this.content.getChildren(), selectOption);
    }
    unselectItem(param, unselectOption) {
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      const item = this.getItem(param);
      item && item.unselect(unselectOption);
    }
    unselectItems(param, unselectOption) {
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      let itemSelectionChanged = false;
      if (Array.isArray(param)) {
        for (let i = 0; i < param.length; i++) {
          itemSelectionChanged =
            this.unselectItem(param[i], {
              triggerUnselect: unselectOption.triggerUnselect,
              triggerSelectionChange: false,
            }) || itemSelectionChanged;
        }
      }
      if (unselectOption.triggerSelectionChange && itemSelectionChanged) {
        this._onItemSelectionChange();
      }
      return itemSelectionChanged;
    }
    unselectAllItems(unselectOption) {
      return this.unselectItems(this.getAllItems(), unselectOption);
    }
    getAllItems() {
      const items = [];
      const children = this.content.getChildren();
      for (let i = 0; i < children.length; i++) {
        const itemWrapper = children[i]; //  itemWrapper
        items.push(itemWrapper.item || itemWrapper);
      }
      return items;
    }
    _onItemSelectionChange() {
      this._callHandler(this.props.onItemSelectionChange, {
        selectedItem: this.selectedItem,
      });
    }
    getSelectedItem() {
      return this.selectedItem;
    }
    getSelectedData() {
      const { itemSelectable } = this.props;
      if (itemSelectable && itemSelectable.multiple === true) {
        const selectedData = [];
        const children = this.content.getChildren();
        for (let i = 0; i < children.length; i++) {
          const item = children[i];
          if (item.content.props.selected) {
            selectedData.push(item.props.data);
          }
        }
        return selectedData;
      }
      if (!this.selectedItem) {
        return null;
      }
      return this.selectedItem.parent.props.data;
    }
    getSelectedItems() {
      const selectedItems = [];
      const children = this.content.getChildren();
      for (let i = 0; i < children.length; i++) {
        const { item } = children[i];
        if (item.props.selected) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    }
    getUnselectedItems() {
      const UnselectedItems = [];
      const children = this.content.getChildren();
      for (let i = 0; i < children.length; i++) {
        const { item } = children[i];
        if (!item.props.selected) {
          UnselectedItems.push(item);
        }
      }
      return UnselectedItems;
    }
    appendItem(itemProps) {
      this.content.appendItem(itemProps);
    }
    appendDataItem(itemData) {
      this.content.appendDataItem(itemData);
    }
    prependDataItem(itemData) {
      this.content.prependDataItem(itemData);
    }
    removeItem(param) {
      const item = this.getItem(param);
      if (item !== null) {
        item.wrapper ? item.wrapper.remove() : item.remove();
      }
    }
    removeItems(param) {
      if (Array.isArray(param)) {
        for (let i = 0; i < param.length; i++) {
          this.removeItem(param[i]);
        }
      }
    }
    hideItem(param) {
      const item = this.getItem(param);
      if (item !== null) {
        item.wrapper.hide();
      }
    }
    showItem(param) {
      const item = this.getItem(param);
      if (item !== null) {
        item.wrapper.show();
      }
    }
    scrollTo(param) {
      const item = this.getItem(param);
      if (item) {
        const itemElement = item.wrapper ? item.wrapper.element : item.element;
        const scrollOptions =
          this.props.itemSelectable &&
          this.props.itemSelectable.scrollIntoView &&
          isPlainObject(this.props.itemSelectable.scrollIntoView)
            ? this.props.itemSelectable.scrollIntoView
            : {};
        setTimeout(() => {
          scrollIntoView(
            itemElement,
            Component.extendProps(
              { behavior: "smooth", scrollMode: "if-needed" },
              scrollOptions
            )
          );
        }, 200);
      }
    }
    scrollToSelected() {
      if (this.selectedItem) {
        this.scrollTo(this.selectedItem);
      }
    }
    _onItemSelected(itemData) {
      this._callHandler(this.props.onItemSelected, { itemData });
    }
    _rendered() {
      this.props.sortable && defaultSortableOndrop();
    }
    /* -start */ virCreated() {
      const { items, virtualSupport } = this.props;
      this.virtual = {
        virtualTimer: null,
        start: 0,
        end: 0,
        positions: [
          // {
          //   top:0,
          //   bottom:100,
          //   height:100,
          // }
        ],
        selectedItems: [], // 
        itemsRefs: [], // arry
        listData: items, // 
        ListHeight: virtualSupport.height, // 
        estimatedSize: virtualSupport.size, // 
        bufferScale: virtualSupport.bufferScale, // 
        toolDivRef: null,
      };
      this.virInitPositions();
    }
    virChildren(childObj) {
      const { positions, ListHeight } = this.virtual;
      const toolDivHeight = positions[positions.length - 1].bottom;
      this.setProps({
        classes: { "nom-virtual-list-container": true },
        attrs: {
          style: { height: `${ListHeight}px` },
          onscroll: () => {
            this.virScrollEvent();
          },
        },
        children: [
          {
            ref: (c) => {
              this.virtual.toolDivRef = c;
            },
            classes: { "nom-virtual-list-tooldiv": true },
            attrs: { style: { height: `${toolDivHeight}px` } },
            children: "",
          },
          childObj,
        ],
      });
    }
    virGetList(arry) {
      this.virtual.itemsRefs = [];
      const _that = this;
      return arry.map(function (obj) {
        return Component.extendProps(obj, {
          ref: (c) => {
            if (c) _that.virtual.itemsRefs.push(c);
          },
          classes: { "nom-virtual-list-item": true },
          attrs: { "data-key": obj._index },
        });
      });
    } //  
    virUpdated() {
      if (!this.virtual.itemsRefs || !this.virtual.itemsRefs.length) {
        return;
      }
      const { positions, toolDivRef } = this.virtual;
      this.virUpdateItemsSize();
      const toolDivHeight = positions[positions.length - 1].bottom;
      toolDivRef.element.style.height = `${toolDivHeight}px`;
      this.content.update({
        attrs: {
          style: {
            transform: `translate3d(0,${this.virSetStartOffset()}px,0)`,
          },
        },
      });
    } // 
    virInitPositions() {
      const { estimatedSize, listData } = this.virtual;
      this.virtual.positions = listData.map((d, index) => ({
        index,
        height: estimatedSize,
        top: index * estimatedSize,
        bottom: (index + 1) * estimatedSize,
      }));
    } // 
    virGetStartIndex(scrollTop = 0) {
      return this.virBinarySearch(this.virtual.positions, scrollTop);
    } // 
    virBinarySearch(list, value) {
      let start = 0;
      let end = list.length - 1;
      let tempIndex = null;
      while (start <= end) {
        const midIndex = parseInt((start + end) / 2, 10);
        const midValue = list[midIndex].bottom;
        if (midValue === value) {
          return midIndex + 1;
        }
        if (midValue < value) {
          start = midIndex + 1;
        } else if (midValue > value) {
          if (tempIndex === null || tempIndex > midIndex) {
            tempIndex = midIndex;
          }
          end -= 1;
        }
      }
      return tempIndex;
    } // 
    virUpdateItemsSize() {
      const { itemsRefs, positions } = this.virtual;
      itemsRefs.forEach((node) => {
        if (!node.rendered) return;
        const rect = node.element.getBoundingClientRect();
        const height = rect.height;
        const index = +node.element.dataset.key.slice(1);
        const oldHeight = positions[index].height;
        const dValue = oldHeight - height; // 
        if (dValue) {
          positions[index].bottom -= dValue;
          positions[index].height = height;
          for (let k = index + 1; k < positions.length; k++) {
            positions[k].top = positions[k - 1].bottom;
            positions[k].bottom -= dValue;
          }
        }
      });
    } // 
    virSetStartOffset() {
      const { start, positions } = this.virtual;
      let startOffset;
      if (start >= 1 && positions[start]) {
        const size =
          positions[start].top -
          (positions[start - this.virAboveCount()]
            ? positions[start - this.virAboveCount()].top
            : 0);
        startOffset = positions[start - 1].bottom - size;
      } else {
        startOffset = 0;
      }
      return startOffset;
    } // 
    virScrollEvent() {
      // 
      const scrollTop = this.element.scrollTop; // if (!this.virGetStartIndex(scrollTop)) return
      this.virtual.virtualTimer && clearTimeout(this.virtual.virtualTimer);
      this.virtual.virtualTimer = setTimeout(() => {
        // 
        this.virtual.start = this.virGetStartIndex(scrollTop); // 
        this.virtual.end = this.virtual.start + this.virVisibleCount(); // 
        this.virUpdated();
      }, 100);
    }
    virListData() {
      return this.virtual.listData.map((obj, index) => {
        return Object.assign({}, obj, { _index: `_${index}` });
      });
    } // 
    virVisibleCount() {
      return Math.ceil(this.virtual.ListHeight / this.virtual.estimatedSize);
    } // 
    virAboveCount() {
      return Math.min(
        this.virtual.start,
        this.virtual.bufferScale * this.virVisibleCount()
      );
    } // 
    virBelowCount() {
      return Math.min(
        this.virtual.listData.length - this.virtual.end,
        this.virtual.bufferScale * this.virVisibleCount()
      );
    } // 
    virVisibleData() {
      const start = this.virtual.start - this.virAboveCount();
      const end = this.virtual.end + this.virBelowCount();
      return this.virListData().slice(start, end);
    }
    /* -end */ handleDrag(event) {
      const { oldIndex, newIndex } = event;
      this._lastDragIndex = newIndex;
      const { data, items } = this.props;
      const _listData = data && data.length ? data : items;
      const _dragerItem = _listData.splice(oldIndex, 1)[0];
      _listData.splice(newIndex, 0, _dragerItem);
      if (this.props.sortable && this.props.sortable.onEnd) {
        this._callHandler(this.props.sortable.onEnd, { event: event });
      }
    }
    getLastDragItem() {
      if (!this._lastDragIndex) return;
      const { data, items } = this.props;
      const _listData = data && data.length ? data : items;
      return _listData[this._lastDragIndex];
    }
  }
  List.defaults = {
    tag: "div",
    items: [],
    itemDefaults: {},
    data: null, // data
    selectedItems: null,
    itemSelectable: { multiple: false, byClick: false, scrollIntoView: false },
    disabledItems: [],
    virtual: false,
    showEmpty: false, // Boolean || { onEnd: Funciton}
    sortable: false,
    overflow: "hidden",
    loadMore: false,
    loadmoreText: "...",
    vertical: false,
  };
  Component.register(List);
  var AutoCompleteListItemMixin = {
    _config: function () {
      const { onSelect, onUnselect } = this.props;
      const {
        filterName,
        optionFields,
      } = this.parent.parent.parent.autoCompleteControl.props;
      this.setProps({
        selectable: {
          byClick: true,
          canRevert: this.list.autoCompleteControl.props.multiple === false,
        },
        onSelect: () => {
          const { autoCompleteControl } = this.list;
          const autoCompleteOption = {
            value: filterName === "select" ? this.props.text : this.props.value,
            option: this.props,
          };
          if (optionFields && optionFields.value && optionFields.text) {
            autoCompleteOption.value = this.props[optionFields.text];
          }
          autoCompleteControl.input.update(autoCompleteOption);
          this._callHandler(onSelect);
        },
        onUnselect: () => {
          this._callHandler(onUnselect);
        },
        onClick: () => {
          const { autoCompleteControl } = this.list;
          autoCompleteControl.props.animate &&
            autoCompleteControl.popup.animateHide();
          !autoCompleteControl.props.animate &&
            autoCompleteControl.popup.hide();
        },
      });
    },
  };
  class AutoCompleteList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        gutter: "x-md",
        cols: 1,
        vertical: true,
        optionDefaults: Object.assign(
          {
            key() {
              return this.props.value;
            },
            _config: function () {
              const {
                filterName,
                optionFields,
              } = this.parent.parent.parent.autoCompleteControl.props;
              if (optionFields.text && optionFields.value) {
                this.setProps({ children: this.props[optionFields.text] });
              } else {
                this.setProps({
                  children:
                    filterName === "text" ? this.props.value : this.props.text,
                });
              }
            },
          },
          props.optionDefaults
        ),
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.autoCompleteControl = this.parent.parent.parent.autoCompleteControl;
      this.autoCompleteControl.optionList = this;
    }
    _config() {
      const { searchable, options: aops } = this.autoCompleteControl.props;
      const { optionDefaults, options: sops } = this.props;
      const value = this.autoCompleteControl.props.value || "";
      const options = searchable ? aops : sops;
      this.setProps({
        items: options || [],
        itemDefaults: n$1(null, optionDefaults, null, [
          AutoCompleteListItemMixin,
        ]),
        itemSelectable: {
          multiple: false,
          byClick: true,
          scrollIntoView: true,
        },
        selectedItems: value,
        onItemSelectionChange: () => {
          this.autoCompleteControl._onValueChange({ fromSelect: true });
        },
      });
      super._config();
    }
  }
  class AutoCompletePopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = { autoRender: false };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.autoCompleteControl = this.opener.field;
    }
    _config() {
      const autoCompletePopupRef = this;
      const { options } = this.props;
      const {
        searchable,
        debounce,
        interval,
        popupWidth,
      } = this.autoCompleteControl.props;
      let { maxPopupWidth } = this.autoCompleteControl.props;
      if (isNumeric(maxPopupWidth)) {
        maxPopupWidth = `${maxPopupWidth}px`;
      }
      let w = `${this.autoCompleteControl.control.offsetWidth()}px`;
      if (isNumeric(popupWidth)) {
        w = `${popupWidth}px`;
      } else if (popupWidth === "auto") {
        w = "auto";
      }
      this.setProps({
        attrs: {
          style: {
            width: w,
            maxWidth:
              maxPopupWidth ||
              `${this.autoCompleteControl.control.offsetWidth()}px`,
          },
        },
        children: {
          component: Layout,
          header:
            searchable && searchable.sharedInput === false
              ? {
                  children: {
                    component: Textbox,
                    placeholder: searchable.placeholder,
                    _created: (inst) => {
                      autoCompletePopupRef.autoCompleteControl.searchRef = inst;
                    },
                    onValueChange({ newValue }) {
                      if (debounce) {
                        autoCompletePopupRef.timer &&
                          clearTimeout(autoCompletePopupRef.timer);
                        autoCompletePopupRef.timer = setTimeout(() => {
                          const loading = new nomui.Loading({
                            container:
                              autoCompletePopupRef.autoCompleteControl
                                .optionList.parent,
                          });
                          const searchPromise = searchable.onSearch({
                            inputValue: newValue,
                            options,
                          });
                          if (isPromiseLike$1(searchPromise)) {
                            return searchPromise
                              .then((val) => {
                                autoCompletePopupRef.autoCompleteControl.props.options = val;
                                autoCompletePopupRef.autoCompleteControl.optionList.update();
                                loading && loading.remove();
                              })
                              .catch(() => {
                                loading && loading.remove();
                              });
                          }
                          loading && loading.remove();
                          autoCompletePopupRef.autoCompleteControl.props.options = searchPromise;
                          searchPromise &&
                            autoCompletePopupRef.autoCompleteControl.optionList.update();
                        }, interval);
                      }
                    },
                  },
                }
              : null,
          body: { children: autoCompletePopupRef._getOptionList() },
        },
      });
      super._config();
    }
    animateHide() {
      if (!this.element) return false;
      let animateName;
      if (this.element.getAttribute("offset-y") !== "0") {
        animateName = "nom-auto-complete-animate-bottom-hide";
      } else {
        animateName = "nom-auto-complete-animate-top-hide";
      }
      this.addClass(animateName);
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
        this.removeClass(animateName);
      }, 160);
    }
    _show() {
      super._show();
      this.autoCompleteControl.props.autoFocus &&
        this.autoCompleteControl.searchRef &&
        this.autoCompleteControl.searchRef.focus();
      this.removeClass("nom-layer-animate-show");
      this.autoCompleteControl.props.animate && this.animateInit();
    }
    animateInit() {
      if (!this.element) return false;
      if (this.element.getAttribute("offset-y") !== "0") {
        this.addClass("nom-auto-complete-animate-bottom-show");
      } else {
        this.addClass("nom-auto-complete-animate-top-show");
      }
    }
    _getOptionList() {
      const options = this.autoCompleteControl.internalOptions;
      const {
        searchable,
        value,
        filterOption,
        filterName,
        optionDefaults,
        text = "",
      } = this.autoCompleteControl.props;
      const _value = filterName === "text" ? value : text;
      const opts = isFunction(filterOption)
        ? filterOption(_value || "", options)
        : options;
      if (searchable) {
        return { component: AutoCompleteList, optionDefaults, options: opts };
      }
      if (opts && opts.length) {
        return { component: AutoCompleteList, optionDefaults, options: opts };
      }
      this.autoCompleteControl.optionList = null;
      return {
        component: Layout,
        body: { styles: { padding: 1 }, children: { component: Empty } },
      };
    }
  }
  class AutoComplete extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(AutoComplete.defaults, props), ...mixins);
      this._init.bind(this);
      this._handleSearch.bind(this);
      this._doSearch.bind(this);
    }
    _created() {
      super._created();
      this.placeholder = this.props.placeholder;
      this.imeInputing = false;
      this.searchMode = false;
      this.clearContent = true;
      this.internalOptions = {};
    }
    _rendered() {
      const { searchable } = this.props;
      if ((!searchable || searchable.sharedInput !== false) && this.input) {
        this._init();
      }
      const { options } = this.props;
      this.popup = new AutoCompletePopup({
        trigger: this.control,
        options,
        onShow: () => {
          if (this.optionList) {
            this.optionList.update({ selectedItems: this.getValue() });
            this.optionList.scrollToSelected();
          }
        },
      });
    }
    _remove() {
      this.timer && clearTimeout(this.timer);
    }
    _config() {
      const autoCompleteRef = this;
      const { allowClear, options } = this.props;
      this._normalizeSearchable();
      this._normalizeInternalOptions(options);
      if (allowClear && this.currentValue) {
        this.setProps({
          clearProps: {
            component: "Icon",
            type: "times",
            ref: (c) => {
              this.clearIcon = c;
            },
            classes: {
              "nom-auto-complete-clear": true,
              "nom-field-clear-handler": true,
            },
            onClick: ({ event }) => {
              event.stopPropagation();
              autoCompleteRef.clear();
              this.props.onClear && this._callHandler(this.props.onClear);
              this.clearIcon.hide();
              autoCompleteRef.popup && autoCompleteRef.popup.hide();
            },
          },
        });
      }
      if (options && this.popup) {
        this.popup.update({ options });
      }
      super._config();
    }
    _init() {
      const autoComplete = this;
      this.input.element.addEventListener("focus", function () {
        autoComplete.currentValue = this.value;
        if (autoComplete.clearContent) {
          this.placeholder = this.value;
          this.value = "";
        } else {
          autoComplete.clearContent = true;
        }
        autoComplete.popup &&
          autoComplete.popup.update({ options: autoComplete.props.options });
      });
      this.input.element.addEventListener("input", function () {
        if (!autoComplete.imeInputing) {
          autoComplete._handleSearch(this.value);
        }
      });
      this.input.element.addEventListener("blur", function () {
        // ,blurchange
        if (!autoComplete.searchMode) {
          // 
          this.value = autoComplete.currentValue;
        }
        this.placeholder = autoComplete.placeholder || "";
        autoComplete.searchMode = false;
        const { filterName } = autoComplete.props;
        if (filterName === "select" && !autoComplete._getValue()) {
          autoComplete.setProps({ text: "" });
          autoComplete.clear();
        }
        if (autoComplete.props.delayValueChange) {
          setTimeout(() => {
            !autoComplete.optionClicked &&
              autoComplete._onValueChange({ fromBlur: true });
          }, 200);
        }
      }); // 
      this.input.element.addEventListener("compositionstart", function () {
        autoComplete.imeInputing = true;
      });
      this.input.element.addEventListener("compositionend", function () {
        autoComplete.imeInputing = false;
        autoComplete._handleSearch(this.value);
      });
    }
    _getValue() {
      const { options, filterName, optionFields } = this.props;
      const inputText = this._getInputText();
      if (
        filterName === "select" ||
        (optionFields.text && optionFields.value)
      ) {
        const currOption = options.find(
          (item) => item[optionFields.text] === inputText
        );
        if (currOption) {
          return (
            currOption[optionFields.value] || currOption[optionFields.text]
          );
        }
      }
      if (inputText === "") {
        return null;
      }
      return inputText;
    }
    _getInputText() {
      const { trimValue } = this.props;
      let inputText = this.getText();
      inputText = trimValue ? inputText.trimLeft().trimRight() : inputText;
      return inputText;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      const { filterName, options: opt, optionFields } = this.props;
      let _value = value;
      if (filterName === "select") {
        const selectedOption = opt.find((e) => e[optionFields.value] === value);
        if (selectedOption) {
          _value = selectedOption[optionFields.text];
        } else {
          this.input.setText("");
          this.currentValue = null;
          super._onValueChange();
          return;
        }
      }
      this.input.setText(_value);
      const newValue = this.getValue();
      this.oldValue = this.currentValue;
      if (options.triggerChange) {
        if (newValue !== this.oldValue) {
          super._onValueChange();
        }
      }
      this.currentValue = newValue;
    }
    getSelectedOption() {
      const { options, value, optionFields } = this.props;
      if (value) {
        const currOption = options.find(
          (item) => item[optionFields.value] === value
        );
        return currOption;
      }
      return null;
    }
    _valueChange(changed) {
      changed.newValue
        ? this.props.allowClear && this.clearIcon.show()
        : this.props.allowClear && this.clearIcon.hide();
      const { filterName } = this.props;
      filterName === "select" && this.setProps({ text: this._getInputText() });
    }
    _onValueChange(args = {}) {
      if (args.fromSelect) {
        this.optionClicked = true;
      } else {
        this.optionClicked = false;
      }
      const that = this;
      this.oldValue = clone(this.currentValue);
      this.currentValue = clone(this.getValue());
      this.props.value = this.currentValue;
      args = extend(true, args, {
        name: this.props.name,
        oldValue: this.oldValue,
        newValue: this.currentValue,
      });
      if (!this.props.delayValueChange || args.fromSelect || args.fromBlur) {
        setTimeout(function () {
          that.props &&
            that.props.onValueChange &&
            that._callHandler(that.props.onValueChange, args);
          that.group &&
            that.group._onValueChange({
              changedField: args.changedField || that,
            });
          isFunction(that._valueChange) && that._valueChange(args);
          if (that.validateTriggered) {
            that._validate();
          }
        }, 0);
      }
      this._triggerDependencyValueChange();
    }
    blur() {
      super.blur();
    }
    focus() {
      this.clearContent = false;
      super.focus();
    }
    _isFocus() {
      if (!this.input) return false;
      return document.activeElement === this.input.element;
    }
    _handleSearch(txt) {
      const autoComplete = this;
      this.popup && this.popup.show();
      const { debounce, interval } = this.props; // 
      this.timer && clearTimeout(this.timer);
      if (debounce) {
        this.timer = setTimeout(function () {
          autoComplete._doSearch(txt);
        }, interval);
      } else {
        autoComplete._doSearch(txt);
      }
    }
    _doSearch(txt) {
      this.searchMode = true;
      const { onSearch, filterOption, searchable } = this.props;
      const options = this.internalOptions;
      this.setProps({ text: txt });
      if (
        searchable &&
        searchable.sharedInput !== false &&
        isFunction(searchable.onSearch)
      ) {
        const loading = new nomui.Loading({
          container: this.optionList.parent,
        });
        const searchPromise = searchable.onSearch({ inputValue: txt, options });
        if (isPromiseLike$1(searchPromise)) {
          return searchPromise
            .then((val) => {
              this.props.options = val;
              this.optionList.update();
              loading && loading.remove();
            })
            .catch(() => {
              loading && loading.remove();
            });
        }
        loading && loading.remove();
        this.props.options = searchPromise;
        searchPromise && this.optionList.update();
      } else if (isFunction(filterOption)) {
        this.popup.update({ options: filterOption(txt, options) });
      }
      isFunction(onSearch) && onSearch({ text: txt, sender: this });
    }
    _normalizeSearchable() {
      const { searchable, onSearch } = this.props;
      if (searchable) {
        this.setProps({
          searchable: Component.extendProps(
            { placeholder: null, onSearch },
            searchable
          ),
        });
      }
    }
    _normalizeInternalOptions(options) {
      if (!Array.isArray(options) || !options.length) {
        this.internalOptions = [];
        return;
      }
      const { optionFields, filterName } = this.props;
      this.internalOptions = clone(options);
      this.handleOptions(this.internalOptions, optionFields, filterName);
    }
    handleOptions(options, optionFields, filterName) {
      const { text: textField, value: valueField } = optionFields;
      if (!Array.isArray(options)) return [];
      const internalOptions = options;
      for (let i = 0; i < internalOptions.length; i++) {
        const item = internalOptions[i];
        item.value = item[valueField];
        if (filterName === "select") item.text = item[textField];
      }
    }
  }
  AutoComplete.defaults = {
    options: [],
    debounce: true,
    interval: 300,
    optionFields: { value: "value" },
    filterOption: (txt, options) => {
      return options;
    },
    allowClear: true,
    filterName: "text", // text,select
    optionDefaults: {},
    autoFocus: false, // 
    popupWidth: null,
    delayValueChange: false,
  };
  Component.register(AutoComplete);
  class Avatar extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Avatar.defaults, props), ...mixins);
    }
    _config() {
      const { text, icon, src, alt, extra } = this.props;
      this._propStyleClasses = ["size"];
      this.setProps({
        classes: { "avatar-image": !!src },
        children: [
          extra,
          src && {
            tag: "img",
            ref: (c) => {
              this.imgRef = c;
            },
            attrs: { alt: alt },
          },
          icon && {
            component: "Icon",
            type: icon,
            ref: (c) => {
              this.iconRef = c;
            },
          },
          !icon && {
            ref: (c) => {
              this.textRef = c;
            },
            tag: "span",
            classes: { "nom-avatar-string": true },
            children: text || "NA",
          },
        ],
      });
    }
    _setScale() {
      if (!this.props) {
        return;
      }
      const { gap, icon } = this.props;
      if (icon) {
        return;
      }
      if (!this.element.querySelector(".nom-avatar-string")) {
        return;
      }
      const childrenWidth = this.element.querySelector(".nom-avatar-string")
        .offsetWidth;
      const nodeWidth = this.element.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        if (gap * 2 < nodeWidth) {
          const scale =
            nodeWidth - gap * 2 < childrenWidth
              ? (nodeWidth - gap * 2) / childrenWidth
              : 1;
          const transformString = `scale(${scale}) translateX(-50%)`;
          this.textRef &&
            this.textRef.update({
              attrs: {
                style: {
                  "-ms-transform": transformString,
                  "-webkit-transform": transformString,
                  transform: transformString,
                },
              },
            });
        }
      }
    }
    _loadImageAsync() {
      const { src } = this.props;
      if (!src) {
        return Promise.reject(new Error("No image source provided"));
      } // Convert single string src to array for consistent handling
      const srcArray = Array.isArray(src) ? [...src] : [src];
      if (srcArray.length === 0) {
        return Promise.reject();
      }
      let currentIndex = 0;
      const image = this.imgRef.element;
      return new Promise((resolve, reject) => {
        const tryNextImage = () => {
          if (currentIndex >= srcArray.length) {
            reject();
            return;
          }
          const currentSrc = srcArray[currentIndex];
          currentIndex++;
          image.src = currentSrc;
          image.onload = () => {
            this.textRef && this.textRef.hide();
            this.iconRef && this.iconRef.hide();
            resolve();
          };
          image.onerror = () => {
            tryNextImage();
          };
        };
        tryNextImage();
      });
    }
    _rendered() {
      if (this.props.src && this.props.src.length) {
        this._loadImageAsync().catch(() => {
          console.warn("Failed to load avatar images:");
          this.imgRef && this.imgRef.hide();
        });
      }
      this._setScale();
    }
    _created() {
      super._created();
      this.intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this._setScale();
          }
        });
      });
      this.intersectionObserver.observe(this.referenceElement);
    }
    _remove() {
      this.intersectionObserver &&
        this.intersectionObserver.unobserve(this.referenceElement);
      super._remove();
    }
  }
  Avatar.defaults = {
    tag: "span",
    size: "default",
    alt: "",
    gap: 4, // 
    text: null, // 
    icon: null, // 
    src: null, // 
  };
  Component.register(Avatar);
  class AvatarGroup extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(AvatarGroup.defaults, props), ...mixins);
    }
    _config() {
      const {
        size,
        items,
        maxCount,
        maxPopoverPlacement,
        itemDefaults,
      } = this.props; // size
      const avatars = items.map((item) => {
        return Object.assign({ component: Avatar, size }, itemDefaults, item);
      });
      const numOfChildren = avatars.length;
      if (maxCount && maxCount < numOfChildren) {
        const childrenShow = avatars.slice(0, maxCount);
        const childrenHidden = avatars.slice(maxCount, numOfChildren);
        childrenShow.push(
          Object.assign(
            { component: Avatar, text: `+${numOfChildren - maxCount}`, size },
            itemDefaults,
            {
              popup: {
                triggerAction: "hover",
                align: maxPopoverPlacement,
                children: childrenHidden,
                attrs: { style: { padding: "8px 12px" } },
              },
            }
          )
        );
        this.setProps({ children: childrenShow });
      } else {
        this.setProps({ children: avatars });
      }
    }
  }
  AvatarGroup.defaults = {
    tag: "div",
    size: "default",
    maxCount: null, // 
    maxPopoverPlacement: "top", // 
    items: [], // 
  };
  Component.register(AvatarGroup);
  /* eslint-disable no-return-assign */ /* eslint-disable no-restricted-properties */ /*
   * Tween.js
   * t: current time
   * b: beginning value
   * c: change in value
   * d: duration
   */ const Tween = {
    Linear: function (t, b, c, d) {
      return (c * t) / d + b;
    },
    Quad: {
      easeIn: function (t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      easeOut: function (t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      easeInOut: function (t, b, c, d) {
        if ((t /= d / 2) < 1) return (c / 2) * t * t + b;
        return (-c / 2) * (--t * (t - 2) - 1) + b;
      },
    },
    Cubic: {
      easeIn: function (t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },
      easeOut: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
      },
      easeInOut: function (t, b, c, d) {
        if ((t /= d / 2) < 1) return (c / 2) * t * t * t + b;
        return (c / 2) * ((t -= 2) * t * t + 2) + b;
      },
    },
    Quart: {
      easeIn: function (t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
      },
      easeOut: function (t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
      },
      easeInOut: function (t, b, c, d) {
        if ((t /= d / 2) < 1) return (c / 2) * t * t * t * t + b;
        return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;
      },
    },
    Quint: {
      easeIn: function (t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      easeOut: function (t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      easeInOut: function (t, b, c, d) {
        if ((t /= d / 2) < 1) return (c / 2) * t * t * t * t * t + b;
        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
      },
    },
    Sine: {
      easeIn: function (t, b, c, d) {
        return -c * Math.cos((t / d) * (Math.PI / 2)) + c + b;
      },
      easeOut: function (t, b, c, d) {
        return c * Math.sin((t / d) * (Math.PI / 2)) + b;
      },
      easeInOut: function (t, b, c, d) {
        return (-c / 2) * (Math.cos((Math.PI * t) / d) - 1) + b;
      },
    },
    Expo: {
      easeIn: function (t, b, c, d) {
        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
      },
      easeOut: function (t, b, c, d) {
        return t === d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b;
      },
      easeInOut: function (t, b, c, d) {
        if (t === 0) return b;
        if (t === d) return b + c;
        if ((t /= d / 2) < 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;
        return (c / 2) * (-Math.pow(2, -10 * --t) + 2) + b;
      },
    },
    Circ: {
      easeIn: function (t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
      },
      easeOut: function (t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
      },
      easeInOut: function (t, b, c, d) {
        if ((t /= d / 2) < 1) return (-c / 2) * (Math.sqrt(1 - t * t) - 1) + b;
        return (c / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
      },
    },
    Elastic: {
      easeIn: function (t, b, c, d, a, p) {
        let s;
        if (t === 0) return b;
        if ((t /= d) === 1) return b + c;
        if (typeof p === "undefined") p = d * 0.3;
        if (!a || a < Math.abs(c)) {
          s = p / 4;
          a = c;
        } else {
          s = (p / (2 * Math.PI)) * Math.asin(c / a);
        }
        return (
          -(
            a *
            Math.pow(2, 10 * (t -= 1)) *
            Math.sin(((t * d - s) * (2 * Math.PI)) / p)
          ) + b
        );
      },
      easeOut: function (t, b, c, d, a, p) {
        let s;
        if (t === 0) return b;
        if ((t /= d) === 1) return b + c;
        if (typeof p === "undefined") p = d * 0.3;
        if (!a || a < Math.abs(c)) {
          a = c;
          s = p / 4;
        } else {
          s = (p / (2 * Math.PI)) * Math.asin(c / a);
        }
        return (
          a *
            Math.pow(2, -10 * t) *
            Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
          c +
          b
        );
      },
      easeInOut: function (t, b, c, d, a, p) {
        let s;
        if (t === 0) return b;
        if ((t /= d / 2) === 2) return b + c;
        if (typeof p === "undefined") p = d * (0.3 * 1.5);
        if (!a || a < Math.abs(c)) {
          a = c;
          s = p / 4;
        } else {
          s = (p / (2 * Math.PI)) * Math.asin(c / a);
        }
        if (t < 1)
          return (
            -0.5 *
              (a *
                Math.pow(2, 10 * (t -= 1)) *
                Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +
            b
          );
        return (
          a *
            Math.pow(2, -10 * (t -= 1)) *
            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *
            0.5 +
          c +
          b
        );
      },
    },
    Back: {
      easeIn: function (t, b, c, d, s) {
        if (typeof s === "undefined") s = 1.70158;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      easeOut: function (t, b, c, d, s) {
        if (typeof s === "undefined") s = 1.70158;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      easeInOut: function (t, b, c, d, s) {
        if (typeof s === "undefined") s = 1.70158;
        if ((t /= d / 2) < 1)
          return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      },
    },
    Bounce: {
      easeIn: function (t, b, c, d) {
        return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;
      },
      easeOut: function (t, b, c, d) {
        if ((t /= d) < 1 / 2.75) {
          return c * (7.5625 * t * t) + b;
        }
        if (t < 2 / 2.75) {
          return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
        }
        if (t < 2.5 / 2.75) {
          return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
        }
        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      },
      easeInOut: function (t, b, c, d) {
        if (t < d / 2) {
          return Tween.Bounce.easeIn(t * 2, 0, c, d) * 0.5 + b;
        }
        return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
      },
    },
  };
  class BackTop extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(BackTop.defaults, props), ...mixins);
    }
    _created() {
      const { parent, target } = this.props;
      if (target === "window") {
        this.parentNode = document.documentElement || document.body;
        this.bindEle = window;
      } else if (this.hasClass(parent.element, target)) {
        this.parentNode = parent.element;
        this.bindEle = this.parentNode;
      } else {
        this.parentNode = parent.element.getElementsByClassName(target)[0];
        this.bindEle = this.parentNode;
      }
      const parentRemoveClone = parent._remove;
      parent._remove = () => {
        parentRemoveClone();
        this.remove();
      };
      this.once = true;
      this.onWindowScroll = () => {
        this.backTopFun();
      };
      this.initRequestAnimationFrame();
    }
    _config() {
      const { right, bottom } = this.props;
      this.setProps({
        children: {
          ref: (c) => {
            this.backTopRef = c;
          },
          classes: { "nom-back-top-container": true },
          attrs: { style: { right: `${right}px`, bottom: `${bottom}px` } },
          children: this.backTopButton(),
          onClick: () => {
            this.backTopEvent();
          },
        },
      });
    }
    _rendered() {
      this.bindEle.addEventListener("scroll", this.onWindowScroll);
    }
    _remove() {
      this.bindEle.removeEventListener("scroll", this.onWindowScroll);
    }
    backTopFun() {
      const { height } = this.props;
      if (this.once === true) {
        this.once = false;
        this.iconRef.update();
        if (this.bindEle === window) {
          this.parentNode.appendChild(this.backTopRef.element);
          this.backTopRef.element.style.position = "fixed";
        } else {
          this.parentNode.parentElement.style.position = "relative";
          this.parentNode.parentElement.appendChild(this.backTopRef.element);
        }
      }
      if (this.parentNode.scrollTop >= height) {
        this.backTopRef.show();
      } else {
        this.backTopRef.hide();
      }
    }
    hasClass(ele, className) {
      const reg = new RegExp(`(^|\\s)${className}(\\s|$)`);
      return reg.test(ele.className);
    }
    backTopButton() {
      const { text } = this.props;
      let obj;
      if (text.length > 0) {
        obj = {
          ref: (c) => {
            this.iconRef = c;
          },
          classes: { "nom-back-top-text": true },
          autoRender: false,
          children: text,
        };
      } else {
        obj = {
          ref: (c) => {
            this.iconRef = c;
          },
          classes: { "nom-back-top-icons": true },
          autoRender: false,
          component: "Icon",
          type: "up",
        };
      }
      return obj;
    }
    initRequestAnimationFrame() {
      let lastTime = 0;
      const vendors = ["webkit", "moz"];
      for (
        let x = 0;
        x < vendors.length && !window.requestAnimationFrame;
        ++x
      ) {
        window.requestAnimationFrame =
          window[`${vendors[x]}RequestAnimationFrame`];
        window.cancelAnimationFrame =
          window[`${vendors[x]}CancelAnimationFrame`] ||
          window[`${vendors[x]}CancelRequestAnimationFrame`];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback) {
          const currTime = new Date().getTime();
          const timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
          const id = window.setTimeout(function () {
            callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
          clearTimeout(id);
        };
      }
    }
    backTopEvent() {
      const { animations, duration } = this.props;
      const element = this.parentNode;
      let start = 0;
      const begin = element.scrollTop;
      const end = -element.scrollTop;
      const during = Math.round((duration * 10) / 167);
      const paramArry = animations.split(".");
      const scrollAnimation = function () {
        if (element.scrollTop === 0) return false;
        let top; // 
        if (paramArry[1]) {
          top = Tween[paramArry[0]][paramArry[1]](start, begin, end, during);
        } else {
          top = Tween[paramArry[0]](start, begin, end, during);
        }
        element.scrollTop = top; // 
        start++; // 
        if (start <= during && element.scrollTop !== 0) {
          requestAnimationFrame(scrollAnimation);
        }
      };
      if (element) scrollAnimation();
    }
  }
  Component.mixin({
    _rendered: function () {
      if (this.props.backtop) {
        this.backtop = new BackTop(
          Component.extendProps({}, this.props.backtop, { parent: this })
        );
      }
    },
  });
  BackTop.defaults = {
    duration: 100,
    animations: "Linear",
    target: "window",
    height: 400,
    right: 30,
    bottom: 30,
    text: "",
    parent: "",
    onClick: () => {},
  };
  Component.register(BackTop);
  class Badge extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Badge.defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = ["size", "color"];
      const { icon, text, type, overflowCount } = this.props;
      const number = this.props.number;
      if (icon) {
        this.setProps({ classes: { "p-with-icon": true } });
      }
      if (type === "round") {
        this.setProps({ classes: { "u-shape-round": true } });
      } else if (type === "dot") {
        if (number > 0) {
          this.setProps({ classes: { "p-with-number": true } });
        }
      } else if (type === "tag") {
        this.setProps({ classes: { "u-shape-tag": true } });
      }
      this.setProps({
        classes: { "nom-badge-pointer": !!this.props.onClick },
        children: [
          Component.normalizeIconProps(icon),
          { tag: "span", children: text },
          (number || number === 0) && {
            tag: "span",
            children: number > overflowCount ? `${overflowCount}+` : number,
          },
        ],
      });
    }
    _disable() {
      this.element.setAttribute("disabled", "disabled");
    }
  }
  Component.mixin({
    _config: function () {
      if (this.props.badge) {
        this.setProps({ classes: { "s-with-badge": true } });
      }
    },
    _rendered: function () {
      if (this.props.badge) {
        const badgeProps = { type: "dot" };
        if (this.props.badge.text) {
          badgeProps.text = this.props.badge.text;
          badgeProps.type = "tag";
        }
        if (
          this.props.badge.number !== undefined &&
          (this.props.badge.number === 0 || this.props.badge.number === "0")
        ) {
          badgeProps.hidden = true;
        }
        badgeProps.number = this.props.badge.number
          ? this.props.badge.number
          : null;
        badgeProps.overflowCount = this.props.badge.overflowCount
          ? this.props.badge.overflowCount
          : 99;
        badgeProps.styles = this.props.badge.styles
          ? this.props.badge.styles
          : { color: "danger" };
        this.props.badge = badgeProps;
        this.badge = new Badge(
          Component.extendProps({ reference: this }, this.props.badge)
        );
      }
    },
  });
  Badge.defaults = {
    key: null,
    tag: "span",
    type: "round",
    text: null,
    icon: null,
    number: null,
    overflowCount: 99,
    size: "sm",
  };
  Component.register(Badge);
  class BreadcrumbItem extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "span", url: null };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      // const that = this
      // const { icon, rightIcon, separator, url, text, overlay } = this.props
      const { icon, rightIcon, separator, url, text } = this.props;
      if (icon || rightIcon) {
        this.setProps({ classes: { "p-with-icon": true } });
        if (!text) {
          this.setProps({ classes: { "p-only-icon": true } });
        }
      } // if (isNotEmptyArray(overlay)) {
      //   this.setProps({
      //     popup: {
      //       triggerAction: 'hover',
      //       aligin: 'left bottom',
      //       children: {
      //         component: BreadcrumbSub,
      //         items: overlay,
      //       },
      //     },
      //   })
      // }
      this.setProps({
        children: [
          Component.normalizeIconProps(icon),
          {
            tag: "span",
            classes: { "nom-breadcrumb-link": true },
            children: url
              ? { tag: "a", attrs: { href: url }, children: text }
              : text,
          },
          Component.normalizeIconProps(rightIcon),
          {
            tag: "span",
            classes: { "nom-breadcrumb-separator": true },
            children: separator,
          },
        ],
      });
    }
  }
  Component.register(BreadcrumbItem);
  class Breadcrumb extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Breadcrumb.defaults, props), mixins);
    }
    _config() {
      const { separator, items, itemDefaults } = this.props;
      const children = isNotEmptyArray(items)
        ? items.map((item, idx) => {
            const isLeaf = idx === items.length - 1;
            return Object.assign(
              {},
              Component.extendProps({ separator, isLeaf }, itemDefaults, item)
            );
          })
        : [];
      this.setProps({ children });
    }
  }
  Breadcrumb.defaults = {
    separator: "/",
    itemDefaults: { component: BreadcrumbItem },
  };
  Component.register(Breadcrumb);
  class Carousel extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Carousel.defaults, props), ...mixins);
    }
    _config() {
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
      }
      this.dotsRef = [];
      this.positions = [];
      this.slideWidth = null;
      this.autoplayInterval = null;
      this.sildeRefs = [];
      const { defaultActiveIndex } = this.props;
      let { imgs } = this.props;
      this.origLen = imgs.length;
      if (imgs && imgs.length === 2) {
        imgs = [...imgs, ...imgs];
      }
      const cloneImgs = [...imgs];
      cloneImgs.push(imgs[0]);
      this.loopImgs = cloneImgs;
      this.activeId = defaultActiveIndex;
      this.activeIdOld = defaultActiveIndex;
      this.setProps({
        children: {
          ref: (c) => {
            this.containerRef = c;
          },
          classes: { "nom-carousel-container": true },
          children: [
            {
              ref: (c) => {
                this.wrapperRef = c;
              },
              classes: { "nom-carousel-wrapper": true },
              children: this.slideList(),
            },
            {
              ref: (c) => {
                this.paginationRef = c;
              },
              classes: {
                "nom-carousel-pagination": true,
                "nom-carousel-pagination-show": this.props.dots,
              },
              children: this.paginationList(),
            },
            {
              classes: {
                "nom-carousel-buttons": true,
                "nom-carousel-buttons-show": this.props.arrows,
              },
              children: [
                {
                  classes: { "nom-carousel-button-prev": true },
                  onClick: () => {
                    this.prevClick();
                  },
                  component: "Icon",
                  type: "prev",
                },
                {
                  classes: { "nom-carousel-button-next": true },
                  onClick: () => {
                    this.nextClick();
                  },
                  component: "Icon",
                  type: "next",
                },
              ],
            },
          ],
        },
      });
    }
    _rendered() {
      const {
        autoplay,
        pauseOnHover,
        defaultActiveIndex,
        triggerType,
      } = this.props;
      this.initPositions(); // 
      if (autoplay) {
        this.initAutoplay();
      } // 
      if (pauseOnHover) {
        this.containerRef.element.addEventListener("mouseover", () => {
          clearInterval(this.autoplayInterval);
        });
        this.containerRef.element.addEventListener("mouseout", () => {
          if (autoplay) {
            this.initAutoplay();
          }
        });
      } // 
      setTimeout(() => {
        this.paginationClick(defaultActiveIndex);
      }, 500); // 
      if (triggerType === "hover") {
        this.dotsRef.forEach((item) => {
          item.element.onmouseenter = (e) => {
            const target = e.target;
            if (target.nodeName === "SPAN") {
              this.paginationClick(target.dataset.index);
            }
          };
        });
      } else {
        this.paginationRef.element.addEventListener("click", (e) => {
          const target = e.target;
          if (target.nodeName === "SPAN") {
            this.paginationClick(target.dataset.index);
          }
        });
      } // 
      this.resizeObserver = new ResizeObserver(() => {
        this.updateSlideSize();
        const wrapper = this.wrapperRef.element;
        const pos = (idx) => -Math.round(this.positions[idx].left);
        const idx =
          this.activeId === this.loopImgs.length ? 0 : this.activeId - 1;
        wrapper.style.transform = `translate3d(${pos(idx)}px, 0, 0)`;
      });
      this.resizeObserver.observe(this.containerRef.element);
    }
    initAutoplay() {
      const { autoplay, autoplaySpeed } = this.props; // 
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
      } // 
      if (autoplay) {
        this.autoplayInterval = setInterval(() => {
          this.nextClick();
        }, autoplaySpeed);
      }
    }
    _remove() {
      clearInterval(this.autoplayInterval);
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    }
    slideList() {
      const _that = this;
      return this.loopImgs.map(function (item) {
        return {
          ref: (c) => {
            if (c) _that.sildeRefs.push(c);
          },
          classes: { "nom-carousel-slide": true },
          attrs: {
            style: {
              height: isNumeric(_that.props.height)
                ? `${_that.props.height}px`
                : _that.props.height,
            },
          },
          children: { tag: "img", attrs: { src: item }, children: "" },
        };
      });
    }
    paginationList() {
      const _that = this; //  imgs  dots
      const dotsCount = this.origLen;
      return Array.from({ length: dotsCount }, (_, index) => ({
        ref: (c) => {
          if (c) _that.dotsRef.push(c);
        },
        classes: {
          "nom-carousel-pagination-bullet": true,
          "nom-carousel-pagination-bullet-active":
            index === _that.defaultActiveIndex - 1,
        },
        tag: "span",
        attrs: { "data-index": index + 1 },
        children: index + 1,
      }));
    }
    paginationClick(index) {
      this.activeId = index;
      this.animate("pagination");
      this.initAutoplay();
    }
    prevClick() {
      this.activeId -= 1;
      if (this.activeId <= 0) {
        this.activeId = this.loopImgs.length - 1;
      }
      this.animate();
      this.initAutoplay();
    }
    nextClick() {
      this.activeId += 1;
      if (this.activeId > this.loopImgs.length) {
        this.activeId = 2;
      }
      this.animate();
      this.initAutoplay();
    }
    animate(val) {
      this.updateSlideSize();
      const wrapper = this.wrapperRef.element;
      const duration = `${this.props.speed}ms ${this.props.easing}`;
      const pos = (idx) => -Math.round(this.positions[idx].left); // 
      const to = (idx, withTransition = true) => {
        wrapper.style.transition = withTransition
          ? `transform ${duration}`
          : "none";
        wrapper.style.transform = `translate3d(${pos(idx)}px, 0, 0)`;
      }; //  or 
      if (
        this.activeId === this.loopImgs.length - 1 &&
        this.activeIdOld === 1 &&
        val !== "pagination"
      ) {
        // 
        to(this.loopImgs.length - 1, false); // 
        // eslint-disable-next-line no-void
        void wrapper.offsetWidth; // 
        to(this.loopImgs.length - 2, true);
      } else {
        to(this.activeId - 1, true);
      } // 
      const origLen = this.origLen; // 0-based
      let dotIndex = (this.activeId - 1) % origLen;
      if (dotIndex < 0) dotIndex += origLen; // 
      this.dotsRef.forEach((dot) =>
        dot.element.classList.remove("nom-carousel-pagination-bullet-active")
      ); // 
      if (this.dotsRef[dotIndex] && this.dotsRef[dotIndex].element) {
        this.dotsRef[dotIndex].element.classList.add(
          "nom-carousel-pagination-bullet-active"
        );
      } //  activeIdOld
      this.activeIdOld = this.activeId; // 
      if (this.activeId === this.loopImgs.length) {
        const onEnd = (e) => {
          if (e.target !== wrapper || e.propertyName !== "transform") return;
          wrapper.style.transition = "none";
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              wrapper.style.transform = "translate3d(0px, 0, 0)";
              requestAnimationFrame(() => {
                wrapper.style.transition = `transform ${duration}`;
              });
            });
          });
        };
        wrapper.addEventListener("transitionend", onEnd, { once: true });
      }
    } // 
    initPositions() {
      this.positions = this.loopImgs.map(() => ({ left: 0, width: 0 }));
    } // 
    updateSlideSize() {
      const nodes = this.sildeRefs;
      let firstLeft = 0;
      if (this.slideWidth === nodes[0].element.getBoundingClientRect().width)
        return;
      nodes.forEach((node, index) => {
        if (!node.rendered) return;
        const rect = node.element.getBoundingClientRect();
        this.positions[index].width = rect.width;
        if (index === 0) {
          this.positions[index].left = 0;
          firstLeft = rect.left;
          this.slideWidth = rect.width;
        } else {
          this.positions[index].left = rect.left - firstLeft;
        }
      });
    }
  }
  Carousel.defaults = {
    imgs: [],
    height: 100,
    arrows: false,
    autoplay: false,
    autoplaySpeed: 3000,
    speed: 500,
    resetDelayCompensation: 50,
    dots: true,
    defaultActiveIndex: 1,
    easing: "linear",
    pauseOnHover: false,
    triggerType: "click",
  };
  Component.register(Carousel);
  class CascaderInput extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "input",
        attrs: { type: "text", autocomplete: "off" },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.capsLock = false;
    }
    _config() {
      this.setProps({
        attrs: Object.assign({}, this.props.attrs, {
          value: this.props.value,
          placeholder: this.props.placeholder,
          oninput: () => {
            this._callHandler(this.props.onInput, { text: this.getText() });
          },
          onblur: () => {
            this._callHandler(this.props.onBlur, { text: this.getText() });
          },
          onfocus: () => {
            this._callHandler(this.props.onFocus);
          },
        }),
      });
    }
    _rendered() {
      if (this.props.autofocus === true) {
        this.focus();
      }
    }
    getText() {
      return this.element.value;
    }
    setPlaceholder(text) {
      this.element.setAttribute("placeholder", text);
    }
    setText(text) {
      this.element.value = text;
    }
    clear() {
      this.element.value = "";
      this.element.setAttribute("placeholder", this.props.placeholder);
    }
    focus() {
      this.element.focus();
    }
    blur() {
      this.element.blur();
    }
    disable() {
      this.element.setAttribute("disabled", "disabled");
    }
    enable() {
      this.element.removeAttribute("disabled", "disabled");
    }
  }
  class CascaderList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        classes: { "nom-cascader-option-wrapper": true },
        itemRender: ({ itemData }) => {
          return {
            component: "List",
            classes: { "nom-cascader-option-list": true },
            ref: (c) => {
              this.listRefs[itemData.level] = c;
            },
            attrs: {
              style: {
                width: isString(this.cascaderControl.props.width)
                  ? this.cascaderControl.props.width
                  : `${this.cascaderControl.props.width}px`,
                height: isString(this.cascaderControl.props.height)
                  ? this.cascaderControl.props.height
                  : `${this.cascaderControl.props.height}px`,
              },
            },
            items: itemData.items,
            level: itemData.level,
            cols: 1,
            itemDefaults: {
              key: function () {
                return this.props.value;
              },
              onConfig: ({ inst }) => {
                const arr = [
                  {
                    grow: true,
                    children: { component: "Ellipsis", text: inst.props.label },
                  },
                  {
                    component: "Icon",
                    type: "right",
                    ref: (c) => {
                      inst.iconRef = c;
                    },
                    hidden:
                      inst.props.isLeaf !== false &&
                      (!!inst.props.isLeaf || !inst.props.hasChildren),
                  },
                ];
                if (this.cascaderControl.props.multiple) {
                  arr.unshift({
                    classes: { "nom-cascader-option-checker": true },
                    children: {
                      component: "Checkbox",
                      compact: true,
                      ref: (c) => {
                        inst.checkerRef = c;
                      },
                      itemKey: inst.props.value,
                      animate: false,
                      hidden:
                        this.cascaderControl.props.onlyleaf &&
                        (inst.props.isLeaf === false || inst.props.hasChildren),
                      value: this._isNodeChecked(inst.props.value),
                      onClick: ({ event }) => {
                        event.stopPropagation();
                      },
                      onValueChange: ({ newValue }) => {
                        this._handleNodeCheck({
                          item: inst,
                          level: parseInt(itemData.level, 10),
                          newValue,
                        });
                      },
                    },
                  });
                }
                inst.setProps({
                  onClick: () => {
                    !inst.props.disabled &&
                      this._handleItemSelect({
                        item: inst,
                        level: parseInt(itemData.level, 10),
                      });
                  },
                  children: { component: "Flex", align: "center", cols: arr },
                });
              },
            },
            itemSelectable: { byClick: true, scrollIntoView: true },
            onItemSelectionChange: ({ selectedItem }) => {
              this._drawNextLevel({
                level: itemData.level,
                value: selectedItem.props.value,
                item: selectedItem,
              }); // valueMap
              this.tempValueMap[parseInt(itemData.level, 10)] = {
                value: selectedItem.props.value,
                text: selectedItem.props.label,
              };
            },
            onRendered: ({ inst }) => {
              if (this.cascaderControl && !!this.cascaderControl.props.value) {
                if (this.cascaderControl.props.multiple) {
                  for (
                    let i = 0;
                    i < this.cascaderControl.multiValueMap.length;
                    i++
                  ) {
                    const item = this.cascaderControl.multiValueMap[i];
                    if (inst.getItem(item.value)) {
                      inst.selectItem(item.value);
                      break;
                    }
                  }
                } else {
                  for (const k in this.cascaderControl.valueMap) {
                    if (parseInt(k, 10) === parseInt(itemData.level, 10)) {
                      inst.selectItem(this.cascaderControl.valueMap[k].value);
                    }
                  }
                }
              }
            },
          };
        },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.listRefs = {};
      this.cascaderControl = this.parent.parent.parent.cascaderControl;
      this.cascaderControl.optionList = this;
    }
    _rendered() {
      if (!this.props.data || !this.props.data.length) {
        this.cascaderControl.emptyRef.show();
      } else {
        this.cascaderControl.emptyRef.hide();
      }
    }
    _drawLists() {
      this.tempValueMap = {};
      const { cascaderControl } = this;
      const { options, fieldsMapping } = cascaderControl.props;
      if (!options || !options.length) {
        this._drawNextLevel({ level: "0", value: "" });
        return;
      }
      const firstCol = {
        items: options.map((x) => {
          return {
            label: x[fieldsMapping.label],
            value: x[fieldsMapping.value],
            disabled: x[fieldsMapping.disabled],
            hasChildren:
              x[fieldsMapping.children] && x[fieldsMapping.children].length > 0,
            isLeaf: x[fieldsMapping.isLeaf],
            itemData: x,
          };
        }),
        level: "0",
        key: "0",
      };
      this.update({ data: [firstCol] });
    }
    _drawNextLevel({ value, level, item }) {
      const { cascaderControl } = this;
      const { fieldsMapping } = cascaderControl.props;
      const allItems = this.getAllItems().map((x) => {
        return x.key;
      });
      this.removeItems(
        allItems.filter((x) => parseInt(x, 10) > parseInt(level, 10))
      );
      if (cascaderControl.props.loadData) {
        if (item && item.iconRef) {
          item.iconRef.update({ type: "loading" });
        }
        cascaderControl.props
          .loadData({ value, level, itemData: item ? item.props.itemData : {} })
          .then((options) => {
            if (item && item.iconRef) {
              item.iconRef.update({ type: "right" });
            }
            if (!options || !options.length) {
              return;
            }
            this.cascaderControl.emptyRef.hide();
            this.appendDataItem({
              items: options.map((x) => {
                return {
                  label: x[fieldsMapping.label],
                  value: x[fieldsMapping.value],
                  disabled: x[fieldsMapping.disabled],
                  hasChildren:
                    x[fieldsMapping.children] &&
                    x[fieldsMapping.children].length > 0,
                  isLeaf: x[fieldsMapping.isLeaf],
                  itemData: x,
                };
              }),
              level: `${parseInt(level, 10) + 1}`,
              key: `${parseInt(level, 10) + 1}`,
            });
          });
      } else {
        const arr = this._getNextLevelItems({ value, level });
        if (arr.length) {
          this.cascaderControl.emptyRef.hide();
          this.appendDataItem({
            items: arr,
            level: `${parseInt(level, 10) + 1}`,
            key: `${parseInt(level, 10) + 1}`,
          });
        }
      }
      this.cascaderControl.popup.setPosition();
    }
    _getNextLevelItems({ value, level }) {
      const arr = [];
      const { cascaderControl } = this;
      cascaderControl.items.forEach((x) => {
        if (parseInt(level, 10) + 1 === x.level && x.pid === value) {
          arr.push(x);
        }
      });
      return arr;
    } // 
    _handleItemSelect({ item, level }) {
      const isLeaf = item.props.isLeaf !== false && !item.props.hasChildren;
      const { cascaderControl } = this;
      const { changeOnSelect, multiple } = cascaderControl.props; // value text
      this.tempValueMap[level] = {
        value: item.props.value,
        text: item.props.label,
      }; // 
      for (let i = level + 1; i < 20; i++) {
        delete this.tempValueMap[i];
      }
      if (multiple) {
        return;
      }
      if (isLeaf || changeOnSelect) {
        cascaderControl.valueMap = this.tempValueMap;
        cascaderControl._onValueChange();
      }
      if (isLeaf && !cascaderControl.props.multiple) {
        cascaderControl.popup.animateHide();
      }
    }
    _isNodeChecked(val) {
      return this.cascaderControl.multiValueMap.some((x) => x.value === val);
    }
    _handleNodeCheck({ item, newValue, level }) {
      this.cascaderControl._onNodeCheckChange({ item, newValue });
      if (this.cascaderControl.props.multiple.cascade) {
        this.cascaderControl._processCascade({ item, newValue, level });
        this._refreshCurrentLists();
      }
    }
    _refreshCurrentLists() {
      for (const i in this.listRefs) {
        const list = this.listRefs[i];
        list.getAllItems().forEach((x) => {
          x.checkerRef.update({
            value: this._isNodeChecked(x.checkerRef.props.itemKey),
          });
        });
      }
    }
  }
  class CascaderPopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = { animate: true };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.cascaderControl = this.opener.field;
    }
    _config() {
      const { cascaderControl } = this;
      this.setProps({
        children: {
          classes: { "nom-cascader-pop-container": true },
          component: Layout,
          fit: true,
          body: {
            children: [
              {
                ref: (c) => {
                  cascaderControl.emptyRef = c;
                },
                classes: { "nom-cascader-empty": true },
                hidden: true,
                component: Layout,
                body: { children: { component: "Empty" } },
              },
              { component: CascaderList },
              {
                component: "List",
                classes: { "nom-cascader-search-option-list": true },
                ref: (c) => {
                  cascaderControl.searchOptionList = c;
                },
                hidden: true,
                cols: 1,
                itemDefaults: {
                  onConfig: ({ inst }) => {
                    const fullText = inst.props.label.join(
                      cascaderControl.props.separator
                    );
                    const searchText = cascaderControl._currentSearchText || "";
                    const childrenArray = [];
                    if (
                      searchText &&
                      fullText.toLowerCase().includes(searchText.toLowerCase())
                    ) {
                      const index = fullText.indexOf(searchText);
                      const before = fullText.slice(0, index);
                      const match = fullText.slice(
                        index,
                        index + searchText.length
                      );
                      const after = fullText.slice(index + searchText.length);
                      if (before) {
                        childrenArray.push({ tag: "span", children: before });
                      }
                      if (match) {
                        childrenArray.push({
                          tag: "span",
                          children: match,
                          classes: { "nom-cascader-highlight": true },
                        });
                      }
                      if (after) {
                        childrenArray.push({ tag: "span", children: after });
                      }
                    } else {
                      childrenArray.push({ tag: "span", children: fullText });
                    }
                    inst.setProps({
                      children: {
                        classes: { "s-disable1d": !!inst.props.disabled },
                        children: childrenArray,
                        onClick: () => {
                          if (inst.props.disabled) {
                            return;
                          }
                          const { label, value } = inst.props;
                          cascaderControl.onSearchItemClick({ label, value });
                        },
                      },
                    });
                  },
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _rendered() {
      this.removeClass("nom-layer-animate-show");
      this.cascaderControl.props.animate &&
        this.props.animate &&
        this.animateInit();
    }
    animateInit() {
      if (!this.element) return false;
      if (this.element.getAttribute("offset-y") !== "0") {
        this.addClass("nom-cascader-animate-bottom-show");
      } else {
        this.addClass("nom-cascader-animate-top-show");
      }
    }
    animateHide() {
      if (!this.element) return false;
      let animateName;
      if (this.element.getAttribute("offset-y") !== "0") {
        animateName = "nom-cascader-animate-bottom";
      } else {
        animateName = "nom-cascader-animate-top";
      }
      this.addClass(`${animateName}-hide`);
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
        this.removeClass(`${animateName}-hide`);
        this.addClass(`${animateName}-show`);
      }, 160);
    }
  }
  Component.register(CascaderPopup);
  class Cascader extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Cascader.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.valueMap = {};
      this.multiValueMap = [];
    }
    _config() {
      const me = this;
      const children = [];
      const {
        showArrow,
        placeholder,
        allowClear,
        multiple,
        searchable,
      } = this.props;
      const { value, options, disabled } = this.props;
      this.initValue = clone(value);
      this.internalOption = JSON.parse(JSON.stringify(options));
      this._flatItems();
      if (this.props.onlyleaf && !this.props.multiple) {
        this.props.changeOnSelect = false;
      }
      if (value && value.length) {
        this.valueMap = {};
        this.multiValueMap = [];
        this._setValueMap();
      }
      this.currentValue = this.initValue;
      const showInput = !multiple && searchable;
      children.push({
        classes: { "nom-cascader-content": true },
        ref: (c) => {
          me._content = c;
        },
        hidden: showInput,
        children: multiple ? this._getMultipleText() : this.getValueText(),
      });
      if (showInput) {
        children.push({
          component: CascaderInput,
          _created: function () {
            me.inputRef = this;
            this.cascader = me;
          },
          attrs: { value: this.getValueText() },
          placeholder,
          onFocus: ({ sender }) => {
            sender.setText("");
            sender.setPlaceholder(me.getValueText());
          },
          onInput: ({ text }) => {
            this._handleSearch(text || "");
          },
        });
      } else if (isString(placeholder)) {
        children.push({
          _created() {
            me.placeholder = this;
          },
          classes: { "nom-cascader-placeholder": true },
          children: placeholder,
          value: multiple ? this._getMultipleText() : this.getValueText,
          hidden: !!this.props.value,
        });
      }
      if (showArrow) {
        children.push({
          component: Icon,
          type: "down",
          classes: { "nom-cascader-icon": true },
          _created() {
            me.down = this;
          },
        });
      }
      if (allowClear) {
        children.push({
          component: Icon,
          type: "times",
          classes: { "nom-cascader-icon": true },
          hidden: true,
          _created() {
            me.close = this;
          },
          onClick: ({ event }) => {
            event.stopPropagation();
            me.props.onClear && me._callHandler(me.props.onClear);
            me.inputRef && me.inputRef.clear();
            me.setValue(null);
          },
        });
      }
      this.setProps({
        control: { children, disabled },
        attrs: {
          onmouseover() {
            if (disabled) return;
            me.close && me.close.show();
            showArrow && me.down.hide();
          },
          onmouseleave() {
            if (disabled) return;
            showArrow && me.down.show();
            me.close && me.close.hide();
          },
        },
      });
      super._config();
    }
    _rendered() {
      if (this.props.value && this.props.value.length && this.props.loadData) {
        this._loopLoadValueData();
      }
      this.popup = new CascaderPopup({
        trigger: this.control,
        onShow: () => {
          this.optionList && this._drawOptionLists();
          if (this.props.multiple) {
            this._lastShowValue = this.getValue();
          }
        },
        onHide: () => {
          if (this._showingSearch) {
            this._showingSearch = false;
            this.optionList && this.optionList.show();
            this.searchOptionList && this.searchOptionList.hide();
          }
          if (this.props.changeOnClose && this.props.multiple) {
            const _currentValue = this.getValue();
            if (!deepEqual(_currentValue, this._lastShowValue)) {
              this._onValueChange();
            }
          }
          if (this.props.value && this.inputRef) {
            this.inputRef.setText(this.getValueText());
          }
        },
      });
    }
    _handleSearch(text) {
      this._currentSearchText = text;
      if (text.length) {
        this._showingSearch = true;
        this.popup.show();
        this.optionList.hide();
        this.searchOptionList.show();
        this.searchOptionList.update({ items: this._getFilterOptions(text) });
      } else {
        this.popup.show();
        this.optionList.show();
        this.searchOptionList.hide();
        this.searchOptionList.update({ items: [] });
      }
    }
    onSearchItemClick(item) {
      this._showingSearch = false;
      this.popup.hide();
      this.optionList.show();
      this.searchOptionList.hide();
      this.searchOptionList.update({ items: [] });
      this.setValue(item.value);
    }
    _getFilterOptions(text) {
      const { fieldsMapping } = this.props;
      const result = []; // 
      function search(node, parentPath) {
        const currentPath = [...parentPath, node];
        const label = node[fieldsMapping.label]; // 
        if (label && label.toLowerCase().includes(text.toLowerCase())) {
          //  text  value
          const textPath = currentPath.map((item) => item[fieldsMapping.label]);
          const valuePath = currentPath.map(
            (item) => item[fieldsMapping.value]
          ); //  disabled
          const isDisabled = currentPath.some(
            (item) => item[fieldsMapping.disabled]
          );
          result.push({
            label: textPath,
            value: valuePath,
            disabled: isDisabled,
          });
        } //  children
        if (
          Array.isArray(node[fieldsMapping.children]) &&
          node[fieldsMapping.children].length
        ) {
          node[fieldsMapping.children].forEach((child) => {
            search(child, currentPath);
          });
        }
      } // 
      this.internalOption.forEach((rootNode) => {
        search(rootNode, []);
      });
      return result;
    } // value
    _loopLoadValueData() {
      const me = this;
      let { value } = this.props;
      const { fieldsMapping, multiple } = this.props;
      if (!Array.isArray(value)) {
        value = [value];
      }
      value.unshift("");
      const promises = value.map((v, i) =>
        this.props.loadData({
          value: i === 0 ? null : v,
          itemData: i === 0 ? {} : { [fieldsMapping.value]: v },
          level: `${i}`,
        })
      );
      Promise.all(promises)
        .then((results) => {
          results.forEach((res) => {
            if (res?.length) {
              me._flatItems(res);
            }
          });
          me._setValueMap();
          me._content.update({
            children: multiple ? me._getMultipleText() : me.getValueText(),
          });
          me.inputRef && me.inputRef.setText(me.getValueText());
        })
        .catch((error) => {
          console.error("load data failed:", error);
        });
    }
    _drawOptionLists() {
      this.optionList._drawLists();
    }
    _setValueMap() {
      let { value } = this.props;
      if (isNullish(value)) {
        return;
      }
      if (isString(value)) {
        value = this._getCascadeValue(value);
      }
      if (!Array.isArray(value)) {
        value = [value];
      }
      value.forEach((n, i) => {
        const item = this.items.find((x) => x.value === n);
        if (item) {
          if (this.props.multiple) {
            this.multiValueMap.push({ value: item.value, text: item.label });
          } else {
            this.valueMap[i] = { value: item.value, text: item.label };
          }
        }
      });
    }
    _getCascadeValue(val) {
      const me = this;
      const arr = [];
      function getParentNodeValue(id) {
        for (let i = 0; i < me.items.length; i++) {
          const item = me.items[i];
          if (id === item.value) {
            arr.unshift(item.value);
            getParentNodeValue(item.pid);
            break;
          }
        }
      }
      getParentNodeValue(val);
      return arr;
    }
    _flatItems(source) {
      if (!source) {
        this.items = [];
        source = this.internalOption;
      }
      const { fieldsMapping } = this.props;
      const findTree = (data, pid = null, level = 0) => {
        data.forEach((n) => {
          const hasChildren =
            n[fieldsMapping.children] && n[fieldsMapping.children].length;
          if (
            this.items.filter((x) => {
              return x.value === n[fieldsMapping.value] && x.pid === pid;
            }).length === 0
          ) {
            this.items.push({
              level: level,
              label: n[fieldsMapping.label],
              value: n[fieldsMapping.value],
              pid: pid,
              disabled: n[fieldsMapping.disabled],
              hasChildren,
              itemData: n,
            });
          }
          if (hasChildren) {
            findTree(
              n[fieldsMapping.children],
              n[fieldsMapping.value],
              level + 1
            );
          }
        });
      };
      findTree(source);
    }
    _getValue() {
      let v = [];
      if (this.props.multiple) {
        v = this.multiValueMap.map((x) => x.value);
      } else {
        for (const k in this.valueMap) {
          v.push(this.valueMap[k].value);
        }
      }
      if (this.props.valueType === "cascade") {
        return v.length ? v : null;
      }
      return v.length ? v[v.length - 1] : null;
    }
    _getValueText() {
      const t = [];
      if (this.props.multiple) {
        if (!this.multiValueMap.length) {
          return "";
        }
        const arr = this.multiValueMap.map((n) => {
          return n.text;
        });
        return arr.join(",");
      }
      for (const k in this.valueMap) {
        t.push(this.valueMap[k].text);
      }
      if (!this.props.singleShowFullPath) {
        return t.length ? t[t.length - 1] : "";
      }
      return t.length ? t.join(this.props.separator) : "";
    }
    _getMultipleText() {
      if (!this.multiValueMap.length) {
        return "";
      }
      let data = this.multiValueMap;
      const hasOverTag =
        this.props.maxTagCount > 0 &&
        this.multiValueMap.length > this.props.maxTagCount;
      if (hasOverTag) {
        const overTags = this.multiValueMap.slice(
          this.props.maxTagCount,
          this.multiValueMap.length
        );
        const num = this.multiValueMap.length - this.props.maxTagCount;
        data = this.multiValueMap.slice(0, this.props.maxTagCount);
        data.push({ isOverCount: true, overList: overTags, overNum: num });
      }
      return {
        component: "List",
        classes: { "nom-cascader-multiple-content-list": true },
        data: data,
        itemRender: ({ itemData }) => {
          if (itemData.isOverCount) {
            return {
              classes: { "nom-cascader-over-tags-trigger": true },
              children: `+${itemData.overNum}`,
              popup: {
                triggerAction: "hover",
                align: "top left",
                children: {
                  component: "List",
                  classes: { "nom-cascader-over-tags-list": true },
                  items: itemData.overList,
                  itemDefaults: {
                    onConfig: ({ inst }) => {
                      inst.setProps({ children: inst.props.text });
                    },
                  },
                },
              },
            };
          }
          return {
            classes: { "nom-cascader-multiple-content-list-text": true },
            onClick: ({ event }) => {
              event.stopPropagation();
            },
            children: [
              { attrs: { title: itemData.text }, children: itemData.text },
              {
                component: "Icon",
                type: "times",
                onClick: () => {
                  this._removeItem(itemData.value);
                },
              },
            ],
          };
        },
      };
    }
    _removeItem(value) {
      this.multiValueMap = this.multiValueMap.filter((x) => x.value !== value);
      this._onValueChange();
    }
    _onNodeCheckChange({ item, newValue }) {
      if (newValue === true) {
        if (!this.multiValueMap.some((x) => x.value === item.props.value)) {
          this.multiValueMap.push({
            value: item.props.value,
            text: item.props.label,
          });
        }
      } else {
        this.multiValueMap = this.multiValueMap.filter(
          (x) => x.value !== item.props.value
        );
      }
      !this.props.changeOnClose && this._onValueChange();
    }
    _setValue(value) {
      if (!value) {
        if (this._content) {
          this._content.element.innerText = "";
        }
        this.inputRef && this.inputRef.clear();
      }
      this.props.value = value;
      this.valueMap = {};
      this.multiValueMap = [];
      this._setValueMap();
      this._onValueChange();
    }
    _reset() {
      this.setValue(this.initValue);
    }
    _clear() {
      this.setValue(null);
    }
    _processCascade({ item, newValue, level }) {
      if (newValue === true) {
        this._cascadeCheckChildren(item.key, level);
        this._cascadeCheckParent(item.key, level);
      } else {
        this._cascadeUncheckChildren(item.key, level);
        this._cascadeUncheckParent(item.key, level);
      }
      this._onValueChange();
    }
    _cascadeCheckChildren(key, level) {
      const children = this.items.filter(
        (n) => n.pid === key && n.level === level + 1
      );
      children.forEach((child) => {
        if (!this.multiValueMap.some((x) => x.value === child.value)) {
          this.multiValueMap.push({ text: child.label, value: child.value });
        } // 
        this._cascadeCheckChildren(child.value, child.level);
      });
    }
    _cascadeUncheckChildren(key, level) {
      const children = this.items.filter(
        (n) => n.pid === key && n.level === level + 1
      );
      children.forEach((child) => {
        const index = this.multiValueMap.findIndex(
          (x) => x.value === child.value
        );
        if (index !== -1) {
          this.multiValueMap.splice(index, 1);
        } // 
        this._cascadeUncheckChildren(child.value, child.level);
      });
    }
    _cascadeCheckParent(key, level) {
      if (level === 0) return; // 
      const currentItem = this.items.find((x) => x.value === key);
      if (!currentItem) return;
      const parentItem = this.items.find((x) => x.value === currentItem.pid);
      if (!parentItem) return;
      const siblings = this.items.filter(
        (x) => x.pid === parentItem.value && x.level === level
      );
      const allSiblingsChecked = siblings.every((sibling) =>
        this.multiValueMap.some((x) => x.value === sibling.value)
      );
      if (allSiblingsChecked) {
        if (!this.multiValueMap.some((x) => x.value === parentItem.value)) {
          this.multiValueMap.push({
            text: parentItem.label,
            value: parentItem.value,
          });
        } // 
        this._cascadeCheckParent(parentItem.value, parentItem.level);
      }
    }
    _cascadeUncheckParent(key, level) {
      if (level === 0) return; // 
      const currentItem = this.items.find((x) => x.value === key);
      if (!currentItem) return;
      const parentItem = this.items.find((x) => x.value === currentItem.pid);
      if (!parentItem) return;
      const siblings = this.items.filter(
        (x) => x.pid === parentItem.value && x.level === level
      );
      const allSiblingsUnchecked = siblings.every(
        (sibling) => !this.multiValueMap.some((x) => x.value === sibling.value)
      );
      if (allSiblingsUnchecked) {
        const index = this.multiValueMap.findIndex(
          (x) => x.value === parentItem.value
        );
        if (index !== -1) {
          this.multiValueMap.splice(index, 1);
        } // 
        this._cascadeUncheckParent(parentItem.value, parentItem.level);
      }
    }
    _onValueChange() {
      const that = this;
      this.oldValue = clone(this.currentValue);
      this.currentValue = clone(this.getValue());
      this.props.value = this.currentValue;
      if (this._getValueText().length) {
        if (this.props.multiple) {
          this._content.update({ children: this._getMultipleText() });
        } else {
          this._content.element.innerText = this._getValueText();
          this.inputRef && this.inputRef.setText(this._getValueText());
        }
        this.placeholder && this.placeholder.hide();
      } else {
        if (this.props.multiple) {
          this._content.update({ children: "" });
        } else {
          this._content.element.innerText = "";
          this.inputRef && this.inputRef.clear();
        }
        this.placeholder && this.placeholder.show();
      }
      const changed = {
        name: this.props.name,
        oldValue: this.oldValue,
        newValue: this.currentValue,
        changedField: this,
      };
      setTimeout(function () {
        that._callHandler(that.props.onValueChange, changed);
        that.group &&
          that.group._onValueChange({
            changedField: changed.changedField || that,
          });
        isFunction(that._valueChange) && that._valueChange(changed);
        if (that.validateTriggered) {
          that._validate();
        }
      }, 0);
      this._triggerDependencyValueChange();
    }
    _disable() {
      if (this.firstRender === false) {
        this.control.disable();
      }
    }
    _enable() {
      if (this.firstRender === false) {
        this.control.enable();
      }
    }
  }
  Cascader.defaults = {
    options: [],
    showArrow: true,
    separator: " / ",
    fieldsMapping: {
      label: "label",
      value: "value",
      children: "children",
      disabled: "disabled",
      isLeaf: "isLeaf",
    },
    singleShowFullPath: true, // valueType  'single' 
    valueType: "cascade",
    changeOnSelect: true,
    width: 200,
    height: 250,
    disabled: false,
    allowClear: true,
    multiple: false,
    changeOnClose: false, //  onValueChange
    maxTagCount: 5,
  };
  Component.register(Cascader);
  class Checkbox extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Checkbox.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      if (!this.props.value && this.props.partChecked) {
        this.partChecked = true;
      } else {
        this.partChecked = false;
      }
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        classes: {
          "s-checked-part": !this.props.value && this.props.partChecked,
        },
        control: {
          tag: "label",
          children: [
            {
              tag: "input",
              attrs: {
                type: "checkbox",
                checked: this.props.value,
                onclick: (event) => {
                  if (that.partChecked && that.props.uncheckPart) {
                    that.setValue(false, { triggerChange: false });
                    that.partChecked = false;
                  }
                  event.stopPropagation();
                },
                onchange() {
                  that.removeClass("s-checked-part");
                  that._onValueChange();
                },
              },
              _created() {
                that.input = this;
              },
            },
            { tag: "span" }, // { tag: 'i' },
            {
              tag: "span",
              classes: {
                "checkbox-text": true,
                "checkbox-text-none": !this.props.text,
              },
              children: this.props.text || "",
            },
          ],
        },
      });
      super._config();
    }
    partCheck(triggerChange) {
      this.setValue(false, triggerChange);
      this.partChecked = true;
      this.addClass("s-checked-part");
    }
    _getValue() {
      return this.input.element.checked;
    }
    triggerEdit() {
      return false;
    }
    _getValueText() {
      if (this.getValue() === true) {
        return this.props.valueText.checked;
      }
      return this.props.valueText.unchecked;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({}, options);
      }
      this.partChecked = false;
      this.removeClass("s-checked-part");
      this.input.element.checked = value === true;
      options.triggerChange !== false && this._onValueChange();
    }
    _disable() {
      this.input.element.setAttribute("disabled", "disabled");
    }
    _enable() {
      this.input.element.removeAttribute("disabled", "disabled");
    }
  }
  Checkbox.defaults = {
    text: null,
    valueText: { checked: "", unchecked: "" },
    uncheckPart: false,
  };
  Component.register(Checkbox);
  var OptionListMixin = {
    _created: function () {
      this.checkboxList = this.parent.parent;
      this.checkboxList.optionList = this;
    },
    _config: function () {
      const { itemSelectionChange } = this.props;
      const listProps = this.checkboxList.props;
      const asArray = listProps.valueOptions.asArray;
      this.setProps({
        disabled: listProps.disabled,
        items: listProps.options,
        itemDefaults: listProps.optionDefaults,
        itemSelectable: {
          byClick: true,
          multiple: true,
          scrollIntoView: false,
        },
        selectedItems:
          asArray === true
            ? listProps.value
            : isString(listProps.value)
            ? listProps.value.split(",")
            : null,
        onItemSelectionChange: () => {
          this.checkboxList._onValueChange();
          this._callHandler(itemSelectionChange);
        },
      });
    },
  };
  class OptionList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        gutter: "x-md",
        itemDefaults: {
          tag: "label",
          _config: function () {
            this.setProps({
              selected: this.props.checked === true,
              children: [
                { tag: "span", classes: { checkbox: true } }, // { tag: 'i' },
                {
                  tag: "span",
                  classes: { text: true },
                  children: this.list.controlRef.props.itemRender
                    ? this.list.controlRef.props.itemRender({
                        itemData: this.props,
                      })
                    : this.props[props.fieldName.text],
                },
              ],
            });
          },
        },
      };
      super(Component.extendProps(defaults, props), OptionListMixin, ...mixins);
    }
  }
  class CheckboxList extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(CheckboxList.defaults, props), ...mixins);
    }
    _config() {
      const me = this;
      this.setProps({
        optionDefaults: {
          key: function () {
            return this.props[me.props.fieldName.value];
          },
        },
      });
      this.setProps({
        optionList: {
          component: OptionList,
          onCreated: ({ inst }) => {
            inst.controlRef = me;
          },
          fieldName: this.props.fieldName,
          cols: this.props.cols,
        },
      });
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: this.props.optionList,
      });
      super._config();
    }
    getSelectedOptions() {
      return this.optionList.getSelectedItems();
    }
    getUnselectedOptions() {
      return this.optionList.getUnselectedItems();
    }
    hideOption(value, alsoUnselect = true) {
      this.optionList.hideItem(value);
      if (alsoUnselect === true) {
        this.optionList.unselectItem(value);
      }
    }
    showOption(value) {
      this.optionList.showItem(value);
    }
    _getValue(options) {
      const me = this;
      const { valueOptions } = this.props;
      options = extend({ asArray: true }, valueOptions, options);
      const selected = this.getSelectedOptions();
      if (selected !== null && Array.isArray(selected) && selected.length > 0) {
        const vals = selected.map(function (item) {
          return item.props[me.props.fieldName.value];
        });
        return options.asArray ? vals : vals.join(",");
      }
      return null;
    }
    _getValueText(options, value) {
      const selected =
        value !== undefined
          ? this._getOptionsByValue(value)
          : this.getSelectedOptions();
      if (selected !== null && Array.isArray(selected) && selected.length > 0) {
        const vals = selected.map(function (item) {
          return item.props
            ? item.props[this.props.fieldName.text]
            : item[this.props.fieldName.text];
        });
        return vals;
      }
      return null;
    }
    _setValue(value, options) {
      const me = this;
      const { valueOptions } = this.props;
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, valueOptions, options);
      }
      if (value === null) {
        this.optionList.unselectAllItems({
          triggerSelectionChange: options.triggerChange,
        });
      }
      if (options.asArray === false && isString(value)) {
        value = value.split(",");
      }
      const _that = this;
      const optionsArry = [];
      this.props.options.forEach((ele) => {
        optionsArry.push(ele[me.props.fieldName.value]);
      });
      Array.isArray(value) &&
        optionsArry.forEach((item) => {
          if (value.includes(item)) {
            _that.optionList.selectItem(item, {
              triggerSelectionChange: options.triggerChange,
            });
          } else {
            _that.optionList.unselectItem(item, {
              triggerSelectionChange: options.triggerChange,
            });
          }
        });
    }
    _disable() {
      if (this.firstRender === false) {
        this.optionList.disable();
      }
    }
    _enable() {
      if (this.firstRender === false) {
        this.optionList.enable();
      }
    }
    _getOptionsByValue(value) {
      const me = this;
      let retOptions = null;
      const { options } = this.props;
      if (Array.isArray(value)) {
        retOptions = [];
        for (let i = 0; i < options.length; i++) {
          if (value.indexOf(options[i][me.props.fieldName.value]) !== -1) {
            retOptions.push(options[i]);
          }
        }
      }
      return retOptions;
    }
  }
  CheckboxList.defaults = {
    options: [],
    valueOptions: { asArray: true },
    fieldName: { text: "text", value: "value" },
    itemRender: null,
  };
  Component.register(CheckboxList);
  class TreeNodeContent extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(TreeNodeContent.defaults, props), ...mixins);
    }
    _created() {
      this.node = this.parent;
      this.node.content = this;
      this.level = this.node.level;
      this.tree = this.node.tree;
    }
    _config() {
      const me = this;
      const { text, icon, tools } = this.node.props;
      const { initExpandLevel, nodeCheckable, expandable } = this.tree.props;
      const { nodes, childrenData } = this.node.props;
      const isNotEmptyNode =
        this.node._isNotEmptyArray(nodes) ||
        this.node._isNotEmptyArray(childrenData);
      let expanded =
        (initExpandLevel === -1 || initExpandLevel > this.level) &&
        isNotEmptyNode;
      if (this.tree.expandedNodeRefs[this.node.key] !== undefined) {
        expanded = true;
      }
      const tree = this.tree;
      const indicatorProps = {
        component: Icon,
        classes: {
          "nom-tree-node-expandable-indicator": true,
          "is-leaf": this.node.isLeaf && !this.node.isLoadData,
        },
        expandable: {
          expandedProps: { type: "sort-down" },
          collapsedProps: { type: "sort-right" },
        },
      };
      if (nomui.utils.isFunction(this.tree.props.loadData) && !isNotEmptyNode) {
        indicatorProps.onClick = () => {
          this._handleLoadData();
        };
      }
      let toolProps = null;
      let isNewToolProp = false;
      if (tools) {
        if (nomui.utils.isFunction(tools)) {
          toolProps = tools({ node: this.node, tree: this.tree });
        } else if (tools.component) {
          toolProps = tools;
        } else if (tools.render) {
          isNewToolProp = true;
          const n = tools.render({
            node: this.node,
            tree: this.tree,
            nodeData: this.node.props.data,
          });
          toolProps = {
            justify: tools.justify || "start",
            items: Array.isArray(n) ? n : [n],
          };
        }
      }
      this.setProps({
        hidden: this.node.props.data.hidden,
        expanded, // byIndicator 
        expandable: extend(expandable, {
          byClick: true,
          target: () => {
            return this.node.nodesRef;
          },
          indicator: indicatorProps,
        }),
        selectable: { byClick: this.tree.props.nodeSelectable.byClick },
        selected:
          this.tree.props.nodeSelectable.selectedNodeKey === this.node.key,
        attrs: { style: { paddingLeft: `${this.level * 16}px` } },
        onSelect: () => {
          if (tree.selectedNode !== null) tree.selectedNode.unselect();
          tree.selectedNode = this.node;
          tree._onNodeSelect({
            node: this.node,
            nodeData: this.node.props.data,
          });
        },
      });
      if (
        this.tree.props.nodeSelectable.onlyleaf === true &&
        this.node.isLeaf === false
      ) {
        this.setProps({ selectable: false });
      }
      this.setProps({
        children: [
          this.tree.props.sortable &&
            this.tree.props.sortable.showHandler && {
              attrs: { style: { paddingLeft: "1rem" } },
              children: {
                component: "Icon",
                type: "swap",
                classes: { "nom-tree-drag-handler": true },
              },
            },
          this.getExpandableIndicatorProps(expanded),
          nodeCheckable && this._getCheckbox(),
          icon &&
            Component.extendProps(
              { classes: { "nom-tree-node-content-icon": true } },
              Component.normalizeIconProps(icon)
            ),
          Component.extendProps(
            {
              tag: "span",
              classes: { "nom-tree-node-content-text": true },
              created: function () {
                me.node.contentText = this;
              },
            },
            Component.normalizeTemplateProps(text)
          ),
          tools &&
            (isNewToolProp
              ? {
                  classes: {
                    "nom-tree-node-content-tools": true,
                    "nom-tree-node-content-tools-flex": true,
                    "nom-tree-node-content-tools-hover": !!tools.hover,
                  },
                  children: {
                    component: "Flex",
                    justify: toolProps.justify,
                    fit: true,
                    cols: toolProps.items,
                  },
                }
              : Component.extendProps(
                  {
                    classes: {
                      "nom-tree-node-content-tools": true,
                      "nom-tree-node-content-tools-hover": !!tools.hover,
                    },
                  },
                  toolProps
                )),
        ],
        onClick: () => {
          this.tree._onNodeClick({ node: this.node });
        },
      });
    }
    expand() {
      this.tree.expandedNodeRefs[this.node.key] = this.node;
      super.expand();
    }
    collapse() {
      delete this.tree.expandedNodeRefs[this.node.key];
      super.collapse();
    }
    _handleLoadData() {
      const r = this.tree.props.loadData({
        data: this.node.props.data,
        key: this.node.key,
        node: this.node,
      });
      if (nomui.utils.isPromiseLike(r)) {
        r.then((res) => {
          this.node.addNodes(res);
        });
      } else if (Array.isArray(r)) {
        this.node.addNodes(r);
      }
    }
    _getCheckbox() {
      const { disabled: treeDisabled, nodeCheckable } = this.tree.props;
      const { disabled: nodeDisabled, partChecked } = this.node.props;
      return {
        component: Checkbox,
        plain: true,
        classes: { "nom-tree-node-checkbox": true },
        partChecked,
        hidden: nodeCheckable && nodeCheckable.onlyleaf && !this.node.isLeaf,
        disabled: treeDisabled || nodeDisabled,
        _created: (inst) => {
          this.node.checkboxRef = inst;
        },
        onClick: ({ event }) => {
          event.stopPropagation();
        },
        value:
          this.node.props.checked === true ||
          this.tree.checkedNodeKeysHash[this.node.key] === true,
        onValueChange: ({ newValue }) => {
          if (newValue === true) {
            this.node.check({ checkCheckbox: false });
          } else {
            this.node.uncheck({ uncheckCheckbox: false });
          }
          this.node && this.node.autoCheckAll();
        },
      };
    }
  }
  TreeNodeContent.defaults = { text: null };
  Component.register(TreeNodeContent);
  class TreeNode extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(TreeNode.defaults, props), ...mixins);
    }
    _created() {
      this.level = 0;
      this.parentNode = this.parent.parentNode;
      if (this.parentNode !== null) {
        this.level = this.parentNode.level + 1;
        this.parentNode.subnodeRefs[this.key] = this;
      }
      this.tree = this.parent.tree;
      this.subnodeRefs = {};
      const { data } = this.props;
      const { dataFields } = this.tree.props;
      Object.keys(dataFields).forEach((dataField) => {
        data[dataField] = data[dataFields[dataField]];
      });
    }
    _config() {
      this.props.dataToNode({ data: this.props.data, node: this });
      if (this.props.key) {
        this.key = this.props.key;
      }
      this.tree.nodeRefs[this.key] = this;
      if (this.tree.props.nodeSelectable.selectedNodeKey === this.key) {
        this.tree.selectedNode = this;
      }
      const { nodes, childrenData } = this.props;
      const children = [{ component: TreeNodeContent }];
      this.isLeaf = !(
        this._isNotEmptyArray(nodes) || this._isNotEmptyArray(childrenData)
      );
      this.isLoadData =
        this.tree.props.loadData && this.props.data.isLeaf === false;
      if (Array.isArray(nodes) || Array.isArray(childrenData)) {
        children.push({ component: "TreeNodes", nodes, childrenData });
      }
      this.setProps({
        classes: { "filter-node": this.props.data.__filterNode },
        children,
      });
      if (this.tree.props.nodeCheckable) {
        this.setProps({
          checked: this.firstRender
            ? this.tree.checkedNodeKeysHash[this.key] === true
            : this.props.checked === true ||
              this.tree.checkedNodeKeysHash[this.key] === true,
        });
      }
    }
    _isNotEmptyArray(arr) {
      return Array.isArray(arr) && arr.length > 0;
    }
    checkChildren({ checkCheckbox = true, triggerCheckChange = true } = {}) {
      const { checked } = this.props;
      const {
        onCheckChange,
        cascadeCheckChildren,
      } = this.tree.props.nodeCheckable;
      cascadeCheckChildren === true &&
        Object.keys(this.subnodeRefs).forEach((key) => {
          this.subnodeRefs[key].checkChildren({
            checkCheckbox: true,
            triggerCheckChange: false,
          });
        });
      if (checked === true) {
        return;
      }
      if (checkCheckbox === true) {
        this.checkboxRef.setValue(true, { triggerChange: false });
      }
      this.props.checked = true;
      if (triggerCheckChange === true) {
        this._callHandler(onCheckChange);
      }
    }
    partCheck() {
      // Set the checkbox to a "partially checked" state
      this.checkboxRef.partCheck(false);
      this.props.partChecked = true;
      this.props.checked = false;
    }
    updateParentCheckState() {
      const childKeys = Object.keys(this.subnodeRefs); // 
      const allChecked = childKeys.every(
        (key) => this.subnodeRefs[key].props.checked === true
      );
      const noneChecked = childKeys.every(
        (key) =>
          this.subnodeRefs[key].props.checked === false &&
          !this.subnodeRefs[key].props.partChecked
      ); // 
      if (allChecked) {
        this.check({
          checkCheckbox: true,
          triggerCheckChange: false,
          fromChildren: true,
        });
      } else if (noneChecked) {
        this.uncheck({
          uncheckCheckbox: true,
          triggerCheckChange: false,
          skipChildren: true,
        });
      } else {
        this.partCheck();
      } // 
      if (this.parentNode) {
        this.parentNode.updateParentCheckState();
      }
    }
    check({
      checkCheckbox = true,
      triggerCheckChange = true,
      fromChildren = false,
    } = {}) {
      const { checked } = this.props;
      const {
        onCheckChange,
        cascadeCheckParent,
        cascadeCheckChildren,
        onlyleaf,
      } = this.tree.props.nodeCheckable;
      if (onlyleaf && !this.isLeaf) {
        return;
      }
      if (checked === true) {
        return;
      } // 
      if (checkCheckbox === true) {
        this.checkboxRef.setValue(true, { triggerChange: false });
      }
      this.props.checked = true;
      this.props.partChecked = false; // 
      // 
      if (!onlyleaf && cascadeCheckChildren === true && !fromChildren) {
        Object.keys(this.subnodeRefs).forEach((key) => {
          this.subnodeRefs[key].check({
            checkCheckbox: true,
            triggerCheckChange: false,
          });
        });
      } // 
      if (!onlyleaf && cascadeCheckParent === true && this.parentNode) {
        this.parentNode.updateParentCheckState();
      }
      if (triggerCheckChange === true) {
        this._callHandler(onCheckChange);
      }
    }
    uncheck({
      uncheckCheckbox = true,
      triggerCheckChange = true,
      skipChildren = false,
    } = {}) {
      const { checked } = this.props;
      const {
        onCheckChange,
        cascadeUncheckChildren,
        cascadeUncheckParent,
        onlyleaf,
      } = this.tree.props.nodeCheckable;
      if (onlyleaf && !this.isLeaf) {
        return;
      }
      if (checked === false && this.props.partChecked === false) {
        return;
      } // 
      if (uncheckCheckbox === true) {
        this.checkboxRef.setValue(false, { triggerChange: false });
      }
      this.props.checked = false;
      this.props.partChecked = false; // 
      // 
      if (!onlyleaf && cascadeUncheckChildren === true && !skipChildren) {
        Object.keys(this.subnodeRefs).forEach((key) => {
          this.subnodeRefs[key].uncheck({
            uncheckCheckbox: true,
            triggerCheckChange: false,
          });
        });
      } // 
      if (!onlyleaf && cascadeUncheckParent === true && this.parentNode) {
        this.parentNode.updateParentCheckState();
      }
      if (triggerCheckChange === true) {
        this._callHandler(onCheckChange);
      }
    }
    isChecked() {
      return this.props.checked === true;
    }
    checkNodes({ childKey }) {
      const c = Object.keys(this.subnodeRefs).filter((n) => {
        return (
          this.subnodeRefs[n].props.checked === true &&
          this.subnodeRefs[n].key !== childKey
        );
      });
      if (!c.length) {
        this.uncheck({
          uncheckCheckbox: true,
          triggerCheckChange: false,
          skipChildren: true,
        });
      }
    }
    autoCheckAll() {
      if (!this.tree.checkAllRef) return false;
      const check = Object.keys(this.tree.nodeRefs).some((nodeKey) => {
        return this.tree.nodeRefs[nodeKey].props.checked === false;
      });
      this.tree.checkAllRef.setValue(!check, { triggerChange: false });
    }
    getChildNodes() {
      return this.nodesRef ? this.nodesRef.getChildren() : [];
    }
    addNodes(param) {
      this.update({
        data: { children: [...this.props.data.children, ...param] },
      });
    }
    getData(getOptions, node) {
      getOptions = getOptions || {};
      node = node || this;
      const nodesData = [];
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        const childNodeData = Object.assign({}, childNode.props.data);
        nodesData.push(childNodeData);
        const children = this.getData(getOptions, childNode);
        if (children && children.length) {
          childNodeData.children = children;
        }
      });
      return nodesData;
    }
    select() {
      this.content.select();
    }
    unselect() {
      this.content.unselect();
    }
    disable() {
      this.update({ data: { disabled: true } });
    }
    enable() {
      this.update({ data: { disabled: false } });
    }
    hide() {
      this.update({ data: { hidden: true } });
    }
    show() {
      this.update({ data: { hidden: false } });
    }
  }
  TreeNode.defaults = { nodes: null, data: { hidden: false } };
  Component.register(TreeNode);
  class TreeNodes extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(TreeNodes.defaults, props), ...mixins);
    }
    _created() {
      if (this.parent instanceof Component.components.Tree) {
        this.tree = this.parent;
        this.tree.nodesRef = this;
        this.parentNode = null;
      } else {
        this.parentNode = this.parent;
        this.parentNode.nodesRef = this;
        this.tree = this.parentNode.tree;
      }
    }
    _config() {
      const { nodes, childrenData } = this.props;
      const { initExpandLevel } = this.tree.props;
      let expanded =
        initExpandLevel === -1 ||
        initExpandLevel > (this.parentNode ? this.parentNode.level : -1);
      if (
        this.parentNode &&
        this.tree.expandedNodeRefs[this.parentNode.key] !== undefined
      ) {
        expanded = true;
      }
      let nodesProps = nodes;
      if (Array.isArray(childrenData)) {
        nodesProps = childrenData.map((item) => {
          return { data: item };
        });
      }
      const childDefaults = Component.extendProps(
        {
          component: TreeNode,
          dataToNode: ({ data, node }) => {
            if (isPlainObject(data)) {
              node.props.key = data.key;
              node.props.text = data.text;
              node.props.icon = data.icon;
              node.props.tools = data.tools;
              node.props.disabled = data.disabled;
              node.props.childrenData = data.children;
            }
          },
        },
        this.tree.props.nodeDefaults
      );
      this.setProps({
        children: nodesProps,
        childDefaults,
        hidden: expanded === false,
      });
    }
    _rendered() {
      const { sortable } = this.tree.props;
      if (sortable !== false) {
        const options = isPlainObject(sortable)
          ? Object.assign(
              {},
              {
                group: this.key,
                animation: 150,
                fallbackOnBody: true,
                swapThreshold: 0.65,
                handle:
                  this.tree.props.sortable &&
                  this.tree.props.sortable.showHandler &&
                  this.tree.props.sortable.byHandler
                    ? ".nom-tree-drag-handler"
                    : null,
              },
              sortable
            )
          : {
              group: this.key,
              animation: 150,
              fallbackOnBody: true,
              swapThreshold: 0.65,
              handle:
                this.tree.props.sortable &&
                this.tree.props.sortable.showHandler &&
                this.tree.props.sortable.byHandler
                  ? ".nom-tree-drag-handler"
                  : null,
            };
        new Sortable(this.element, options);
      }
    }
    iterateNodes() {}
  }
  TreeNodes.defaults = { nodes: null, childrenData: null };
  Component.register(TreeNodes);
  class Tree extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Tree.defaults, props), ...mixins);
    }
    _created() {
      this.nodeRefs = {};
      this.expandedNodeRefs = {};
      this._alreadyProcessedFlat = false;
      this.selectedNode = null;
    }
    _update(props) {
      if (props.data && this.props) {
        // data, flatDataTree
        if (this.props.flatData) {
          this._alreadyProcessedFlat = false;
        }
      }
    }
    _config() {
      this.nodeRefs = {};
      this.selectedNode = null;
      const { nodes, data, flatData, nodeCheckable } = this.props;
      if (flatData === true && !this._alreadyProcessedFlat) {
        this.setProps({ data: this._setTreeData(data) });
        this._alreadyProcessedFlat = true;
      }
      this._addPropStyle("fit");
      if (nodeCheckable) {
        this._loopSetValue(nodeCheckable, [
          "cascadeCheckParent",
          "cascadeCheckChildren",
          "cascadeUncheckChildren",
          "cascadeUncheckParent",
        ]);
        this.setProps({
          nodeCheckable: Component.extendProps(
            {
              cascadeCheckParent: true,
              cascadeCheckChildren: true,
              cascadeUncheckChildren: true,
              cascadeUncheckParent: true,
              cascade: false,
              showCheckAll: false,
              checkAllText: this.props.checkAllText,
              checkedNodeKeys: [],
            },
            nodeCheckable
          ),
        });
        if (this.props.nodeCheckable && this.props.nodeCheckable.onlyleaf) {
          this.setProps({
            nodeCheckable: {
              cascadeCheckParent: false,
              cascadeUncheckParent: false,
              cascade: false,
            },
          });
        }
        this.checkedNodeKeysHash = {};
        if (Array.isArray(this.props.nodeCheckable.checkedNodeKeys)) {
          this.props.nodeCheckable.checkedNodeKeys.forEach((key) => {
            this.checkedNodeKeysHash[key] = true;
          });
        }
      }
      const children = [];
      if (
        this.props.nodeCheckable &&
        this.props.nodeCheckable.showCheckAll === true
      ) {
        children.push(this._getCheckAllCheckbox());
      }
      children.push({
        component: TreeNodes,
        nodes,
        childrenData: this.props.data,
      });
      this.setProps({ children: children });
    }
    _rendered() {
      this.autoCheckAll();
      this.props.sortable && defaultSortableOndrop();
      this.props.nodeCheckable &&
        this.props.nodeCheckable.enablePartChecked === true &&
        this._initializePartCheckedNodes();
    }
    autoCheckAll() {
      if (!this.checkAllRef) return false;
      const check = Object.keys(this.nodeRefs).some((nodeKey) => {
        return this.nodeRefs[nodeKey].props.checked === false;
      });
      this.checkAllRef.setValue(!check, { triggerChange: false });
    }
    _loopSetValue(key, arry) {
      if (key.cascade === undefined) return false;
      arry.forEach(function (currentValue) {
        if (key[currentValue] === undefined) {
          key[currentValue] = key.cascade;
        }
      });
    }
    _dataToNodes() {}
    getData(getOptions, node) {
      getOptions = getOptions || {};
      node = node || this;
      const nodesData = [];
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        const childNodeData = Object.assign({}, childNode.props.data);
        nodesData.push(childNodeData);
        const children = this.getData(getOptions, childNode);
        if (children && children.length) {
          childNodeData.children = children;
        }
      });
      return nodesData;
    }
    getCheckedNodes(node) {
      if (node === undefined) {
        node = this;
      }
      const checkedNodes = [];
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        if (childNode.isChecked() === true) {
          checkedNodes.push(childNode);
          childNode.checkedNodes = this.getCheckedNodes(childNode);
        }
      });
      return checkedNodes;
    }
    getCheckedNodeKeys(getOptions = {}, checkedNodeKeys = [], node) {
      const { includePartialChecked = true } = getOptions;
      node = node || this;
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        //  includePartialChecked  true
        if (
          childNode.isChecked() === true ||
          (includePartialChecked && childNode.props.partChecked === true)
        ) {
          checkedNodeKeys.push(childNode.props.key);
        } // 
        this.getCheckedNodeKeys(getOptions, checkedNodeKeys, childNode);
      });
      return checkedNodeKeys;
    }
    getCheckedNodesData(
      getOptions = { flatData: false, includePartialChecked: true },
      node
    ) {
      const { flatData, includePartialChecked } = getOptions;
      node = node || this;
      const nodesData = [];
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        //  includePartialChecked  true
        if (
          childNode.isChecked() === true ||
          (includePartialChecked && childNode.props.partChecked === true)
        ) {
          const childNodeData = Object.assign({}, childNode.props.data);
          nodesData.push(childNodeData); // 
          if (!flatData) {
            const children = this.getCheckedNodesData(getOptions, childNode);
            if (children.length > 0) {
              childNodeData.children = children;
            }
          }
        } // 
        if (flatData) {
          const children = this.getCheckedNodesData(getOptions, childNode);
          nodesData.push(...children);
        }
      });
      return nodesData;
    }
    getNode(param) {
      let retNode = null;
      if (param instanceof Component) {
        return param;
      }
      if (isFunction(param)) {
        for (const key in this.nodeRefs) {
          if (this.nodeRefs.hasOwnProperty(key)) {
            if (param.call(this.nodeRefs[key]) === true) {
              retNode = this.nodeRefs[key];
              break;
            }
          }
        }
      } else {
        return this.nodeRefs[param];
      }
      return retNode;
    }
    getSelectedNode() {
      return this.selectedNode;
    }
    getChildNodes() {
      return this.nodesRef.getChildren();
    }
    selectNode(param) {
      const node = this.getNode(param);
      if (node) {
        node.select();
        if (this.props.nodeSelectable.scrollIntoView) {
          this.scrollTo(node);
        }
      }
    }
    clearSelection() {
      if (this.selectedNode) {
        this.selectedNode.unselect();
      }
    }
    checkNodes(param, options) {
      Object.keys(this.nodeRefs).forEach((nodeKey) => {
        if (!param.includes(nodeKey)) {
          this.nodeRefs[nodeKey].uncheck({ triggerCheckChange: false });
        } else if (options && options.ignoreDisabled !== true) {
          if (this.nodeRefs[nodeKey].props.disabled !== true) {
            this.nodeRefs[nodeKey].check({ triggerCheckChange: true });
          }
        } else {
          this.nodeRefs[nodeKey].check({ triggerCheckChange: true });
        }
      });
    }
    unCheckNodes(param, options) {
      if (Array.isArray(param) && param.length) {
        param.forEach((item) => {
          const node = this.getNode(item);
          if (options && options.ignoreDisabled !== true) {
            if (node.props.disabled !== true) {
              node.uncheck({ triggerCheckChange: false });
            }
          } else {
            node.uncheck({ triggerCheckChange: false });
          }
        });
      }
    }
    setCheckedNodeKeys(array) {
      this.props.nodeCheckable.checkedNodeKeys = array;
      this.update({});
    } // 
    expandTo(param) {
      let node = this.getNode(param); //  parentNode
      while (node) {
        //  && -->expanded: false
        if (node && node.content && !node.content.props.expanded) {
          node.content.expand();
        }
        node = node.parentNode;
      }
    }
    scrollTo(param) {
      const node = this.getNode(param);
      if (node) {
        scrollIntoView(node.element, {
          behavior: "smooth",
          scrollMode: "if-needed",
        });
      }
    }
    checkAllNodes(options) {
      Object.keys(this.nodeRefs).forEach((nodeKey) => {
        if (options && options.ignoreDisabled === true) {
          if (this.nodeRefs[nodeKey].props.disabled !== true) {
            this.nodeRefs[nodeKey].check({ triggerCheckChange: false });
          }
        } else {
          this.nodeRefs[nodeKey].check({ triggerCheckChange: false });
        }
      });
      this._onCheckChange();
    }
    uncheckAllNodes(options) {
      Object.keys(this.nodeRefs).forEach((nodeKey) => {
        if (options && options.ignoreDisabled === true) {
          if (this.nodeRefs[nodeKey].props.disabled !== true) {
            this.nodeRefs[nodeKey].uncheck({ triggerCheckChange: false });
          }
        } else {
          this.nodeRefs[nodeKey].uncheck({ triggerCheckChange: false });
        }
      });
      this._onCheckChange();
    }
    _onCheckChange(args) {
      const { onCheckChange } = this.props.nodeCheckable;
      this._callHandler(onCheckChange, args);
    }
    _onNodeClick(args) {
      this._callHandler("onNodeClick", args);
    }
    _onNodeSelect(args) {
      const { onNodeSelect } = this.props.nodeSelectable;
      this._callHandler(onNodeSelect, args);
    }
    _initializePartCheckedNodes() {
      Object.keys(this.checkedNodeKeysHash).forEach((key) => {
        const node = this.nodeRefs[key];
        if (node) {
          // 
          node.check({ checkCheckbox: false, triggerCheckChange: false }); // 
          let parentNode = node.parentNode;
          while (parentNode) {
            parentNode.updateParentCheckState();
            parentNode = parentNode.parentNode;
          }
        }
      });
    }
    _setTreeData(arr) {
      const { key, parentKey, children } = this.props.dataFields;
      if (!key || key === "" || !arr) return []; //   children,
      arr.forEach(function (item) {
        delete item[children];
      });
      const map = {}; // map
      arr.forEach((i) => {
        map[i[key]] = i; // key 
      });
      const treeData = [];
      arr.forEach((child) => {
        const mapItem = map[child[parentKey]]; // parentKeymap
        if (mapItem) {
          (mapItem[children] || (mapItem[children] = [])).push(child); // mapItemchildren, , children[]
        } else {
          // 
          treeData.push(child);
        }
      });
      return treeData;
    }
    _getCheckAllCheckbox() {
      const { disabled } = this.props;
      return {
        component: Checkbox,
        classes: { "nom-tree-check-all": true },
        text: this.props.nodeCheckable.checkAllText,
        disabled: disabled,
        _created: (inst) => {
          this.checkAllRef = inst;
        }, // value: this.tree.checkedNodeKeysHash[this.node.key] === true,
        onValueChange: ({ newValue }) => {
          if (newValue === true) {
            this.checkAllNodes();
          } else {
            this.uncheckAllNodes();
          }
        },
      };
    }
  }
  Tree.defaults = {
    nodes: null,
    nodeDefaults: {},
    nodeSelectable: {
      onlyleaf: false,
      byClick: true,
      selectedNodeKey: null,
      scrollIntoView: true,
    },
    dataFields: {
      key: "key",
      text: "text",
      children: "children",
      parentKey: "parentKey",
    },
    flatData: false,
    sortable: false,
    initExpandLevel: -1,
    loadData: false,
    checkAllText: "",
  };
  Component.register(Tree);
  var OptionTreeMixin = {
    _created: function () {
      this.checkboxTree = this.parent.parent;
      this.checkboxTree.optionTree = this;
    },
    _config: function () {
      const checkboxTreeProps = this.checkboxTree.props;
      this.setProps({
        disabled: checkboxTreeProps.disabled,
        nodeCheckable: {
          checkedNodeKeys: checkboxTreeProps.value,
          onCheckChange: () => {
            this.checkboxTree._onValueChange();
          },
        },
      });
    },
  };
  class DefaultCheckboxOptionTree extends Tree {
    constructor(props, ...mixins) {
      const defaults = { dataFields: { key: "value" } };
      super(Component.extendProps(defaults, props), OptionTreeMixin, ...mixins);
    }
  }
  class CheckboxTree extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(CheckboxTree.defaults, props), ...mixins);
    }
    _config() {
      const {
        options,
        showCheckAll,
        checkAllText,
        treeDataFields,
        cascadeUncheckChildren,
        cascadeCheckChildren,
        cascadeCheckParent,
        cascadeUncheckParent,
        cascade,
        attrs,
        initExpandLevel,
      } = this.props;
      if (attrs && attrs.style && attrs.style.height && isChrome49()) {
        attrs.style.overflow = "auto";
      }
      this.setProps({
        classes: { "nom-checkbox-tree-with-label": !!this.props.label },
        control: {
          component: DefaultCheckboxOptionTree,
          data: options,
          fit: true,
          dataFields: treeDataFields,
          initExpandLevel,
          nodeCheckable: {
            showCheckAll,
            checkAllText,
            cascade,
            cascadeCheckParent,
            cascadeCheckChildren,
            cascadeUncheckChildren,
            cascadeUncheckParent,
          },
        },
      });
      super._config();
    }
    getSelectedOptions() {
      return this.optionTree.getCheckedNodesData({ flatData: true });
    }
    _getValue(options) {
      const { valueOptions } = this.props;
      options = extend({ asString: false }, valueOptions, options);
      const selected = this.getSelectedOptions();
      if (selected !== null && Array.isArray(selected) && selected.length > 0) {
        const vals = selected.map(function (item) {
          return item.key;
        });
        if (options.asString) {
          return vals.join();
        }
        return vals;
      }
      return null;
    }
    _getValueText(options, value) {
      const selected =
        value !== undefined
          ? this._getOptionsByValue(value)
          : this.getSelectedOptions();
      if (selected !== null && Array.isArray(selected) && selected.length > 0) {
        const vals = selected.map(function (item) {
          return item.text;
        });
        return vals;
      }
      return null;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      if (value === null) {
        this.optionTree.unselectAllItems({
          triggerSelectionChange: options.triggerChange,
        });
      }
      this.optionTree.selectItem(
        function () {
          return this.props.value === value;
        },
        { triggerSelectionChange: options.triggerChange }
      );
    }
    _disable() {
      if (this.firstRender === false) {
        this.optionTree.disable();
      }
    }
    _enable() {
      if (this.firstRender === false) {
        this.optionTree.enable();
      }
    }
    _getOptionsByValue(value) {
      let retOptions = null;
      const { options } = this.props;
      if (Array.isArray(value)) {
        retOptions = [];
        for (let i = 0; i < options.length; i++) {
          if (value.indexOf(options[i].value) !== -1) {
            retOptions.push(options[i]);
          }
        }
      }
      return retOptions;
    }
  }
  CheckboxTree.defaults = {
    options: [],
    showCheckAll: false,
    checkAllText: "",
    treeDataFields: {},
  };
  Component.register(CheckboxTree);
  class CollapseItem extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        key: null,
        title: null,
        content: null,
        collapsed: true,
        onChange: null,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.menu = this.parent.parent.parent;
      this.menu.itemRef[this.props.key] = this;
    }
    _config() {
      const { key, title, content, collapsed } = this.props;
      const that = this;
      this.setProps({
        classes: { "align-right": that.menu.props.icon.align === "right" },
        children: [
          {
            component: "Flex",
            classes: {
              "nom-collapse-item-title": true,
              "nom-collapse-item-open": !collapsed,
            },
            key: key,
            align: "center",
            cols: [
              {
                children: Object.assign(
                  {},
                  Component.normalizeIconProps(
                    collapsed
                      ? that.menu.props.icon.default
                      : that.menu.props.icon.open
                  ),
                  {
                    ref: (c) => {
                      that.iconRef = c;
                    },
                    onClick: ({ sender }) => {
                      if (sender.props.type === that.menu.props.icon.default) {
                        sender.update({ type: that.menu.props.icon.open });
                      } else {
                        sender.update({ type: that.menu.props.icon.default });
                      }
                      if (!that.menu.props.iconOnly) return;
                      that._handleCollapse();
                    },
                  }
                ),
              },
              { grow: true, children: title },
            ],
            onClick: function () {
              if (that.menu.props.iconOnly) return;
              that._handleCollapse();
            },
          },
          {
            tag: "div",
            classes: { "nom-collapse-item-content": true },
            ref: (c) => {
              that.contentRef = c;
            },
            hidden: collapsed,
            children: content,
          },
        ],
      });
    }
    close() {
      this.contentRef.hide();
      this.props.collapsed = true;
      this.iconRef.update({ type: this.menu.props.icon.default });
    }
    _handleCollapse() {
      this.setProps({ collapsed: this.props.collapsed !== true });
      if (this.props.collapsed) {
        this.contentRef.hide();
      } else {
        this.contentRef.show();
      }
      this.menu._onCollapse(this.props.key, !this.props.collapsed);
    }
    _disable() {
      this.element.setAttribute("disabled", "disabled");
    }
  }
  Component.register(CollapseItem);
  class Collapse extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Collapse.defaults, props), ...mixins);
    }
    _created() {
      this.itemRef = [];
    }
    _config() {
      const { activeKey, bordered } = this.props;
      const items = this.props.items.map((item) => {
        return {
          component: CollapseItem,
          key: item.key,
          title: item.title,
          content: item.content,
          collapsed:
            Object.prototype.toString.call(activeKey) === "[object Array]"
              ? !this.onActiveKeyArray(item.key)
              : activeKey !== item.key,
          classes: { "nom-collapse-bordered": !!bordered },
        };
      });
      this.setProps({
        children: { component: "Flex", gutter: this.props.gutter, rows: items },
      });
    }
    _disable() {
      this.element.setAttribute("disabled", "disabled");
    }
    _onCollapse(key, isShown) {
      const that = this;
      this.setProps({ activeKey: key });
      if (isShown && this.props.accordion) {
        Object.keys(this.itemRef).forEach(function (k) {
          if (k !== key && parseInt(k, 10) !== key) {
            that.itemRef[k].close();
          }
        });
      }
      this.props.onChange &&
        this._callHandler(this.props.onChange, {
          currentKey: key,
          collapsed: !isShown,
        });
    }
    onActiveKeyArray(key) {
      return this.props.activeKey.some(function (currentValue) {
        return currentValue === key;
      });
    }
  }
  Collapse.defaults = {
    activeKey: 1,
    items: null,
    bordered: false,
    icon: { default: "right", open: "up", align: "left" },
    gutter: "small",
    iconOnly: false,
    accordion: false,
  };
  Component.register(Collapse);
  class ColorPicker extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(ColorPicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      const { dataKey, useHex } = this.props;
      let { data, popupWidth } = this.props;
      if (!useHex) {
        data = this._generateDefaultData();
      } else if (!data || !data.length) {
        data = [
          { id: "#c6cacc" },
          { id: "#feda98" },
          { id: "#f9e89e" },
          { id: "#fde996" },
          { id: "#cbe394" },
          { id: "#c8e2a5" },
          { id: "#a4e0a7" },
          { id: "#87e0d3" },
          { id: "#8ad3e2" },
          { id: "#95d8f8" },
          { id: "#98cdf3" },
          { id: "#a7b3e1" },
          { id: "#c4a7e9" },
          { id: "#dd9bc0" },
          { id: "#f6a0b5" },
          { id: "#fdb7a5" },
          { id: "#a7abb0" },
          { id: "#fdd565" },
          { id: "#f6d871" },
          { id: "#fcde65" },
          { id: "#b7e365" },
          { id: "#add37e" },
          { id: "#7dd182" },
          { id: "#54d1c1" },
          { id: "#58cfd3" },
          { id: "#62c3f5" },
          { id: "#65b2fc" },
          { id: "#8072d3" },
          { id: "#a675dd" },
          { id: "#c975d1" },
          { id: "#f2739a" },
          { id: "#fba07c" },
          { id: "#888d92" },
          { id: "#fda635" },
          { id: "#f3c645" },
          { id: "#fbd032" },
          { id: "#a7da2c" },
          { id: "#93c55a" },
          { id: "#5ac264" },
          { id: "#27c2b0" },
          { id: "#2cb8c5" },
          { id: "#30ace1" },
          { id: "#32a5fb" },
          { id: "#5e73c4" },
          { id: "#885bd2" },
          { id: "#b44a9a" },
          { id: "#ed4a7b" },
          { id: "#fa6648" },
          { id: "#6b7279" },
          { id: "#fc8800" },
          { id: "#f0b112" },
          { id: "#fac800" },
          { id: "#9bd100" },
          { id: "#7bb63c" },
          { id: "#3bb346" },
          { id: "#00b3a1" },
          { id: "#05a4b6" },
          { id: "#0095ee" },
          { id: "#0077fa" },
          { id: "#3f51b5" },
          { id: "#6a3ac7" },
          { id: "#9e2cb3" },
          { id: "#e91e63" },
          { id: "#f93a20" },
          { id: "#555B61" },
          { id: "#D26700" },
          { id: "#C88A0F" },
          { id: "#D0AA00" },
          { id: "#7EAE00" },
          { id: "#649830" },
          { id: "#30953B" },
          { id: "#009589" },
          { id: "#038698" },
          { id: "#007BCA" },
          { id: "#0062D6" },
          { id: "#3342A1" },
          { id: "#572FB3" },
          { id: "#871E9E" },
          { id: "#C51356" },
          { id: "#D52515" },
        ];
      }
      if (useHex && data.length === 80 && data[0].id === "#c6cacc") {
        // hex
        popupWidth = 468;
      }
      this.setProps({
        attrs: { tabindex: this.props.tabindex || 0 },
        control: {
          classes: { "nom-color-picker-trigger": true },
          children: {
            ref: (c) => {
              this.colorBlock = c;
            },
            classes: { "nom-color-picker-color-block": true },
            styles: { color: !useHex ? this.initValue : undefined },
            attrs: {
              style: {
                backgroundColor:
                  useHex && isHexColor(this.initValue)
                    ? this.initValue
                    : undefined,
                color:
                  useHex && isHexColor(this.initValue) ? "#fff" : undefined,
              },
            },
          },
          popup: {
            children: {
              component: "DataList",
              ref: (c) => {
                this.colorList = c;
              },
              classes: { "nom-color-picker-list": true }, // cols: 6,
              wrap: true,
              gap: "xsmall",
              attrs: { style: { width: `${popupWidth}px`, padding: "12px" } },
              itemSelectable: { byClick: true },
              selectedKeys: this.initValue,
              data: data,
              dataKey,
              itemRender: ({ itemData }) => {
                const color = itemData[dataKey];
                const isHex = isHexColor(color);
                return {
                  classes: { "nom-color-picker-list-item": true },
                  styles: { color: !useHex ? color : undefined },
                  attrs: {
                    style: {
                      backgroundColor: isHex ? color : undefined,
                      color: isHex ? "#fff" : undefined,
                    },
                  },
                  children: { component: "Icon", type: "check" },
                  onClick: () => {
                    if (isHex) {
                      this.colorBlock.update({
                        attrs: {
                          style: { backgroundColor: color, color: "#fff" },
                        },
                      });
                    } else {
                      this.colorBlock.update({
                        styles: { color: !useHex ? color : undefined },
                      });
                    }
                    this.control.popup.hide();
                  },
                };
              },
              onItemSelectionChange: () => {
                this._onValueChange();
              },
            },
            onShow: () => {
              this.colorList.selectItem(this.currentValue);
            },
          },
        },
      });
      super._config();
    }
    _generateDefaultData() {
      let data = [];
      const colors = [
        "red",
        "orange",
        "yellow",
        "green",
        "teal",
        "blue",
        "indigo",
        "purple",
        "pink",
        "cyan",
        "brown",
        "gray",
      ];
      colors.forEach((color) => {
        data = data.concat([
          { id: `l${color}-light` },
          { id: `l${color}` },
          { id: `l${color}-dark` },
          { id: `${color}-light` },
          { id: `${color}` },
          { id: `${color}-dark` },
        ]);
      });
      return data;
    }
    _getValue() {
      if (
        !this.colorList ||
        !this.colorList.props ||
        !this.colorList.getSelected()
      ) {
        return this.currentValue;
      }
      return this.colorList.getSelected().id;
    }
    _setValue(value) {
      this.currentValue = value;
      if (!this.props.useHex) {
        this.colorBlock.update({ styles: { color: value } });
      } else if (isHexColor(value)) {
        this.colorBlock.update({
          attrs: { style: { backgroundColor: value, color: "#fff" } },
        });
      }
    }
    _disable() {
      this.control.disable();
    }
    _enable() {
      this.control.enable();
    }
  }
  ColorPicker.defaults = {
    tag: "div",
    dataKey: "id",
    selectedKeys: null,
    itemSelectable: { multiple: false, byClick: false, scrollIntoView: false },
    disabledItemKeys: [],
    showEmpty: false,
    popupWidth: 192,
    useHex: false,
    data: null,
  };
  Component.register(ColorPicker);
  class ConfirmContent extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        title: null,
        description: null,
        icon: null,
        type: null,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const confirmInst = this.modal;
      const {
        title,
        description,
        icon,
        action,
        okText,
        cancelText,
      } = confirmInst.props;
      const iconProps = icon
        ? Component.extendProps(Component.normalizeIconProps(icon), {
            classes: { "nom-confirm-icon": true },
          })
        : null;
      const titleProps = title
        ? Component.extendProps(Component.normalizeTemplateProps(title), {
            classes: { "nom-confirm-title": true },
          })
        : null;
      const descriptionProps = description
        ? Component.extendProps(Component.normalizeTemplateProps(description), {
            classes: { "nom-confirm-description": true },
          })
        : null;
      const okButtonProps = {
        component: Button,
        type: "primary",
        text: okText,
        onClick: () => {
          confirmInst._handleOk();
        },
      };
      const cancelButtonProps = {
        component: Button,
        text: cancelText,
        onClick: () => {
          confirmInst._handleCancel();
        },
      };
      let actionProps = { component: Cols, justify: "end" };
      if (!action) {
        actionProps.items = [okButtonProps, cancelButtonProps];
      } else if (isPlainObject(action)) {
        actionProps = Component.extendProps(actionProps, action);
      } else if (Array.isArray(action)) {
        actionProps.items = action;
      }
      this.setProps({
        children: [
          {
            classes: { "nom-confirm-body": true },
            children: [
              iconProps,
              {
                classes: { "nom-confirm-body-content": true },
                children: [titleProps, descriptionProps],
              },
            ],
          },
          { classes: { "nom-confirm-actions": true }, children: actionProps },
        ],
      });
    }
  }
  Component.register(ConfirmContent);
  class Confirm extends Modal {
    constructor(props, ...mixins) {
      super(Component.extendProps(Confirm.defaults, props), ...mixins);
    }
    _config() {
      const { onOk } = this.props;
      this.setProps({
        content: { component: ConfirmContent },
        onOk: (e) => {
          if (onOk(e) !== false) {
            e.sender.close();
          }
        },
      });
      super._config();
    }
  }
  Confirm.defaults = {
    icon: "help-circle-fill",
    title: null,
    description: null,
    action: null,
  };
  Component.register(Confirm);
  class Container extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Container.defaults, props), mixins);
    }
    _config() {
      this._addPropStyle("breakpoint", "fluid");
    }
  }
  Container.defaults = {
    fluid: false, // type: null,
    breakpoint: null,
  };
  Component.register(Container);
  const CSS_PREFIX = "nom-statistic-"; // 
  function formatDecimal(num, groupSeparator, decimalSeparator) {
    const isNegative = num.toString().startWith("-");
    const absoluteValue = num.toString().replace(/^-/, "");
    let result;
    let decimal = "";
    let absoluteInteger = absoluteValue;
    if (absoluteInteger.includes(".")) {
      [absoluteInteger, decimal] = absoluteValue.split(".");
    }
    const len = absoluteInteger.length;
    if (len <= 3) return num.toString();
    let temp = "";
    const remainder = len % 3;
    if (decimal) temp = `${decimalSeparator}${decimal}`;
    if (remainder > 0) {
      result = `${absoluteInteger.slice(0, remainder)},${absoluteInteger
        .slice(remainder, len)
        .match(/\d{3}/g)
        .join(groupSeparator)}${temp}`;
    } else {
      result = `${absoluteInteger
        .slice(0, len)
        .match(/\d{3}/g)
        .join(groupSeparator)}${temp}`;
    }
    return isNegative ? `-${result}` : result;
  }
  class Statistic extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Statistic.defaults, props), ...mixins);
    }
    _config() {
      const statisticRef = this;
      const {
        title,
        value,
        precision,
        groupSeparator,
        decimalSeparator,
        formatter,
        prefix,
        suffix,
      } = this.props;
      const valueStr = value ? value.toString() : ""; // 
      let formatValue = decimalSeparator
        ? valueStr.replace(decimalSeparator, ".")
        : valueStr;
      if (isNumeric(formatValue)) {
        formatValue = isFunction(formatter)
          ? formatter(value)
          : formatDecimal(
              Number(formatValue).toFixed(precision),
              groupSeparator,
              decimalSeparator
            );
      }
      const content = [];
      prefix &&
        content.push({
          tag: "span",
          _created() {
            statisticRef.prefixRef = this;
          },
          classes: { [`${CSS_PREFIX}content-prefix`]: true },
          children: prefix,
        });
      value &&
        content.push({
          tag: "span",
          _created() {
            statisticRef.valueRef = this;
          },
          classes: { [`${CSS_PREFIX}content-value`]: true },
          children: formatValue,
        });
      suffix &&
        content.push({
          tag: "span",
          _created() {
            statisticRef.suffixRef = this;
          },
          classes: { [`${CSS_PREFIX}content-suffix`]: true },
          children: suffix,
        });
      this.setProps({
        children: [
          {
            _created() {
              statisticRef.captionRef = this;
            },
            classes: { [`${CSS_PREFIX}title`]: true },
            children: title,
          },
          { classes: { "nom-statistic-content": true }, children: content },
        ],
      });
    }
  }
  Statistic.defaults = {
    groupSeparator: ",",
    decimalSeparator: ".",
    precision: 0,
  };
  Component.register(Statistic);
  /**
   * Copyright (c)2005-2009 Matt Kruse (javascripttoolbox.com)
   *
   * Dual licensed under the MIT and GPL licenses.
   * This basically means you can use this code however you want for
   * free, but don't claim to have written it yourself!
   * Donations always accepted: http://www.JavascriptToolbox.com/donate/
   *
   * Please do not link to the .js files on javascripttoolbox.com from
   * your site. Copy the files locally to your server instead.
   *
   */ /*
  Date functions

  These functions are used to parse, format, and manipulate Date objects.
  See documentation and examples at http://www.JavascriptToolbox.com/lib/date/

  */ Date.$VERSION = 1.02; // Utility function to append a 0 to single-digit numbers
  Date.LZ = function (x) {
    return (x < 0 || x > 9 ? "" : "0") + x;
  }; // Full month names. Change this for local month names
  Date.monthNames = new Array(
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ); // Month abbreviations. Change this for local month names
  Date.monthAbbreviations = new Array(
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ); // Full day names. Change this for local month names
  Date.dayNames = new Array(
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ); // Day abbreviations. Change this for local month names
  Date.dayAbbreviations = new Array(
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ); // Used for parsing ambiguous dates like 1/2/2000 - default to preferring 'American' format meaning Jan 2.
  // Set to false to prefer 'European' format meaning Feb 1
  Date.preferAmericanFormat = true; // If the getFullYear() method is not defined, create it
  if (!Date.prototype.getFullYear) {
    Date.prototype.getFullYear = function () {
      const yy = this.getYear();
      return yy < 1900 ? yy + 1900 : yy;
    };
  } // Parse a string and convert it to a Date object.
  // If no format is passed, try a list of common formats.
  // If string cannot be parsed, return null.
  // Avoids regular expressions to be more portable.
  Date.parseString = function (val, format) {
    // If no format is specified, try a few common formats
    if (typeof format === "undefined" || format == null || format === "") {
      const generalFormats = new Array(
        "y-M-d",
        "MMM d, y",
        "MMM d,y",
        "y-MMM-d",
        "d-MMM-y",
        "MMM d",
        "MMM-d",
        "d-MMM"
      );
      const monthFirst = new Array("M/d/y", "M-d-y", "M.d.y", "M/d", "M-d");
      const dateFirst = new Array("d/M/y", "d-M-y", "d.M.y", "d/M", "d-M");
      const checkList = new Array(
        generalFormats,
        Date.preferAmericanFormat ? monthFirst : dateFirst,
        Date.preferAmericanFormat ? dateFirst : monthFirst
      );
      for (let i = 0; i < checkList.length; i++) {
        const l = checkList[i];
        for (let j = 0; j < l.length; j++) {
          const d = Date.parseString(val, l[j]);
          if (d != null) {
            return d;
          }
        }
      }
      return null;
    }
    this.isInteger = function (_val) {
      for (let i = 0; i < _val.length; i++) {
        if ("1234567890".indexOf(_val.charAt(i)) === -1) {
          return false;
        }
      }
      return true;
    };
    this.getInt = function (str, i, minlength, maxlength) {
      for (let x = maxlength; x >= minlength; x--) {
        const token = str.substring(i, i + x);
        if (token.length < minlength) {
          return null;
        }
        if (this.isInteger(token)) {
          return token;
        }
      }
      return null;
    };
    val += "";
    format += "";
    let i_val = 0;
    let i_format = 0;
    let c = "";
    let token = "";
    let x;
    let y;
    let year = new Date().getFullYear();
    let month = 1;
    let date = 1;
    let hh = 0;
    let mm = 0;
    let ss = 0;
    let ampm = "";
    while (i_format < format.length) {
      // Get next token from format string
      c = format.charAt(i_format);
      token = "";
      while (format.charAt(i_format) === c && i_format < format.length) {
        token += format.charAt(i_format++);
      } // Extract contents of value based on format token
      if (token === "yyyy" || token === "yy" || token === "y") {
        if (token === "yyyy") {
          x = 4;
          y = 4;
        }
        if (token === "yy") {
          x = 2;
          y = 2;
        }
        if (token === "y") {
          x = 2;
          y = 4;
        }
        year = this.getInt(val, i_val, x, y);
        if (year == null) {
          return null;
        }
        i_val += year.length;
        if (year.length === 2) {
          if (year > 70) {
            year = 1900 + (year - 0);
          } else {
            year = 2000 + (year - 0);
          }
        }
      } else if (token === "MMM" || token === "NNN") {
        month = 0;
        const names =
          token === "MMM"
            ? Date.monthNames.concat(Date.monthAbbreviations)
            : Date.monthAbbreviations;
        for (let i = 0; i < names.length; i++) {
          const month_name = names[i];
          if (
            val.substring(i_val, i_val + month_name.length).toLowerCase() ===
            month_name.toLowerCase()
          ) {
            month = (i % 12) + 1;
            i_val += month_name.length;
            break;
          }
        }
        if (month < 1 || month > 12) {
          return null;
        }
      } else if (token === "EE" || token === "E") {
        const names = token === "EE" ? Date.dayNames : Date.dayAbbreviations;
        for (let i = 0; i < names.length; i++) {
          const day_name = names[i];
          if (
            val.substring(i_val, i_val + day_name.length).toLowerCase() ===
            day_name.toLowerCase()
          ) {
            i_val += day_name.length;
            break;
          }
        }
      } else if (token === "MM" || token === "M") {
        month = this.getInt(val, i_val, token.length, 2);
        if (month == null || month < 1 || month > 12) {
          return null;
        }
        i_val += month.length;
      } else if (token === "dd" || token === "d") {
        date = this.getInt(val, i_val, token.length, 2);
        if (date == null || date < 1 || date > 31) {
          return null;
        }
        i_val += date.length;
      } else if (token === "hh" || token === "h") {
        hh = this.getInt(val, i_val, token.length, 2);
        if (hh == null || hh < 1 || hh > 12) {
          return null;
        }
        i_val += hh.length;
      } else if (token === "HH" || token === "H") {
        hh = this.getInt(val, i_val, token.length, 2);
        if (hh == null || hh < 0 || hh > 23) {
          return null;
        }
        i_val += hh.length;
      } else if (token === "KK" || token === "K") {
        hh = this.getInt(val, i_val, token.length, 2);
        if (hh == null || hh < 0 || hh > 11) {
          return null;
        }
        i_val += hh.length;
        hh++;
      } else if (token === "kk" || token === "k") {
        hh = this.getInt(val, i_val, token.length, 2);
        if (hh == null || hh < 1 || hh > 24) {
          return null;
        }
        i_val += hh.length;
        hh--;
      } else if (token === "mm" || token === "m") {
        mm = this.getInt(val, i_val, token.length, 2);
        if (mm == null || mm < 0 || mm > 59) {
          return null;
        }
        i_val += mm.length;
      } else if (token === "ss" || token === "s") {
        ss = this.getInt(val, i_val, token.length, 2);
        if (ss == null || ss < 0 || ss > 59) {
          return null;
        }
        i_val += ss.length;
      } else if (token === "a") {
        if (val.substring(i_val, i_val + 2).toLowerCase() === "am") {
          ampm = "AM";
        } else if (val.substring(i_val, i_val + 2).toLowerCase() === "pm") {
          ampm = "PM";
        } else {
          return null;
        }
        i_val += 2;
      } else {
        if (val.substring(i_val, i_val + token.length) !== token) {
          return null;
        }
        i_val += token.length;
      }
    } // If there are any trailing characters left in the value, it doesn't match
    if (i_val !== val.length) {
      return null;
    } // Is date valid for month?
    if (month === 2) {
      // Check for leap year
      if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
        // leap year
        if (date > 29) {
          return null;
        }
      } else if (date > 28) {
        return null;
      }
    }
    if (month === 4 || month === 6 || month === 9 || month === 11) {
      if (date > 30) {
        return null;
      }
    } // Correct hours value
    if (hh < 12 && ampm === "PM") {
      hh = hh - 0 + 12;
    } else if (hh > 11 && ampm === "AM") {
      hh -= 12;
    }
    return new Date(year, month - 1, date, hh, mm, ss);
  }; // Check if a date string is valid
  Date.isValid = function (val, format) {
    return Date.parseString(val, format) != null;
  }; // Check if a date object is before another date object
  Date.prototype.isBefore = function (date2) {
    if (date2 == null) {
      return false;
    }
    return this.getTime() < date2.getTime();
  }; // Check if a date object is after another date object
  Date.prototype.isAfter = function (date2) {
    if (date2 == null) {
      return false;
    }
    return this.getTime() > date2.getTime();
  }; // Check if two date objects have equal dates and times
  Date.prototype.equals = function (date2) {
    if (date2 == null) {
      return false;
    }
    return this.getTime() === date2.getTime();
  }; // Check if two date objects have equal dates, disregarding times
  Date.prototype.equalsIgnoreTime = function (date2) {
    if (date2 == null) {
      return false;
    }
    const d1 = new Date(this.getTime()).clearTime();
    const d2 = new Date(date2.getTime()).clearTime();
    return d1.getTime() === d2.getTime();
  }; // Format a date into a string using a given format string
  Date.prototype.format = function (format) {
    format += "";
    let result = "";
    let i_format = 0;
    let c = "";
    let token = "";
    let y = `${this.getYear()}`;
    const M = this.getMonth() + 1;
    const d = this.getDate();
    const E = this.getDay();
    const H = this.getHours();
    const m = this.getMinutes();
    const s = this.getSeconds(); // Convert real date parts into formatted versions
    const value = {};
    if (y.length < 4) {
      y = `${+y + 1900}`;
    }
    value.y = `${y}`;
    value.yyyy = y;
    value.yy = y.substring(2, 4);
    value.M = M;
    value.MM = Date.LZ(M);
    value.MMM = Date.monthNames[M - 1];
    value.NNN = Date.monthAbbreviations[M - 1];
    value.d = d;
    value.dd = Date.LZ(d);
    value.E = Date.dayAbbreviations[E];
    value.EE = Date.dayNames[E];
    value.H = H;
    value.HH = Date.LZ(H);
    if (H === 0) {
      value.h = 12;
    } else if (H > 12) {
      value.h = H - 12;
    } else {
      value.h = H;
    }
    value.hh = Date.LZ(value.h);
    value.K = value.h - 1;
    value.k = value.H + 1;
    value.KK = Date.LZ(value.K);
    value.kk = Date.LZ(value.k);
    if (H > 11) {
      value.a = "PM";
    } else {
      value.a = "AM";
    }
    value.m = m;
    value.mm = Date.LZ(m);
    value.s = s;
    value.ss = Date.LZ(s);
    while (i_format < format.length) {
      c = format.charAt(i_format);
      token = "";
      while (format.charAt(i_format) === c && i_format < format.length) {
        token += format.charAt(i_format++);
      }
      if (typeof value[token] !== "undefined") {
        result += value[token];
      } else {
        result += token;
      }
    }
    return result;
  }; // Get the full name of the day for a date
  Date.prototype.getDayName = function () {
    return Date.dayNames[this.getDay()];
  }; // Get the abbreviation of the day for a date
  Date.prototype.getDayAbbreviation = function () {
    return Date.dayAbbreviations[this.getDay()];
  }; // Get the full name of the month for a date
  Date.prototype.getMonthName = function () {
    return Date.monthNames[this.getMonth()];
  }; // Get the abbreviation of the month for a date
  Date.prototype.getMonthAbbreviation = function () {
    return Date.monthAbbreviations[this.getMonth()];
  }; // Clear all time information in a date object
  Date.prototype.clearTime = function () {
    this.setHours(0);
    this.setMinutes(0);
    this.setSeconds(0);
    this.setMilliseconds(0);
    return this;
  }; // Add an amount of time to a date. Negative numbers can be passed to subtract time.
  Date.prototype.add = function (interval, number) {
    if (
      typeof interval === "undefined" ||
      interval == null ||
      typeof number === "undefined" ||
      number == null
    ) {
      return this;
    }
    number = +number;
    if (interval === "y") {
      // year
      this.setFullYear(this.getFullYear() + number);
    } else if (interval === "M") {
      // Month
      this.setMonth(this.getMonth() + number);
    } else if (interval === "d") {
      // Day
      this.setDate(this.getDate() + number);
    } else if (interval === "w") {
      // Weekday
      const step = number > 0 ? 1 : -1;
      while (number !== 0) {
        this.add("d", step);
        while (this.getDay() === 0 || this.getDay() === 6) {
          this.add("d", step);
        }
        number -= step;
      }
    } else if (interval === "h") {
      // Hour
      this.setHours(this.getHours() + number);
    } else if (interval === "m") {
      // Minute
      this.setMinutes(this.getMinutes() + number);
    } else if (interval === "s") {
      // Second
      this.setSeconds(this.getSeconds() + number);
    }
    return this;
  }; // Countdown
  const timeUnits = [
    ["Y", 1000 * 60 * 60 * 24 * 365], // years
    ["M", 1000 * 60 * 60 * 24 * 30], // months
    ["D", 1000 * 60 * 60 * 24], // days
    ["H", 1000 * 60 * 60], // hours
    ["m", 1000 * 60], // minutes
    ["s", 1000], // seconds
    ["S", 1], // million seconds
  ]; // function padStart(string, length, chars) {
  //   const strLength = length ? stringSize(string) : 0
  //   return length && strLength < length
  //     ? createPadding(length - strLength, chars) + string
  //     : string || ''
  // }
  function padStart(string, length, chars) {
    if (!string) return "";
    const repeatCount = length - string.length;
    return repeatCount > 0 ? `${chars.repeat(repeatCount)}${string}` : string;
  }
  function formatTimeStr(duration, format) {
    let leftDuration = duration;
    const escapeRegex = /\[[^\]]*]/g;
    const keepList = (format.match(escapeRegex) || []).map((str) =>
      str.slice(1, -1)
    );
    const templateText = format.replace(escapeRegex, "[]");
    const replacedText = timeUnits.reduce((current, [name, unit]) => {
      if (current.indexOf(name) !== -1) {
        const value = Math.floor(leftDuration / unit);
        leftDuration -= value * unit;
        return current.replace(new RegExp(`${name}+`, "g"), (match) => {
          const len = match.length;
          return padStart(value.toString(), len, "0");
        });
      }
      return current;
    }, templateText);
    let index = 0;
    return replacedText.replace(escapeRegex, () => {
      const match = keepList[index];
      index += 1;
      return match;
    });
  }
  class Countdown extends Statistic {
    constructor(props, ...mixins) {
      super(Component.extendProps(Countdown.defaults, props), ...mixins);
    }
    _created() {
      this._interval = null;
    }
    _config() {
      const countdownRef = this;
      this._handleDeadLine();
      this.setProps({ value: countdownRef._flashCountdown(this.props.format) });
      super._config();
    }
    _rendered() {
      // start timer
      this._startCountdown();
    }
    _remove() {
      clearInterval(this._interval);
      this._interval = undefined;
    }
    _handleDeadLine() {
      const { value } = this.props;
      let deadline = 0;
      if (isDate(value)) {
        deadline = value.getTime();
      } else if (isNumeric(value)) {
        deadline = new Date(value).getTime();
      }
      this._deadline = deadline;
    }
    _startCountdown() {
      const countdownRef = this;
      const { interval, format } = this.props;
      if (this._interval || !isNumeric(interval)) return;
      this._interval = setInterval(() => {
        if (countdownRef._deadline < Date.now()) countdownRef._stopCountdown();
        countdownRef.valueRef.element.innerHTML = countdownRef._flashCountdown(
          format
        );
      }, interval);
    }
    _stopCountdown() {
      const { onComplete } = this.props;
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = undefined; // const timestamp = getTimestamp(value)
        if (isFunction(onComplete) && this._deadline < Date.now()) {
          onComplete();
        }
      }
    }
    _flashCountdown(format) {
      const diff = Math.max(this._deadline - Date.now(), 0);
      return formatTimeStr(diff, format);
    }
  }
  Countdown.defaults = { format: "HH:mm:ss", interval: 3000 };
  Component.register(Countdown);
  var DataListItemMixin = {
    _created: function () {
      this.list = this.parent;
    },
    _config: function () {
      const { selected, disabled } = this.props;
      const listProps = this.list.props;
      const { disabledKeys } = this.list.props;
      const selectedItems =
        listProps.selectedKeys !== null && listProps.selectedKeys !== undefined
          ? Array.isArray(listProps.selectedKeys)
            ? listProps.selectedKeys
            : [listProps.selectedKeys]
          : [];
      const disabledItems =
        disabledKeys !== null && disabledKeys !== undefined
          ? Array.isArray(disabledKeys)
            ? disabledKeys
            : [disabledKeys]
          : [];
      this.setProps({
        classes: { "nom-data-list-item": true },
        selected: selected === true || selectedItems.indexOf(this.key) !== -1,
        disabled: disabled === true || disabledItems.indexOf(this.key) !== -1,
        selectable: {
          byClick: listProps.itemSelectable.byClick,
          canRevert: listProps.itemSelectable.multiple === true,
          triggerOnInit: listProps.itemSelectable.triggerOnInit,
        },
        _shouldHandleClick: function () {
          if (listProps.disabled === true) {
            return false;
          }
        },
        onSelect: () => {
          const list = this.list;
          if (listProps.itemSelectable.multiple === false) {
            listProps.selectedKeys = this.key;
            if (list.selectedItem !== null) {
              list.selectedItem.unselect({ triggerSelectionChange: false });
            }
            list.selectedItem = this;
          }
          list._onItemSelected(this.props._itemData, this.key);
        },
        onUnselect: () => {
          const list = this.parent;
          if (listProps.selectedKeys === this.key) {
            listProps.selectedKeys = null;
          }
          if (list.selectedItem === this) {
            list.selectedItem = null;
          }
          list._onItemUnselected(this.props._itemData, this.key);
        },
        onSelectionChange: () => {
          const list = this.parent;
          list._onItemSelectionChange();
        },
      });
    },
    _rendered: function () {
      const list = this.parent;
      const listProps = list.props;
      if (listProps.itemSelectable.multiple === false) {
        if (this.props.selected) {
          list.selectedItem = this;
          if (listProps.itemSelectable.scrollIntoView) {
            list.scrollTo(list.selectedItem);
          }
        }
      }
    },
  };
  function isObject(val) {
    return (
      val != null && typeof val === "object" && Array.isArray(val) === false
    );
  }
  class DataList extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(DataList.defaults, props), ...mixins);
    }
    _config() {
      this.selectedItem = null;
      const { data, showEmpty, itemSelectable, dataKey } = this.props;
      this._addPropStyle(
        "gap",
        "line",
        "align",
        "justify",
        "wrap",
        "vertical",
        "fills",
        "cols"
      );
      let empty = null;
      if (isPlainObject(showEmpty)) {
        empty = Object.assign({ component: "Empty" }, showEmpty);
      } else if (showEmpty === true) {
        empty = { component: "Empty" };
      }
      let children = [];
      if (Array.isArray(data) && data.length > 0) {
        if (itemSelectable.defaultSelectFirst) {
          this.props.selectedKeys = data[0][dataKey];
        }
        children = data.map((itemData) => {
          return this._getItemDescriptor(itemData);
        });
      } else {
        children = empty;
      }
      this.setProps({ selectable: { byClick: false }, children: children });
    }
    selectItem(key, selectOption) {
      const found = this.findItem(key);
      if (found) {
        return found.select(selectOption);
      }
    }
    selectItems(keys, selectOption) {
      selectOption = extend(
        { triggerSelect: true, triggerSelectionChange: true },
        selectOption
      );
      let itemSelectionChanged = false;
      keys = Array.isArray(keys) ? keys : [keys];
      for (let i = 0; i < keys.length; i++) {
        itemSelectionChanged =
          this.selectItem(keys[i], {
            triggerSelect: selectOption.triggerSelect,
            triggerSelectionChange: false,
          }) || itemSelectionChanged;
      }
      if (
        selectOption.triggerSelectionChange === true &&
        itemSelectionChanged
      ) {
        this._onItemSelectionChange();
      }
      return itemSelectionChanged;
    }
    selectAllItems(selectOption) {
      return this.selectItems(this.getChildren(), selectOption);
    }
    unselectItem(key, selectOption) {
      const found = this.findItem(key);
      if (found) {
        found.unselect(selectOption);
      }
    }
    getSelected() {
      const { itemSelectable } = this.props;
      if (itemSelectable && itemSelectable.multiple === true) {
        const selectedData = [];
        const children = this.getChildren();
        for (let i = 0; i < children.length; i++) {
          const item = children[i];
          if (item.props.selected) {
            selectedData.push(item.props._itemData);
          }
        }
        return selectedData;
      }
      if (this.selectedItem) {
        return this.selectedItem.props._itemData;
      }
      return null;
    }
    appendItem(itemData) {
      this.appendChild(this._getItemDescriptor(itemData));
    }
    prependItem(itemData) {
      this.prependChild(this._getItemDescriptor(itemData));
    }
    updateItem(key, newItemData) {
      const item = this.findItem(key);
      if (item) {
        item.replace(this._getItemDescriptor(newItemData));
      }
    }
    removeItem(key) {
      const item = this.findItem(key);
      if (item !== null) {
        item.remove();
      }
    }
    disableItem(key) {
      const item = this.findItem(key);
      if (item !== null) {
        item.disable();
      }
    }
    enableItem(key) {
      const item = this.findItem(key);
      if (item !== null) {
        item.enable();
      }
    }
    scrollTo(key) {
      const item = this.findItem(key);
      if (item) {
        const { itemSelectable } = this.props;
        const itemElement = item.element;
        const scrollOptions =
          itemSelectable &&
          itemSelectable.scrollIntoView &&
          isPlainObject(itemSelectable.scrollIntoView)
            ? itemSelectable.scrollIntoView
            : {};
        setTimeout(() => {
          scrollIntoView(
            itemElement,
            Component.extendProps(
              { behavior: "smooth", scrollMode: "if-needed" },
              scrollOptions
            )
          );
        }, 200);
      }
    }
    findItem(key) {
      return this.findChild(key);
    }
    getItemKeys() {
      const keys = [];
      const children = this.getChildren();
      for (let i = 0; i < children.length; i++) {
        const item = children[i];
        if (item.componentType !== "Empty") {
          keys.push(item.key);
        }
      }
      return keys;
    }
    getItemDatas() {
      const datas = [];
      const children = this.getChildren();
      for (let i = 0; i < children.length; i++) {
        const item = children[i];
        if (item.componentType !== "Empty") {
          datas.push(item.props._itemData);
        }
      }
      return datas;
    }
    _onItemSelectionChange() {
      this._callHandler(this.props.onItemSelectionChange);
    }
    _onItemSelected(itemData, key) {
      this._callHandler(this.props.onItemSelected, { itemData, key });
    }
    _onItemUnselected(itemData, key) {
      this._callHandler(this.props.onItemUnselected, { itemData, key });
    }
    _getItemDescriptor(itemData) {
      const { dataKey, itemRender } = this.props;
      if (isObject(itemData)) {
        let itemProps = { key: itemData[dataKey], _itemData: itemData };
        if (isFunction(itemRender)) {
          itemProps = Component.extendProps(
            itemProps,
            itemRender({ itemData, list: this })
          );
        }
        return n$1(null, itemProps, null, [DataListItemMixin]);
      }
    }
    handleDrag(event) {
      if (this.props.sortable && this.props.sortable.onEnd) {
        this._callHandler(this.props.sortable.onEnd, { event: event });
      }
    }
    _rendered() {
      const that = this;
      const { sortable } = this.props;
      if (sortable) {
        const options = {
          group: this.key,
          animation: 150,
          fallbackOnBody: true,
          swapThreshold: 0.65,
          handle: sortable.handle,
          filter: ".s-disabled",
          onEnd: function (event) {
            that.handleDrag(event);
          },
        };
        new Sortable(this.element, options);
      }
    }
  }
  DataList.defaults = {
    tag: "div",
    data: null,
    dataKey: "id",
    selectedKeys: null,
    itemSelectable: {
      multiple: false,
      byClick: false,
      scrollIntoView: false,
      defaultSelectFirst: false,
      triggerOnInit: false,
    },
    disabledItemKeys: [],
    showEmpty: false,
    sortable: false,
  };
  Component.register(DataList);
  class FlexItem extends Component {
    constructor(props, ...mixins) {
      const defaults = { grow: false, shrink: false, isBody: false };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = ["grow", "shrink", "isBody"];
      const { span } = this.props;
      if (span) {
        this.setProps({ styles: { col: span } });
      }
    }
  }
  Component.register(FlexItem);
  class Flex extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Flex.defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = [
        "direction",
        "wrap",
        "align",
        "justify",
        "gap",
        "gutter",
        "fills",
        "fit",
        "vertical",
        "cols",
      ];
      const { rows, cols, itemDefaults, items } = this.props;
      let { direction } = this.props;
      let children = [];
      if (Array.isArray(items)) {
        this.setProps({ classes: { "nom-flex2": true }, children: items });
        return;
      }
      if (Array.isArray(rows) && rows.length) {
        direction = "column";
        children = rows;
      } else if (Array.isArray(cols) && cols.length) {
        direction = "row";
        children = cols;
      }
      children = children.map((item) => {
        if (isPlainObject(item)) {
          return Component.extendProps(
            itemDefaults,
            this._normalizeItem(item),
            { component: FlexItem }
          );
        }
        return item;
      });
      this.setProps({
        direction: direction,
        children: children,
        childDefaults: { component: FlexItem },
      });
    } // todo:  maybe move some logic to FlexItem
    _normalizeItem(item) {
      let itemProps = {};
      const { component, tag, rows, cols, children: subChildren } = item;
      if (
        (component && component !== FlexItem && component !== "FlexItem") ||
        (component !== FlexItem && component !== "FlexItem" && isString(tag))
      ) {
        itemProps.children = item;
      } else if (Array.isArray(rows) || Array.isArray(cols)) {
        item.component = Flex;
        itemProps.children = item;
      } else if (isPlainObject(subChildren)) {
        const { rows: subRows, cols: subCols } = subChildren;
        if (Array.isArray(subRows) || Array.isArray(subCols)) {
          subChildren.component = Flex;
        }
        itemProps = item;
        itemProps.children = subChildren;
      } else {
        itemProps = item;
      }
      return itemProps;
    }
  }
  Flex.defaults = {
    rows: null,
    cols: null,
    wrap: false,
    align: null,
    justify: null,
    gap: null,
    gutter: null,
    fills: false,
    inline: false,
    fit: false,
  };
  Component.register(Flex);
  class DateTimePickerList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        gutter: "xs",
        cols: 1,
        min: "00",
        max: "59",
        scrollIntoView: false,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.scroller = this.parent;
      this.timeWrapper = this.parent.parent.parent.parent.parent;
      this.pickerControl = this.timeWrapper.pickerControl;
      this.pickerControl.timeList[this.props.type] = this;
    }
    _config() {
      let items = [];
      const that = this;
      const {
        currentDateBeforeMin,
        currentDateAfterMax,
      } = this.pickerControl.datePicker;
      const { _isHourOverRange, _isMinuteOverRange } = this.pickerControl;
      const { type } = this.props;
      this.props.min = this.pickerControl.timeRange[type][0];
      this.props.max = this.pickerControl.timeRange[type][1];
      if (type === "hour") {
        items = this.pickerControl.getHour();
      } else if (type === "minute") {
        items = this.pickerControl.getMinute();
      } else if (type === "second") {
        items = this.pickerControl.getSecond();
      }
      this.setProps({
        items: items,
        itemSelectable: {
          multiple: false,
          byClick: true,
          scrollIntoView: { block: "center", scrollMode: "always" },
        },
        attrs: { style: { position: "relative" } },
        itemDefaults: {
          _config: function () {
            const key = this.props.key;
            const disabledOverRange =
              (type !== "hour" && _isHourOverRange) ||
              (type === "second" && _isMinuteOverRange); //  min  max
            this.setProps({
              disabled:
                key < that.props.min ||
                key > that.props.max ||
                currentDateBeforeMin ||
                currentDateAfterMax ||
                disabledOverRange,
            });
          },
        },
        onItemSelectionChange: () => {
          this.onChange();
        },
      });
      super._config();
    }
    onChange() {
      this.setTime();
    }
    setTime() {
      const key = this.getSelectedItem().key || "00";
      this.pickerControl.setTime({ type: this.props.type, value: key });
    }
    resetTime() {
      if (this.pickerControl.defaultValue) {
        const t = this.pickerControl.defaultValue.split(":");
        if (this.props.type === "hour") {
          this.selectItem(t[0], { triggerSelectionChange: false });
        } else if (this.props.type === "minute") {
          this.selectItem(t[1], { triggerSelectionChange: false });
        } else {
          this.selectItem(t[2], { triggerSelectionChange: false });
        }
      } else {
        this.unselectAllItems();
      }
    }
    refresh() {
      this.update();
    }
  }
  class DateTimePickerWrapper extends Component {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.pickerControl = this.parent.parent.parent;
    }
    _config() {
      this.setProps({
        children: {
          component: "Rows",
          gutter: null,
          items: [
            {
              component: "Cols",
              gutter: null,
              classes: { "timepicker-group": true },
              fills: true,
              align: "stretch",
              children: [
                {
                  classes: { "nom-datepicker-time-overcont": true },
                  hidden: !this.pickerControl.props.format.includes("HH"),
                  children: { component: DateTimePickerList, type: "hour" },
                },
                {
                  classes: { "nom-datepicker-time-overcont": true },
                  hidden: !this.pickerControl.props.format.includes("mm"),
                  children: { component: DateTimePickerList, type: "minute" },
                },
                {
                  classes: { "nom-datepicker-time-overcont": true },
                  hidden: !this.pickerControl.props.format.includes("ss"),
                  children: { component: DateTimePickerList, type: "second" },
                },
              ],
            },
          ],
        },
      });
    }
  }
  Component.register(DateTimePickerWrapper);
  class TimePickerPanel extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        allowClear: true,
        value: null,
        format: "HH:mm:ss",
        hourStep: 0,
        minuteStep: 0,
        secondStep: 0,
        readonly: true,
        placeholder: null,
        showNow: true,
        onValueChange: null,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.datePicker = this.parent.parent.parent.opener.parent.parent;
      this.datePicker.timePicker = this;
      this.timeList = [];
      this.empty = !this.props.value;
      this.minTime = { hour: "00", minute: "00", second: "00" };
      this.maxTime = { hour: "23", minute: "59", second: "59" };
      this.time = { hour: "00", minute: "00", second: "00" };
      if (this.props.value) {
        const t = this.props.value.split(":");
        this.time.hour = t[0] || "00";
        this.time.minute = t[1] || "00";
        this.time.second = t[2] || "00";
      }
      this.defaultTime = this.time;
    }
    _config() {
      const that = this;
      this.defaultValue = this.defaultValue || this.props.value;
      if (
        this.datePicker.props.showTime &&
        this.datePicker.props.showTime !== true
      ) {
        this.props = Object.assign(
          {},
          this.props,
          this.datePicker.props.showTime
        );
      }
      this._getMinTime();
      this._getMaxTime();
      this.timeRange = {
        hour: [this.minTime.hour, this.maxTime.hour],
        minute: ["00", "59"],
        second: ["00", "59"],
      };
      this._calcTimeRangeByTime();
      this.setProps({
        children: {
          component: "Flex",
          rows: [
            {
              classes: { "time-display": true },
              ref: (c) => {
                that.timeText = c;
              },
            },
            { component: DateTimePickerWrapper },
          ],
        },
      });
      super._config();
    } // timeRangemin
    _getMinTime() {
      const { startTime, minTime = "00:00:00" } = this.props; //  datePicker.minDatetime  showTime.minTime
      const _tempStartTime = new Date(`2020/01/01 ${startTime}`);
      const _tempMinTime = new Date(`2020/01/01 ${minTime}`); // startTime  && startTime  minTime
      // 
      const isStartTimeAfterMinTime =
        startTime !== "00:00:00" && _tempStartTime.isAfter(_tempMinTime);
      const time = isStartTimeAfterMinTime ? _tempStartTime : _tempMinTime;
      this.minTime = {
        hour: this.getDoubleDigit(time.getHours()),
        minute: this.getDoubleDigit(time.getMinutes()),
        second: this.getDoubleDigit(time.getSeconds()),
      };
    } // timeRangemax
    _getMaxTime() {
      const { endTime, maxTime = "23:59:59" } = this.props; //  datePicker.minDatetime  showTime.maxTime
      const _tempEndTime = new Date(`2020/01/01 ${endTime}`);
      const _tempMaxTime = new Date(`2020/01/01 ${maxTime}`); // endTime  && endTime  maxTime
      // 
      const isEndTimeBeforeMaxTime =
        endTime !== "23:59:59" && _tempEndTime.isBefore(_tempMaxTime);
      const time = isEndTimeBeforeMaxTime ? _tempEndTime : _tempMaxTime;
      this.maxTime = {
        hour: this.getDoubleDigit(time.getHours()),
        minute: this.getDoubleDigit(time.getMinutes()),
        second: this.getDoubleDigit(time.getSeconds()),
      };
    }
    getHour() {
      const hour = [];
      if (this.props.hourStep) {
        hour.push({ key: "00", children: "00" });
        for (let i = 0; i < 24; i++) {
          if ((i + 1) % this.props.hourStep === 0 && i !== 23) {
            hour.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return hour;
      }
      for (let i = 0; i < 24; i++) {
        hour.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return hour;
    }
    getMinute() {
      const minute = [];
      if (this.props.minuteStep) {
        minute.push({ key: "00", children: "00" });
        for (let i = 0; i < 60; i++) {
          if ((i + 1) % this.props.minuteStep === 0 && i !== 59) {
            minute.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return minute;
      }
      for (let i = 0; i < 60; i++) {
        minute.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return minute;
    }
    getSecond() {
      const second = [];
      if (this.props.secondStep) {
        second.push({ key: "00", children: "00" });
        for (let i = 0; i < 60; i++) {
          if ((i + 1) % this.props.secondStep === 0 && i !== 59) {
            second.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return second;
      }
      for (let i = 0; i < 60; i++) {
        second.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return second;
    }
    setValue(c) {
      this.timeText &&
        this.timeText.props &&
        this.timeText.update({ children: c });
      this.defaultValue = c;
      const t = c.split(":");
      this.time.hour = t[0] || "00";
      this.time.minute = t[1] || "00";
      this.time.second = t[2] || "00";
      this.resetList();
      this.props.onValueChange &&
        this._callHandler(this.props.onValueChange(this.time));
    }
    setTime(data) {
      this.time[data.type] = data.value;
      if (this.time.hour <= this.minTime.hour) {
        this.time.hour = this.minTime.hour;
        if (this.time.minute <= this.minTime.minute) {
          this.time.minute = this.minTime.minute;
        }
        if (this.time.minute <= this.minTime.minute) {
          if (this.time.second <= this.minTime.second) {
            this.time.second = this.minTime.second;
          }
        }
      }
      if (this.time.hour >= this.maxTime.hour) {
        this.time.hour = this.maxTime.hour;
        if (this.time.minute >= this.maxTime.minute) {
          this.time.minute = this.maxTime.minute;
        }
        if (this.time.minute >= this.maxTime.minute) {
          if (this.time.second >= this.maxTime.second) {
            this.time.second = this.maxTime.second;
          }
        }
      }
      this.checkTimeRange();
      const result = new Date(
        "2000",
        "01",
        "01",
        this.time.hour,
        this.time.minute,
        this.time.second
      ).format(this.props.format);
      this.setValue(result);
      this.defaultValue = result;
    }
    resetList() {
      const that = this;
      Object.keys(this.timeList).forEach(function (key) {
        that.timeList[key].resetTime();
      });
    }
    clearTime() {
      const that = this;
      this.props.value = null;
      this.defaultValue = null;
      this.defaultTime = this.time = { hour: "00", minute: "00", second: "00" };
      this.timeText.update({ children: "" });
      Object.keys(this.timeList).forEach(function (key) {
        that.timeList[key].resetTime();
      });
    }
    onShow() {
      this.timeText &&
        this.timeText.props &&
        this.timeText.update({ children: this.defaultValue });
      this.resetList();
    }
    setNow() {
      const c = new Date().format("HH:mm:ss");
      const t = c.split(":");
      this.time.hour = t[0];
      this.time.minute = t[1];
      this.time.second = t[2];
      this.checkTimeRange();
      this.setValue(c.format(this.props.format));
      this.defaultValue = c;
      this.empty = false;
      this.resetList();
    }
    handleChange() {
      this.props.onChange && this._callHandler(this.props.onChange);
    }
    getDoubleDigit(num) {
      if (num < 10) {
        return `0${num}`;
      }
      return `${num}`;
    }
    checkTimeRange() {
      const that = this;
      const beforeHourFlag = this._isHourOverRange;
      const beforeMinuteFlag = this._isMinuteOverRange;
      const { hour, minute, second } = this.timeRange;
      const beforeTimeRangeStr = `${hour}-${minute}-${second}`;
      this._calcTimeRangeByTime();
      this.empty = false; //  timeRange 
      const { hour: aHour, minute: aMinute, second: aSecond } = this.timeRange;
      const afterTimeRangeStr = `${aHour}-${aMinute}-${aSecond}`;
      let needRefreshList = [];
      if (afterTimeRangeStr !== beforeTimeRangeStr) {
        needRefreshList = ["hour", "minute", "second"];
      } else if (beforeHourFlag !== this._isHourOverRange) {
        needRefreshList = ["minute", "second"];
      } else if (beforeMinuteFlag !== this._isMinuteOverRange) {
        needRefreshList = ["second"];
      } // timeList
      needRefreshList.forEach(function (key) {
        that.timeList[key].refresh();
      });
    } //  time  timeRange
    // hour min~max, minutesecondrange = ['00', '59']
    _calcTimeRangeByTime() {
      const { time, timeRange, minTime, maxTime } = this;
      this._isHourOverRange =
        time.hour < minTime.hour || time.hour > maxTime.hour;
      this._isMinuteOverRange =
        (time.hour === minTime.hour && time.minute < minTime.minute) ||
        (time.hour === maxTime.hour && time.minute > maxTime.minute);
      if (time.hour <= minTime.hour) {
        timeRange.hour = [minTime.hour, maxTime.hour];
        timeRange.minute = [minTime.minute, "59"];
        if (time.minute <= minTime.minute) {
          timeRange.second = [minTime.second, "59"];
        } else {
          timeRange.second = ["00", "59"];
        }
      } else if (time.hour >= maxTime.hour) {
        timeRange.minute = ["00", maxTime.minute];
        if (time.minute >= maxTime.minute) {
          timeRange.second = ["00", maxTime.second];
        } else {
          timeRange.second = ["00", "59"];
        }
      } else {
        timeRange.minute = timeRange.second = ["00", "59"];
      }
    }
  }
  Component.register(TimePickerPanel);
  class DatePicker extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(DatePicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.dateInfo = null;
      this.todayItem = null;
      this.startTime = null;
      this.originValue = null;
      this._weekInfo = {};
    }
    _config() {
      const that = this;
      if (this.props.weekMode) {
        this.props.format = "yyyy-MM-dd";
        this.props.showTime = false;
        this.props.displayValue = true;
        this._parseWeekValueType(); // 
      } else {
        this.props.displayValue = false;
      }
      if (isValidDate$1(this.props.value)) {
        this.props.value = formatDate(this.props.value, this.props.format);
      }
      const { disabled, extraTools, startWeekOnMonday } = this.props; // 
      if (startWeekOnMonday && !this.weekNumberChanged) {
        const weekTextArray = this.props.weekText.split(" ");
        const firstDay = weekTextArray.shift();
        weekTextArray.push(firstDay);
        this.props.weekText = weekTextArray.join(" ");
        this.weekNumberChanged = true;
      }
      let extra = [];
      if (isFunction(extraTools)) {
        extra = Array.isArray(extraTools(this))
          ? extraTools(this)
          : [extraTools(this)];
      } else if (Array.isArray(extraTools)) {
        extra = extraTools;
      }
      this.getCurrentDate();
      const minTime =
        this.props.showTime && this.props.minDate
          ? new Date(this.props.minDate).format(
              this.props.showTime.format || "HH:mm:ss"
            )
          : "00:00:00";
      const maxTime =
        this.props.showTime && this.props.maxDate
          ? new Date(this.props.maxDate).format(
              this.props.showTime.format || "HH:mm:ss"
            )
          : "23:59:59";
      this.startTime = minTime;
      this.endTime = maxTime;
      this.minDateDay = this.props.minDate
        ? new Date(this.props.minDate).format("yyyy-MM-dd")
        : null;
      this.maxDateDay = this.props.maxDate
        ? new Date(this.props.maxDate).format("yyyy-MM-dd")
        : null;
      this.showNow = true;
      if (
        (this.props.minDate &&
          new Date().isBefore(new Date(`${this.props.minDate} ${minTime}`))) ||
        (this.props.maxDate &&
          new Date().isAfter(new Date(`${this.props.maxDate} ${maxTime}`)))
      ) {
        this.showNow = false;
      }
      const { weekText } = this.props;
      this.setProps({
        leftIcon: "calendar",
        clearProps: {
          component: "Icon",
          type: "times",
          classes: { "nom-field-clear-handler": true },
          hidden: !this.props.allowClear || this.props.disabled,
          onClick: (args) => {
            this.clearTime();
            args.event && args.event.stopPropagation();
          },
        },
        control: {
          disabled: disabled,
          popup: {
            _created: function () {
              that.popup = this;
            },
            onShow: () => {
              this.getCurrentDate();
              this.reActiveList();
              this.yearMonthContainerRef.hide(); // that.props.showTime && that.timePicker.onShow()
              setTimeout(() => {
                this._fixTimePickerHeight && this._fixTimePickerHeight();
              }, 0);
            },
            onHide: () => {
              that.onPopupHide();
            },
            animate: this.props.animate,
            classes: {
              "nom-date-picker-popup": true,
              "nom-date-picker-with-time": this.props.showTime,
            },
            triggerAction: "click",
            children: [
              {
                component: Flex,
                cols: [
                  {
                    attrs: { style: { width: "280px" } },
                    rows: [
                      {
                        classes: { "nom-datepicker-popup-hd": true },
                        justify: "between",
                        align: "center",
                        gap: "small",
                        cols: [
                          that.props.showYearSkip && {
                            children: {
                              component: "Button",
                              icon: "double-left",
                              type: "text",
                              onClick: ({ event }) => {
                                event.stopPropagation();
                                that._yearMinus();
                              },
                            },
                          },
                          {
                            children: {
                              component: "Button",
                              icon: "left",
                              type: "text",
                              onClick: ({ event }) => {
                                event.stopPropagation();
                                that._monthMinus();
                              },
                            },
                          },
                          {
                            grow: true,
                            align: "center",
                            children: {
                              component: "Flex",
                              onClick: () => {
                                that.yearMonthContainerRef.show();
                                that.yearClicked = false;
                                that.monthClicked = false;
                                that.yearRef.selectItem(that.year);
                                that.monthRef.selectItem(that.month);
                              },
                              gap: "small",
                              cols: [
                                {
                                  tag: "h5",
                                  ref: (c) => {
                                    that.yearTextRef = c;
                                  },
                                  children: that.props.yearTextFormatter(
                                    that.year
                                  ),
                                },
                                {
                                  tag: "h5",
                                  ref: (c) => {
                                    that.monthTextRef = c;
                                  },
                                  children: that.props.monthMap[that.month],
                                },
                              ],
                            },
                          },
                          {
                            children: {
                              component: "Button",
                              icon: "right",
                              type: "text",
                              onClick: ({ event }) => {
                                event.stopPropagation();
                                that._monthPlus();
                              },
                            },
                          },
                          that.props.showYearSkip && {
                            children: {
                              component: "Button",
                              icon: "double-right",
                              type: "text",
                              onClick: ({ event }) => {
                                event.stopPropagation();
                                that._yearPlus();
                              },
                            },
                          },
                        ],
                      },
                      {
                        classes: { "nom-datepicker-popup-bd": true },
                        rows: [
                          {
                            cols: weekText.split(" "),
                            fills: true, // gap: 'md',
                            classes: { "nom-datepicker-panel-header": true },
                          },
                          {
                            component: List,
                            _created: function () {
                              that.days = this;
                            }, // onRendered: () => {
                            //   that._recountHeight()
                            // },
                            cols: 7,
                            classes: { "nom-datepicker-panel-days": true },
                            itemSelectable: {
                              byClick: true,
                              multiple: false,
                              scrollIntoView: true,
                            },
                            items: this._getDays(that.year, that.month),
                            itemDefaults: {
                              key: function () {
                                this.props.date = new Date(
                                  this.props.year,
                                  this.props.month - 1,
                                  this.props.day
                                ).format("yyyy-M-d");
                                return this.props.date;
                              },
                              classes: { "nom-datepicker-day-item": true },
                              attrs: { role: "button" },
                              _config: function () {
                                let isMuted = false;
                                const date = that._getDateString(
                                  this.props.year,
                                  this.props.month,
                                  this.props.day
                                ); // 
                                const weekDays = [];
                                const currentDate = new Date(date);
                                const currentDay = currentDate.getDay();
                                const startOfWeekOffset =
                                  currentDay === 0 ? -6 : 1 - currentDay; // 
                                const startOfWeek = new Date(currentDate);
                                startOfWeek.setDate(
                                  currentDate.getDate() + startOfWeekOffset
                                ); // 
                                for (let i = 0; i < 7; i++) {
                                  const _day = new Date(startOfWeek);
                                  _day.setDate(startOfWeek.getDate() + i);
                                  weekDays.push(_day.format("yyyy-MM-dd"));
                                }
                                this.weekDays = weekDays;
                                const isFirstDayOfWeek = date === weekDays[0];
                                const isLastDayOfWeek = date === weekDays[6];
                                const isToday =
                                  date === new Date().format("yyyy-MM-dd");
                                let isDisabled = false;
                                if (that.props.disabledTime) {
                                  isDisabled = that.props.disabledTime(date);
                                }
                                if (
                                  that.props.minDate &&
                                  new Date(date).isBefore(
                                    new Date(that.minDateDay)
                                  )
                                ) {
                                  isDisabled = true;
                                }
                                if (
                                  that.props.maxDate &&
                                  new Date(date).isAfter(
                                    new Date(that.maxDateDay)
                                  )
                                ) {
                                  isDisabled = true;
                                }
                                if (
                                  this.props.lastMonth === true ||
                                  this.props.nextMonth === true
                                ) {
                                  isMuted = true;
                                }
                                if (isToday) {
                                  that.todayItem = this;
                                  this.setProps({
                                    classes: {
                                      "nom-datepicker-today-item": true,
                                    },
                                  });
                                }
                                if (that.props.weekMode) {
                                  this.weekCount = nomui.utils.getWeekInYear({
                                    date,
                                  }).week;
                                  this.setProps({
                                    attrs: {
                                      title: that.props.weekCountText.replace(
                                        "{week}",
                                        this.weekCount
                                      ),
                                    },
                                  });
                                }
                                this.setProps({
                                  styles: { text: "center" },
                                  attrs: { "data-date": date },
                                  classes: {
                                    "nom-datepicker-item-muted": isMuted,
                                    "nom-datepicker-item-first-day-of-week": isFirstDayOfWeek,
                                    "nom-datepicker-item-last-day-of-week": isLastDayOfWeek,
                                  },
                                  children: this.props.day,
                                  disabled: !!isDisabled,
                                });
                              },
                              _rendered: function () {
                                if (that.props.weekMode) {
                                  const { weekDays } = this;
                                  this.element.addEventListener(
                                    "mouseenter",
                                    () => {
                                      that.days.element
                                        .querySelectorAll(`[data-date]`)
                                        .forEach((item) => {
                                          if (
                                            weekDays.includes(item.dataset.date)
                                          ) {
                                            item.classList.add(
                                              "nom-datepicker-item-week-hover"
                                            );
                                          } else {
                                            item.classList.remove(
                                              "nom-datepicker-item-week-hover"
                                            );
                                          }
                                        });
                                    }
                                  );
                                }
                              },
                              onClick: function ({ sender }) {
                                const {
                                  year: selYear,
                                  month: selMonth,
                                  day: selDay,
                                } = sender.props;
                                that.dateInfo = Object.assign(
                                  {},
                                  that.dateInfo,
                                  {
                                    year: selYear,
                                    month: selMonth - 1,
                                    day: selDay,
                                  }
                                );
                                if (that.props.weekMode) {
                                  // 
                                  const firstDayOfWeek = new Date(
                                    sender.weekDays[0]
                                  );
                                  that.dateInfo = {
                                    year: firstDayOfWeek.getFullYear(),
                                    month: firstDayOfWeek.getMonth(),
                                    day: firstDayOfWeek.getDate(),
                                  };
                                  that._weekInfo = {
                                    year: selYear,
                                    week: sender.weekCount,
                                    dates: sender.weekDays,
                                  };
                                  that.updateValue();
                                  that.popup.hide();
                                  return;
                                }
                                if (that.props.showTime) {
                                  that._updateTimePickerStartEndTime(
                                    sender.props.day
                                  );
                                }
                                that.updateValue();
                                if (that.timePicker) {
                                  that.timePicker.onShow();
                                  that._fixTimePickerHeight();
                                }
                                !that.props.showTime && that.popup.hide();
                              },
                            },
                            onRendered: ({ inst }) => {
                              if (
                                that.props.weekMode &&
                                inst.props.selectedItems &&
                                inst.props.selectedItems.length
                              ) {
                                const item = inst.getSelectedItem();
                                if (!item) {
                                  return;
                                }
                                const { weekDays } = item; // this.element[data-date]sibsnom-datepicker-item-week-selectednom-datepicker-item-week-selected
                                inst.element
                                  .querySelectorAll(`[data-date]`)
                                  .forEach((n) => {
                                    if (weekDays.includes(n.dataset.date)) {
                                      n.classList.add(
                                        "nom-datepicker-item-week-selected"
                                      );
                                    } else {
                                      n.classList.remove(
                                        "nom-datepicker-item-week-selected"
                                      );
                                    }
                                  });
                              }
                            },
                          },
                        ],
                      },
                    ],
                  },
                  this.props.showTime && {
                    component: TimePickerPanel,
                    ref: (c) => {
                      this.timePickerRef = c;
                    },
                    classes: { "nom-datepicker-time-panel": true },
                    onValueChange: (data) => {
                      this.handleTimeChange(data);
                    }, //  startTime, endTime
                    startTime: this.currentDateBeforeMin ? minTime : "00:00:00",
                    endTime: this.currentDateAfterMax ? maxTime : "23:59:59",
                    value:
                      this.props.value &&
                      new Date(this.props.value.replace(/-/g, "/")).format(
                        this.props.showTime.format || "HH:mm:ss"
                      ),
                  },
                ],
              },
              (this.props.showNow || extra.length) && {
                component: Flex,
                classes: { "nom-datepicker-footer": true },
                cols: [
                  ...extra,
                  {
                    component: "Button",
                    size: "small",
                    text: that._getNowText(),
                    disabled: !this.showNow,
                    renderIf: this.props.showNow,
                    onClick: () => {
                      if (that.props.weekMode) {
                        // 
                        const today = new Date();
                        const currentDay = today.getDay();
                        const startOfWeekOffset =
                          currentDay === 0
                            ? -6 // 
                            : 1 - currentDay; // 
                        const startOfWeek = new Date(today);
                        startOfWeek.setDate(
                          today.getDate() + startOfWeekOffset
                        );
                        that.dateInfo = {
                          year: startOfWeek.getFullYear(),
                          month: startOfWeek.getMonth(), // getMonth()  0-11
                          day: startOfWeek.getDate(),
                        };
                        const _date = new Date();
                        const { year, week } = nomui.utils.getWeekInYear({
                          date: _date,
                        });
                        that._weekInfo = {
                          year,
                          week,
                          dates: nomui.utils.getWeekDates({ date: _date }),
                        };
                        that.updateValue();
                        that.popup.hide();
                        return;
                      }
                      if (that.props.showTime) {
                        that._updateTimePickerStartEndTime(
                          new Date().getDate()
                        );
                      }
                      this.setNow();
                    },
                  },
                ],
              },
              {
                ref: (c) => {
                  that.yearMonthContainerRef = c;
                },
                classes: { "nom-datepicker-year-month": true },
                hidden: true,
                children: {
                  component: "Flex",
                  vertical: true,
                  items: [
                    {
                      classes: { "nom-datepicker-year-month-back": true },
                      children: {
                        component: "Button",
                        icon: "left",
                        text: that.props.backText,
                        type: "text",
                        onClick: ({ event }) => {
                          event.stopPropagation();
                          that.yearMonthContainerRef.hide();
                          that._fixTimePickerHeight();
                        },
                      },
                    },
                    {
                      component: "Flex",
                      classes: { "nom-datepicker-year-month-container": true },
                      items: [
                        {
                          component: "List",
                          cols: 1,
                          itemSelectable: {
                            byClick: true,
                            scrollIntoView: true,
                            multiple: false,
                          },
                          ref: (c) => {
                            that.yearRef = c;
                          },
                          itemDefaults: {
                            key: function () {
                              return this.props.value;
                            },
                            onConfig: ({ inst }) => {
                              inst.setProps({
                                children: that.props.yearTextFormatter(
                                  inst.props.text
                                ),
                              });
                            },
                            onClick: () => {
                              if (!that.props.autoHideYearMonthPicker) {
                                return;
                              }
                              that.yearClicked = true;
                              if (that.yearClicked && that.monthClicked) {
                                setTimeout(() => {
                                  that.yearMonthContainerRef.hide();
                                }, 400);
                              }
                            },
                          },
                          onItemSelectionChange: () => {
                            const y = that.yearRef.getSelectedItem();
                            that.year = y.key;
                            that.yearTextRef.update({
                              children: that.props.yearTextFormatter(that.year),
                            });
                            y.element.scrollIntoView({
                              block: "center",
                              behavior: "smooth",
                            });
                            that.days.update({
                              items: that._getDays(that.year, that.month),
                            });
                          },
                          items: this._getYears(),
                        },
                        {
                          component: "List",
                          ref: (c) => {
                            that.monthRef = c;
                          },
                          cols: 1,
                          itemSelectable: {
                            byClick: true,
                            scrollIntoView: true,
                            multiple: false,
                          },
                          itemDefaults: {
                            key: function () {
                              return this.props.value;
                            },
                            onConfig: ({ inst }) => {
                              inst.setProps({
                                children: that.props.monthMap[inst.props.value],
                              });
                            },
                            onClick: () => {
                              if (!that.props.autoHideYearMonthPicker) {
                                return;
                              }
                              that.monthClicked = true;
                              if (that.yearClicked && that.monthClicked) {
                                setTimeout(() => {
                                  that.yearMonthContainerRef.hide();
                                }, 400);
                              }
                            },
                          },
                          onItemSelectionChange: () => {
                            const m = that.monthRef.getSelectedItem();
                            that.month = m.key;
                            that.monthTextRef.update({
                              children: that.props.monthMap[that.month],
                            });
                            m.element.scrollIntoView({
                              block: "center",
                              behavior: "smooth",
                            });
                            that.days.update({
                              items: that._getDays(that.year, that.month),
                            });
                          },
                          items: this._getMonths(),
                        },
                      ],
                    },
                  ],
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _parseWeekValueType() {
      if (!Number.isNaN(Date.parse(this.props.value))) {
        const { year, week, dates } = nomui.utils.getWeekInYear({
          date: this.props.value,
        }); // const dates = nomui.utils.getWeekDates({ year, week })
        this._weekInfo = { year, week, dates };
        this.props.displayValue = this._getWeekText();
        return;
      }
      if (!this.props.weekMode || !this.props.valueOptions) {
        return;
      }
      if (
        this.props.valueOptions &&
        this.props.valueOptions.asObject === true &&
        this.props.weekMode &&
        nomui.utils.isPlainObject(this.props.value)
      ) {
        this.props.value = new Date(this.props.value.dates[0]).format(
          this.props.format
        );
      }
    }
    _fixTimePickerHeight() {
      if (!this.timePicker || !this.popup.rendered) {
        return;
      }
      const h = this.popup.element.querySelector(".nom-datepicker-popup-bd")
        .offsetHeight;
      this.popup.element.querySelector(
        ".timepicker-group"
      ).style.height = `${h}px`;
    } //  timePicker( startTime endTime)
    _updateTimePickerStartEndTime(day) {
      this.currentDateBeforeMin = false;
      this.currentDateAfterMax = false;
      const minDay = parseInt(new Date(this.minDateDay).format("d"), 10);
      const maxDay = parseInt(new Date(this.maxDateDay).format("d"), 10);
      const timeProps = { startTime: "00:00:00", endTime: "23:59:59" };
      if (minDay === day) {
        timeProps.startTime = this.startTime;
      }
      if (maxDay === day) {
        timeProps.endTime = this.endTime;
      }
      this.timePicker.update(timeProps);
    }
    _yearMinus() {
      this.year -= 1;
      this.yearTextRef.update({
        children: this.props.yearTextFormatter(this.year),
      });
      this.days.update({ items: this._getDays(this.year, this.month) });
      this._fixTimePickerHeight();
    }
    _yearPlus() {
      this.year += 1;
      this.yearTextRef.update({
        children: this.props.yearTextFormatter(this.year),
      });
      this.days.update({ items: this._getDays(this.year, this.month) });
      this._fixTimePickerHeight();
    }
    _monthMinus() {
      if (this.month === 1) {
        this.month = 12;
        this.year -= 1;
        this.yearTextRef.update({
          children: this.props.yearTextFormatter(this.year),
        });
      } else {
        this.month -= 1;
      }
      this.monthTextRef.update({ children: this.props.monthMap[this.month] });
      this.days.update({ items: this._getDays(this.year, this.month) });
      this._fixTimePickerHeight();
    }
    _monthPlus() {
      if (this.month === 12) {
        this.month = 1;
        this.year += 1;
        this.yearTextRef.update({
          children: this.props.yearTextFormatter(this.year),
        });
      } else {
        this.month += 1;
      }
      this.monthTextRef.update({ children: this.props.monthMap[this.month] });
      this.days.update({ items: this._getDays(this.year, this.month) });
      this._fixTimePickerHeight();
    }
    _getYears() {
      const years = [];
      const thisYear = new Date().getFullYear();
      for (
        let i = thisYear + this.props.yearRange[1];
        i > thisYear - this.props.yearRange[0];
        i--
      ) {
        years.push({ text: i, value: i });
      }
      return years;
    }
    _getMonths() {
      const months = [];
      for (let i = 1; i < 13; i++) {
        months.push({ text: i, value: i });
      }
      return months;
    }
    _getDays(year, month) {
      const firstDay = this._getFirstDayOfMonth(year, month);
      const currentDayCount = this._getDaysInMonth(year, month);
      let lastDayCount = this._getDaysInMonth(year, month - 1);
      const daysList = [];
      let i = 0;
      let lastMonthYear = year;
      let lastMonthMonth = month - 1;
      let nextMonthYear = year;
      let nextMonthMonth = month + 1;
      if (month === 1) {
        lastDayCount = this._getDaysInMonth(year - 1, 12);
        lastMonthYear = year - 1;
        lastMonthMonth = 12;
      }
      if (firstDay > 0) {
        for (i = lastDayCount - firstDay + 1; i < lastDayCount + 1; i++) {
          daysList.push({
            day: i,
            year: lastMonthYear,
            month: lastMonthMonth,
            lastMonth: true,
          });
        }
      }
      for (i = 1; i < currentDayCount + 1; i++) {
        daysList.push({ day: i, year: year, month: month });
      }
      const nextMonthCount = 7 - (daysList.length % 7 || 7);
      if (month === 12) {
        nextMonthYear++;
        nextMonthMonth = 1;
      }
      for (i = 1; i < nextMonthCount + 1; i++) {
        daysList.push({
          day: i,
          year: nextMonthYear,
          month: nextMonthMonth,
          nextMonth: true,
        });
      }
      return daysList;
    }
    _recountHeight() {
      // 
      const me = this;
      setTimeout(() => {
        const h = me.days.element.offsetHeight;
        me.timePickerRef.element
          .querySelectorAll(".nom-datepicker-time-overcont")
          .forEach((n) => {
            n.style.maxHeight = `${h + 40}px`;
          });
      }, 0);
    }
    /* XXXX1 */ _getFirstDayOfMonth(year, month) {
      const firstDay = new Date(year, month - 1, 1).getDay(); // 0 (Sunday) to 6 (Saturday)
      if (this.props.startWeekOnMonday) {
        //  Sunday (0)  7 1
        return firstDay === 0 ? 6 : firstDay - 1;
      }
      return firstDay; // 
    }
    /* XXXX */ _getDaysInMonth(year, month) {
      return (
        32 - this._daylightSavingAdjust(new Date(year, month - 1, 32)).getDate()
      );
    }
    _getDoubleDigit(num) {
      if (num < 10) {
        return `0${num}`;
      }
      return num;
    }
    _getDateString(year, month, day) {
      return `${year}-${this._getDoubleDigit(month)}-${this._getDoubleDigit(day)}`;
    }
    _daylightSavingAdjust(date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    }
    _extractYearAndWeek(input) {
      if (!Number.isNaN(Date.parse(input))) {
        const { year, week, dates } = nomui.utils.getWeekInYear({
          date: input,
        });
        return { year, week, dates };
      } // 
      const regexPattern = this.props.weekFormat
        .replace(/{year}/g, "(\\d{4})") // 4
        .replace(/{week}/g, "(\\d{1,2})"); // 12
      const regex = new RegExp(`^${regexPattern}$`); // 
      const match = input.match(regex);
      if (!match) {
        throw new Error(
          ` "${this.props.weekFormat}"`
        );
      } // 
      const year = parseInt(match[1], 10);
      const week = parseInt(match[2], 10); // 1  53
      if (week < 1 || week > 53) {
        throw new Error(" 1  53 ");
      }
      const dates = nomui.utils.getWeekDates({ year, week });
      return { year, week, dates };
    }
    _disable() {
      super._disable();
      if (this.firstRender === false) {
        this.control.disable();
      }
    }
    _enable() {
      super._enable();
      if (this.firstRender === false) {
        this.control.enable();
      }
    }
    reActiveList() {
      this.yearRef.selectItem(this.year);
      this.monthRef.selectItem(this.month);
      this.props.value &&
        this.days.update({
          selectedItems: `${this.year}-${this.month}-${this.day}`,
        });
    }
    getCurrentDate() {
      let currentDate = new Date();
      if (this.props.value !== null) {
        if (this.props.weekMode) {
          this._parseWeekValueType(); // 
          const { year, week, dates } = this._extractYearAndWeek(
            this.props.value
          );
          this._weekInfo = { year, week, dates };
          currentDate = new Date(dates[0]);
        } else {
          currentDate = Date.parseString(this.props.value, this.props.format);
        }
      } else if (this.minDateDay) {
        currentDate = new Date(this.minDateDay);
      }
      if (!currentDate) {
        currentDate = new Date();
      }
      this.year = currentDate.getFullYear();
      this.month = currentDate.getMonth() + 1;
      this.day = currentDate.getDate(); // :  , 
      //      new Date(dateString) , `yyyy-MM-dd`
      this.currentDateBeforeMin =
        this.minDateDay && currentDate.isBefore(new Date(this.minDateDay));
      this.currentDateAfterMax =
        this.maxDateDay && currentDate.isAfter(new Date(this.maxDateDay));
      this.dateInfo = { year: this.year, month: this.month - 1, day: this.day };
      if (this.props.value && this.props.showTime && this.timePicker) {
        if (!Date.isValid(this.props.value)) {
          return;
        }
        this.timePicker.setValue(
          new Date(currentDate).format(this.props.showTime.format || "HH:mm:ss")
        );
      } else if (!this.props.value && this.props.showTime && this.timePicker) {
        this.timePicker.clearTime();
      }
    }
    _getNowText() {
      if (this.props.weekMode) {
        return this.props.currentWeekText;
      }
      return this.props.showTime ? this.props.nowText : this.props.todayText;
    }
    _checkFormat(input) {
      if (!Number.isNaN(Date.parse(input))) {
        return true;
      }
      if (
        nomui.utils.isPlainObject(input) &&
        input.year &&
        input.week &&
        input.dates
      ) {
        return true;
      } // 
      const regexPattern = this.props.weekFormat
        .replace(/{year}/g, "\\d{4}") // 4
        .replace(/{week}/g, "\\d{1,2}"); // 12
      const regex = new RegExp(`^${regexPattern}$`); // 
      return regex.test(input);
    }
    handleTimeChange(param) {
      if (
        !this.days.getSelectedItem() &&
        this.todayItem &&
        this.todayItem.props
      ) {
        this.days.selectItem(this.todayItem);
      }
      this.dateInfo = Object.assign({}, this.dateInfo, {
        hour: param.hour,
        minute: param.minute,
        second: param.second,
      });
      this.updateValue();
    }
    getWeekDetails() {
      if (!this.props.weekMode || !this.getValue()) {
        return null;
      }
      return this._weekInfo;
    }
    clearTime() {
      this.props.value = null;
      this.setValue(null);
      this.dateInfo = null;
      if (this.days && this.days.props) {
        this.days.unselectAllItems();
        this.days.element
          .querySelectorAll(`.nom-datepicker-item-week-selected`)
          .forEach((n) => {
            n.classList.remove("nom-datepicker-item-week-selected");
          });
      }
      if (this.props.showTime && this.timePicker && this.timePicker.props) {
        this.timePicker.clearTime();
      }
    }
    _getTextValue() {
      const { trimValue } = this.props;
      let inputText = this.getText();
      inputText = trimValue ? inputText.trimLeft().trimRight() : inputText;
      if (inputText === "") {
        return null;
      }
      return inputText;
    }
    _getWeekText() {
      const weekStr = this.props.weekFormat
        .replace("{week}", this._weekInfo.week)
        .replace("{year}", this._weekInfo.year)
        .replace("{start}", this._weekInfo.dates[0])
        .replace("{end}", this._weekInfo.dates[6]);
      return weekStr;
    }
    getValue(options = {}) {
      if (this.props.weekMode) {
        if (
          (this.props.valueOptions &&
            this.props.valueOptions.asObject === true) ||
          options.asObject === true
        ) {
          if (Object.keys(this._weekInfo).length === 0) {
            return null;
          }
          return this._weekInfo;
        }
        return this._getTextValue();
      }
      return this._getTextValue();
    }
    setValue(value, options = {}) {
      if (this.props.weekMode) {
        if (value) {
          const { year, week, dates } = this._extractYearAndWeek(value);
          this._weekInfo = { year, week, dates };
          this._setDisplayValue(this._getWeekText());
        } else {
          this.dateInfo = null;
          this._weekInfo = {};
          this._setDisplayValue("");
        }
      }
      super.setValue(value, options);
    }
    setNow() {
      this.setValue(new Date().format(this.props.format));
      this.popup.hide();
    }
    close() {
      this.popup.hide();
    }
    updateValue() {
      if (this.props.weekMode) {
        const dateStr = new Date(this._weekInfo.dates[0]).format(
          this.props.format
        );
        this._setDisplayValue(this._getWeekText());
        this.setValue(dateStr);
      } else {
        const date = new Date(
          this.dateInfo.year || new Date().format("yyyy"),
          isNumeric(this.dateInfo.month)
            ? this.dateInfo.month
            : new Date().format("MM") - 1,
          this.dateInfo.day || new Date().format("dd"),
          this.dateInfo.hour || "00",
          this.dateInfo.minute || "00",
          this.dateInfo.second || "00"
        );
        this.setValue(date.format(this.props.format));
      }
    }
    showPopup() {
      this.popup.show();
    }
    onPopupHide() {
      this.getValue() &&
        this.props.onChange &&
        this._callHandler(this.props.onChange);
    }
    _onBlur() {
      if (this.getValue()) {
        if (this.props.weekMode) {
          !this._checkFormat(this.getValue()) && this.clearTime();
        } else {
          !Date.isValid(this.getValue(), this.props.format) &&
            !this.props.allowInValid &&
            this.clearTime();
        }
      }
      super._onBlur();
    }
  }
  DatePicker.defaults = {
    format: "yyyy-MM-dd",
    autoHideYearMonthPicker: true,
    disabledTime: null,
    minDate: null,
    maxDate: null,
    yearRange: [90, 20],
    showTime: false,
    allowClear: true,
    onChange: null,
    showNow: true,
    readonly: false,
    restrictInput: true,
    extraTools: null,
    startWeekOnMonday: true, // 
    weekText: "      ",
    currentWeekText: "",
    weekCountText: `{week}`,
    weekFormat: "{year}{week}",
    nowText: "",
    todayText: "",
    showYearSkip: false,
    backText: "",
    weekMode: false,
    allowInValid: false, // 
    monthMap: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
    },
    yearTextFormatter: (val) => {
      return `${val}`;
    },
  };
  Component.register(DatePicker);
  class Group extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Group.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      this._addPropStyle("inline", "striped", "line", "nowrap");
      const { fields, fieldDefaults, value } = this.props;
      const children = [];
      for (let i = 0; i < fields.length; i++) {
        let fieldProps = extend(true, {}, fields[i]);
        if (isPlainObject(value)) {
          if (fieldProps.flatValue === true) {
            fieldProps.value = value;
          } else if (
            fieldProps.value === null ||
            fieldProps.value === undefined
          ) {
            fieldProps.value = value[fieldProps.name];
          }
        }
        fieldProps.__group = this;
        fieldProps = Component.extendProps(fieldDefaults, fieldProps);
        children.push(fieldProps);
      }
      this.setProps({ control: { children: children } });
      super._config();
    }
    getValue(options) {
      const { valueOptions } = this.props;
      options = extend(
        { ignoreDisabled: true, ignoreHidden: true, merge: false },
        valueOptions,
        options
      );
      const value = {};
      const len = this.fields.length;
      for (let i = 0; i < len; i++) {
        const field = this.fields[i];
        if (field.getValue && this._needHandleValue(field, options)) {
          const fieldValue = field.getValue(options);
          if (field.props.flatValue === true) {
            extend(value, fieldValue);
          } else {
            value[field.name] = fieldValue;
          }
        }
      }
      if (options.merge === true) {
        return extend(this.currentValue, value);
      }
      return value;
    }
    setValue(value, options) {
      options = extend(
        { ignoreDisabled: false, ignoreHidden: false, ignoreNone: false },
        options
      );
      if (options.ignoreNone === false) {
        const len = this.fields.length;
        for (let i = 0; i < len; i++) {
          const field = this.fields[i];
          if (field.setValue && this._needHandleValue(field, options)) {
            let fieldValue = value;
            if (field.props.flatValue === false) {
              if (isPlainObject(value)) {
                fieldValue = value[field.name];
              }
            }
            if (fieldValue === undefined) {
              fieldValue = null;
            }
            field.setValue(fieldValue);
          }
        }
      } else if (isPlainObject(value)) {
        Object.keys(value).forEach((key) => {
          const field = this.getField(key);
          if (field) {
            let fieldValue = value;
            if (field.props.flatValue === false) {
              if (isPlainObject(value)) {
                fieldValue = value[key];
              }
            }
            if (fieldValue === undefined) {
              fieldValue = null;
            }
            field.setValue(fieldValue);
          }
        });
      }
    }
    validate(options) {
      const invalids = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i],
          { disabled, hidden } = field.props;
        if (!(disabled || hidden) && field.validate) {
          const valResult = field.validate(options);
          if (valResult !== true) {
            invalids.push(field);
          }
        }
      }
      if (invalids.length > 0) {
        this.rootField.focusField(invalids[0]);
      }
      if (this.expandBtnRef && invalids.length > 0) {
        this.expand();
      }
      return invalids.length === 0;
    }
    getField(fieldName, options = {}) {
      if (options.byDom) {
        const name = fieldName.split(".").pop();
        return this.findField(name);
      }
      if (typeof fieldName === "string") {
        // Handle nested keys, e.g., "foo.bar" "foo[1].bar" "foo[key].bar"
        const parts = fieldName.split(".");
        let curField = this;
        if (parts.length) {
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            curField = curField._getSubField(part);
            if (!curField) {
              break;
            }
          }
        }
        return curField;
      }
    }
    findField(fieldName) {
      if (!this.element) {
        return null;
      }
      const el = this.element.querySelector(`[data-field-name="${fieldName}"]`);
      if (el && el.component) {
        return el.component;
      }
      return null;
    }
    appendField(fieldProps) {
      const { fieldDefaults } = this.props;
      this.props.fields.push(fieldProps);
      return this.control.appendChild(
        Component.extendProps(fieldDefaults, fieldProps, { __group: this })
      );
    }
    _getSubField(fieldName) {
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.name === fieldName) {
          return field;
        }
      }
      return null;
    }
    _clear() {
      this._resetValidStatus();
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.setValue) {
          field.setValue(null);
        }
      }
    }
    _needHandleValue(field, options) {
      const { disabled, hidden } = field.props;
      const { ignoreFields = [] } = options;
      if (field._autoName) {
        return false;
      }
      if (options.ignoreDisabled && disabled === true) {
        return false;
      }
      if (options.ignoreHidden && hidden === true) {
        return false;
      }
      if (ignoreFields.includes(field.name)) {
        return false;
      }
      return true;
    }
  }
  Group.defaults = { fields: [], fieldDefaults: { component: Field } };
  Component.register(Group);
  class DateRangePicker extends Group {
    constructor(props, ...mixins) {
      super(Component.extendProps(DateRangePicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      const that = this;
      const {
        format,
        allowClear,
        minDate,
        maxDate,
        yearRange,
        showTime,
        required,
        requiredMessage,
        rules,
        startPickerProps,
        endPickerProps,
        disabled,
        animate,
      } = this.props;
      this.setProps({
        inline: true,
        fields: [
          Object.assign(
            {
              component: "DatePicker",
              name: that.props.fieldName.start,
              ref: (c) => {
                that.startPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              animate,
              format,
              allowClear,
              minDate,
              maxDate,
              yearRange,
              showTime,
              required,
              requiredMessage,
              rules,
              disabled,
            },
            startPickerProps
          ),
          { component: "StaticText", value: "-" },
          Object.assign(
            {
              component: "DatePicker",
              name: that.props.fieldName.end,
              ref: (c) => {
                that.endPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              animate,
              format,
              allowClear,
              minDate,
              maxDate,
              yearRange,
              showTime,
              required,
              requiredMessage,
              rules,
              disabled,
            },
            endPickerProps
          ),
        ],
      });
      super._config();
    }
    triggerEdit() {
      this.startPicker.triggerEdit();
    }
    handleChange() {
      this.props.onChange && this._callHandler(this.props.onChange);
    }
    _getValueText() {
      const val = this.getValue();
      return `${
        val[this.props.fieldName.start]
      } - ${val[this.props.fieldName.end]}`;
    }
    checkRange(type) {
      const that = this;
      const active =
        type === this.props.fieldName.start ? this.startPicker : this.endPicker;
      const opposite =
        type === this.props.fieldName.start ? this.endPicker : this.startPicker;
      if (active.getValue()) {
        if (active.name === that.props.fieldName.start) {
          opposite.update({ minDate: active.getValue() });
          if (opposite.getValue() && opposite.getValue() < active.getValue()) {
            opposite.clearTime();
            opposite.focus();
            opposite.showPopup();
          } else if (!opposite.getValue()) {
            opposite.focus();
            that.props.autoPopupEnd && opposite.showPopup();
          }
        } else if (
          opposite.getValue() &&
          opposite.getValue() > active.getValue()
        ) {
          opposite.clearTime();
        }
      }
      if (active.getValue() && opposite.getValue()) {
        that.handleChange();
      }
    }
  }
  DateRangePicker.defaults = {
    format: "yyyy-MM-dd",
    disabledTime: null,
    minDate: null,
    maxDate: null,
    yearRange: [50, 20],
    showTime: false,
    allowClear: true,
    onChange: null,
    fieldName: { start: "start", end: "end" },
    autoPopupEnd: true,
    flatValue: true,
    required: false,
    requiredMessage: null,
    startPickerProps: { placeholder: "" },
    endPickerProps: { placeholder: "" },
  };
  Component.register(DateRangePicker);
  class Divider extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Divider.defaults, props), ...mixins);
    }
    _config() {
      // this._propStyleClasses = ['type','orientation','dashed','plain']
      const { orientation, classes, dashed, plain } = this.props;
      let { children = undefined } = this.props;
      const hasChildren = !!children;
      const orientationPrefix =
        orientation.length > 0 ? `-${orientation}` : orientation;
      children = children && {
        tag: "span",
        classes: { "nom-divider-inner-text": true },
        children,
      };
      this.setProps({
        classes: Object.assign(
          {
            [`nom-divider-with-text`]: hasChildren,
            [`nom-divider-with-text${orientationPrefix}`]: hasChildren,
            [`nom-divider-dashed`]: !!dashed,
            [`nom-divider-plain`]: !!plain,
          },
          classes
        ),
        attrs: { role: "separator" },
        children,
      });
    }
  }
  Divider.defaults = {
    type: "horizontal",
    orientation: "center", // dashed:true,
    // plan:true,
    // children:
  };
  Component.register(Divider);
  Object.defineProperty(Component.prototype, "$drawer", {
    get: function () {
      let cur = this;
      while (cur) {
        if (cur.__isDrawerContent === true) {
          return cur.drawer;
        }
        cur = cur.parent;
      }
      return null;
    },
  });
  var DrawerContentMixin = {
    _created: function () {
      this.drawer = this.parent.drawer;
      this.__isDrawerContent = true;
      this.parent.parent.drawerContent = this;
    },
    _config: function () {
      this.setProps({
        classes: {
          "nom-drawer-content": true,
          "nom-drawer-content-animate-show": this.drawer.props.animate,
        },
      });
    },
  };
  class DrawerDialog extends Component {
    constructor(props, ...mixins) {
      const defaults = { children: { component: Panel, uistyle: "plain" } };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      const drawer = (this.drawer = this.parent);
      const { content } = this.drawer.props;
      if (isString(content)) {
        this.drawer.element &&
          this.drawer.element.setAttribute("data-url", content);
        require([content], (contentConfig) => {
          let props = contentConfig;
          if (isFunction(props)) {
            const pNames = this.getParameterNames(props);
            if (pNames.length && pNames[0] === "{") {
              const args = drawer.props.args || {};
              props = contentConfig({ drawer: drawer, args: args });
              if (props.then) {
                props.then((result) => {
                  props = result;
                  props = Component.extendProps(
                    this._getDefaultPanelContent(props),
                    props
                  );
                  this.update({
                    children: n$1(null, props, null, [DrawerContentMixin]),
                  });
                });
              } else {
                props = Component.extendProps(
                  this._getDefaultPanelContent(props),
                  props
                );
                this.update({
                  children: n$1(null, props, null, [DrawerContentMixin]),
                });
              }
            } else {
              props = contentConfig.call(this, drawer);
              props = Component.extendProps(
                this._getDefaultPanelContent(props),
                props
              );
              this.update({
                children: n$1(null, props, null, [DrawerContentMixin]),
              });
            }
          }
        });
      }
    }
    _getDefaultPanelContent(contentProps) {
      const drawer = this.drawer;
      drawer.setProps({
        okText: contentProps.okText,
        onOk: contentProps.onOk,
        cancelText: contentProps.cancelText,
        onCancel: contentProps.onCancel,
        okButton: contentProps.okButton,
      });
      const {
        okText,
        cancelText,
        okButton = {},
        cancelButton = {},
      } = drawer.props;
      return {
        component: Panel,
        fit: true,
        uistyle: "plain",
        header: {
          caption: { title: drawer.props.title },
          nav: {},
          tools: [
            {
              component: "Button",
              icon: "close",
              styles: { border: "none" },
              onClick: function () {
                drawer.close();
              },
            },
          ],
        },
        footer: {
          children: {
            component: "Cols",
            items: [
              okButton !== false &&
                Component.extendProps(
                  {
                    component: "Button",
                    type: "primary",
                    text: okText,
                    onClick: () => {
                      drawer._handleOk();
                    },
                  },
                  okButton
                ),
              cancelButton !== false &&
                Component.extendProps(
                  {
                    component: "Button",
                    text: cancelText,
                    onClick: () => {
                      drawer._handleCancel();
                    },
                  },
                  cancelButton
                ),
            ],
          },
        },
      };
    }
    _config() {
      const { content, settle } = this.drawer.props;
      const { size } = this.props;
      if (isPlainObject(content)) {
        const extendContent = {};
        if (isFunction(content.footer)) {
          extendContent.footer = content.footer.call(this.drawer, this.drawer);
        }
        const contentProps = Component.extendProps(
          this._getDefaultPanelContent(content),
          content,
          extendContent
        );
        this.setProps({
          children: n$1(null, contentProps, null, [DrawerContentMixin]),
        });
      }
      if (size) {
        if (settle === "left" || settle === "right") {
          this.setProps({ attrs: { style: { width: size.width } } });
        } else {
          this.setProps({ attrs: { style: { height: size.height } } });
        }
      }
    }
    getParameterNames(fn) {
      const code = fn.toString();
      const result = code
        .slice(code.indexOf("(") + 1, code.indexOf(")"))
        .match(/([^\s,]+)/g);
      return result === null ? [] : result;
    }
  }
  Component.register(DrawerDialog);
  class Drawer extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Drawer.defaults, props), ...mixins);
    }
    _created() {
      this.relativeElements = [];
      this._scoped = true;
      this.bodyElem = document.body;
      this._onDocumentMousedown = this._onDocumentMousedown.bind(this);
    }
    _config() {
      this._propStyleClasses = ["size", "fit"];
      const {
        size,
        animate,
        settle,
        content,
        closeOnClickBackdrop,
        maskClosable,
      } = this.props;
      if (settle === "left" || settle === "right") {
        this.props.fit = true;
      }
      const _reference = this._getContainerElement();
      if (_reference !== document.body) {
        this.referenceElement = _reference;
        if (
          !_reference.style.position ||
          _reference.style.position === "static"
        ) {
          _reference.style.position = "relative";
        }
      }
      let sizeInfo = null;
      if (size && isPlainObject(size)) {
        sizeInfo = {
          width: this.getSizeInfo(size.width),
          height: this.getSizeInfo(size.height),
        };
      } else if (this.props.width || this.props.height) {
        sizeInfo = {
          width: this.getSizeInfo(this.props.width),
          height: this.getSizeInfo(this.props.height),
        };
      }
      if (isPlainObject(content) && !content.body) {
        this.props.content = {
          body: { children: content },
          footer: this.props.footer,
        };
      }
      this.setProps({
        classes: {
          "nom-drawer-absolute": _reference !== document.body,
          [`nom-drawer-${settle}`]: true,
          [`nom-drawer-animate-${settle}-show`]: animate,
        },
        children: [
          {
            classes: {
              "nom-drawer-backdrop": true,
              "nom-drawer-backdrop-animate-show": animate,
              "nom-drawer-backdrop-hidden":
                !this.props.showBackdrop || this.props.showMasker === false,
            },
            onClick: () => {
              (closeOnClickBackdrop || maskClosable) && this.close();
            },
          },
          { component: DrawerDialog, size: sizeInfo },
        ],
      });
    }
    _rendered() {
      this.addRel(this.element);
    }
    addRel(elem) {
      this.relativeElements.push(elem);
    }
    _show() {
      this.setzIndex();
      this.checkScrollbar();
      this.setScrollbar();
      this._docClickHandler();
    }
    _remove() {
      document.removeEventListener(
        "mousedown",
        this._onDocumentMousedown,
        false
      );
    }
    close(result) {
      const that = this;
      document.removeEventListener(
        "mousedown",
        this._onDocumentMousedown,
        false
      );
      if (!this.rendered) {
        return;
      }
      if (this.element === undefined) {
        return;
      }
      if (result === undefined) {
        result = that.returnValue;
      }
      let { drawerCount } = this.bodyElem;
      if (drawerCount) {
        drawerCount--;
        this.bodyElem.drawerCount = drawerCount;
        if (drawerCount === 0) {
          this.resetScrollbar();
        }
      }
      this._callHandler(this.props.onClose, { result: result });
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.remove();
    }
    animateHide() {
      if (!this.element) return false;
      this.drawerContent.addClass("nom-drawer-content-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.addClass("nom-drawer-backdrop-animate-hide");
        setTimeout(() => {
          if (!this.element) return false;
          this.remove();
        }, 90);
      }, 90);
    }
    _onDocumentMousedown(e) {
      for (let i = 0; i < this.relativeElements.length; i++) {
        const el = this.relativeElements[i];
        if (el === e.target || el.contains(e.target)) {
          return;
        }
      }
      const closestLayer = e.target.closest(".nom-layer");
      if (closestLayer !== null) {
        const idx = closestLayer.component._zIndex;
        if (idx < this._zIndex) {
          this.hide();
        }
      } else {
        this.hide();
      }
    }
    _docClickHandler() {
      if (this.props.closeOnClickOutside) {
        document.addEventListener(
          "mousedown",
          this._onDocumentMousedown,
          false
        );
      }
    }
    getSizeInfo(data) {
      if (!data) {
        return undefined;
      }
      return isNumeric(data) ? `${data}px` : data;
    }
    _getContainerElement() {
      let el = document.body;
      const { getContainer } = this.props;
      let _reference = getContainer;
      if (isFunction(_reference)) {
        _reference = _reference();
      }
      if (_reference instanceof Component && _reference.element) {
        el = _reference.element;
      } else if (_reference instanceof HTMLElement) {
        el = _reference;
      }
      return el;
    }
    setzIndex() {
      this.element.style.zIndex = getzIndex();
    }
    checkScrollbar() {
      const fullWindowWidth = window.innerWidth;
      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
      this.scrollbarWidth = positionTool.scrollbarWidth();
    }
    setScrollbar() {
      /* var bodyPad = parseInt((this.bodyElem.css('padding-right') || 0), 10);
          this.originalBodyPad = document.body.style.paddingRight || '';
          this.originalBodyOverflow = document.body.style.overflow || '';
          if (this.bodyIsOverflowing) {
              this.bodyElem.css('padding-right', bodyPad + this.scrollbarWidth);
          }
          this.bodyElem.css("overflow", "hidden");
          var drawerCount = this.bodyElem.data('drawerCount');
          if (drawerCount) {
              drawerCount++;
              this.bodyElem.data('drawerCount', drawerCount);
          }
          else {
              this.bodyElem.data('drawerCount', 1);
          } */
    }
    resetScrollbar() {
      /* this.bodyElem.css('padding-right', this.originalBodyPad);
          this.bodyElem.css('overflow', this.originalBodyOverflow);
          this.bodyElem.removeData('drawerCount'); */
    }
    _handleOk() {
      this._callHandler(this.props.onOk);
    }
    _handleCancel() {
      this._callHandler(this.props.onCancel);
    }
  }
  Drawer.defaults = {
    content: {},
    closeOnClickBackdrop: false,
    closeOnClickOutside: false,
    showBackdrop: true,
    okText: " ",
    cancelText: " ",
    settle: "right",
    onOk: (e) => {
      e.sender.close();
    },
    onCancel: (e) => {
      e.sender.close();
    },
    size: "small",
    centered: true,
  };
  Component.register(Drawer);
  class Dropdown extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Dropdown.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.onClick = this.props.onClick;
    }
    _config() {
      const that = this;
      const {
        items,
        triggerAction,
        split,
        text,
        type,
        size,
        menuClasses,
        icon,
      } = this.props;
      const children = [
        split && {
          component: "Button",
          text: text,
          icon,
          type: type,
          size: size,
          inline: type === "link",
          onClick: (args) => {
            that._callHandler(that.onClick);
            args.event.stopPropagation();
          },
        },
        {
          component: "Button",
          text: split ? null : that.props.text,
          icon: split ? null : icon,
          rightIcon: isString(that.props.rightIcon)
            ? that.props.rightIcon
            : {
                component: "Flex",
                classes: { "nom-dropdown-right-icon-group": true },
                items: that.props.rightIcon.map((n) => {
                  return { component: "Icon", type: n };
                }),
              },
          type: type,
          size: size,
          inline: type === "link",
          popup: {
            triggerAction: triggerAction,
            classes: { "nom-dropdown-popup": true },
            ref: (c) => {
              that.popup = c;
            },
            _rendered() {
              that.props.animate && that.animateInit(this);
            },
            children: {
              component: "Menu",
              classes: menuClasses,
              itemDefaults: Object.assign({}, this.props.itemDefaults, {
                size: size,
              }),
              items: items,
            },
            onClick: (args) => {
              if (that.props.animate) {
                that.animateHide(args);
              } else {
                args.sender.hide();
              }
            },
            onShow: () => {
              that.element.classList.add("nom-dropdown-opened");
            },
            onHide: () => {
              that.element.classList.remove("nom-dropdown-opened");
            },
          },
        },
      ];
      this.setProps({
        onClick: null,
        children: children,
        classes: { "nom-split-button": this.props.split },
      });
      super._config();
    }
    animateInit(that) {
      if (!that.element) return false;
      if (that.element.getAttribute("offset-y") !== "0") {
        this.props.animateName = "bottom";
      } else {
        this.props.animateName = "top";
      }
      that.addClass([`nom-dropdown-animate-${this.props.animateName}-show`]);
    }
    animateHide(that) {
      if (!this.popup.element) return false;
      this.popup.removeClass([
        `nom-dropdown-animate-${this.props.animateName}-show`,
      ]);
      if (this.popup.element.getAttribute("offset-y") !== "0") {
        this.props.animateName = "bottom";
      } else {
        this.props.animateName = "top";
      }
      this.popup.addClass([
        `nom-dropdown-animate-${this.props.animateName}-hide`,
      ]);
      setTimeout(() => {
        that.sender.hide();
        if (!this.popup.element) return false;
        this.popup.removeClass([
          `nom-dropdown-animate-${this.props.animateName}-hide`,
        ]);
        this.popup.addClass([
          `nom-dropdown-animate-${this.props.animateName}-show`,
        ]);
      }, 160);
    }
  }
  Dropdown.defaults = {
    animateName: "top",
    tag: "span",
    triggerAction: "click",
    rightIcon: ["down", "up"],
    split: false,
    onClick: null,
    items: [],
    size: null,
  };
  Component.register(Dropdown);
  class Ellipsis extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Ellipsis.defaults, props), ...mixins);
    }
    _config() {
      this.setProps({
        children: {
          classes: {
            "nom-ellipsis-inner": true,
            "nom-ellipsis-nowrap":
              this.props.line === null || this.props.line === 1,
          },
          attrs: {
            title:
              this.props.showTitle &&
              (isString(this.props.text) || isNumeric(this.props.text))
                ? this.props.text
                : null,
            style: {
              "-webkit-line-clamp": this.props.line,
              display: this.props.line > 1 ? "-webkit-box" : "",
            },
          },
          children: this.props.text ? this.props.text : this.props.children,
        },
      });
    }
  }
  Ellipsis.defaults = {
    text: null,
    showTitle: true,
    line: null,
    fitContent: false,
  };
  Component.register(Ellipsis);
  class Form extends Group {
    constructor(props, ...mixins) {
      super(Component.extendProps(Form.defaults, props), ...mixins);
    }
  }
  Form.defaults = { labelAlign: "top" };
  Component.register(Form);
  class Spinner extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Spinner.defaults, props), ...mixins);
    }
    _config() {
      const { spinning } = this.props;
      this.setProps({ classes: { "p-type-border": spinning } });
    }
  }
  Spinner.defaults = { spinning: true };
  Component.register(Spinner);
  class FailIcon extends Component {
    constructor(props, ...mixins) {
      const defaults = {};
      super(
        Component.extendProps(defaults, FailIcon.defaults, props),
        ...mixins
      );
    }
    _config() {
      this.setProps({
        classes: { "nom-loading-icon": true, "status-fail": true },
        children: `#<svg width="2rem" height="2rem" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> <circle cx="50" cy="50" r="40" stroke="var(--nom-color-danger)" stroke-width="6" fill="none" stroke-dasharray="251.2 251.2" stroke-dashoffset="251.2"><animate attributeName="stroke-dashoffset" from="251.2" to="0" dur="0.4s" fill="freeze" /></circle><path d="M30,30 L70,70" stroke="var(--nom-color-danger)" stroke-width="6" fill="none" stroke-dasharray="60" stroke-dashoffset="60" opacity="0"><animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.3s" begin="0.4s" fill="freeze" /><animate attributeName="opacity" from="0" to="1" dur="0.3s" begin="0.4s" fill="freeze" /></path><path d="M70,30 L30,70" stroke="var(--nom-color-danger)" stroke-width="6" fill="none" stroke-dasharray="60" stroke-dashoffset="60" opacity="0"><animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.3s" begin="0.7s" fill="freeze" /><animate attributeName="opacity" from="0" to="1" dur="0.3s" begin="0.7s" fill="freeze" /></path></svg>`,
      });
    }
  }
  FailIcon.defaults = {};
  Component.register(FailIcon);
  class SuccessIcon extends Component {
    constructor(props, ...mixins) {
      const defaults = {};
      super(
        Component.extendProps(defaults, SuccessIcon.defaults, props),
        ...mixins
      );
    }
    _config() {
      this.setProps({
        classes: { "nom-loading-icon": true, "status-success": true },
        children: `#<svg width="2rem" height="2rem" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"> <!--  --> <circle cx="50" cy="50" r="40" stroke="var(--nom-color-success)" stroke-width="6" fill="none" stroke-dasharray="251.2 251.2" stroke-dashoffset="251.2"> <animate attributeName="stroke-dashoffset" from="251.2" to="0" dur="0.4s" fill="freeze" /> </circle> <path d="M25,50 L45,70 L75,35" stroke="var(--nom-color-success)" stroke-width="6" fill="none" stroke-dasharray="100" stroke-dashoffset="100" opacity="0"> <animate attributeName="stroke-dashoffset" from="100" to="0" dur="0.3s" begin="0.4s" fill="freeze" /> <animate attributeName="opacity" from="1" to="1" dur="0.6s" begin="0.4s" fill="freeze" /> </path> </svg>`,
      });
    }
  }
  SuccessIcon.defaults = {};
  Component.register(SuccessIcon);
  class Loading extends Layer {
    constructor(props, ...mixins) {
      const defaults = { container: document.body };
      super(
        Component.extendProps(defaults, Loading.defaults, props),
        ...mixins
      );
    }
    _create() {
      this.setProps({
        reference: this.props.container,
        alignTo: this.getElement(this.props.container),
      });
    }
    _config() {
      this.setProps({
        children: {
          ref: (c) => {
            this.iconRef = c;
          },
          children: this.props.noSpinner ? "" : { component: Spinner },
        },
        onClick({ event }) {
          event.stopPropagation();
        },
      });
      this.referenceElement.classList.add("nom-loading-container");
      super._config();
    }
    _rendered() {
      if (this.props.noSpinner && this.firstRender) {
        this.close({ type: "success" });
      }
      super._rendered();
    }
    _remove() {
      this.referenceElement &&
        this.referenceElement.classList.remove("nom-loading-container");
      super._remove();
    }
    close(args = {}) {
      const { type } = args;
      if (!type) {
        this.remove();
      } else {
        if (type === "fail" || type === "danger") {
          this.iconRef.update({ children: { component: FailIcon } });
        } else if (type === "success") {
          this.iconRef.update({ children: { component: SuccessIcon } });
        }
        this.element.classList.add("nom-loading-animate-hide");
        setTimeout(() => {
          this.remove();
        }, 3000);
      }
    }
    static success(options = {}) {
      new nomui.Loading(Object.assign({}, options, { noSpinner: true }));
    }
  }
  Loading.defaults = { align: "center", backdrop: true, collision: "none" };
  Component.register(Loading);
  class Td extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "td", data: null, column: {} };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tr = this.parent;
      this.table = this.tr.table;
      this.col = this.table.colRefs[this.props.column.field];
      this.col.tdRefs[this.key] = this;
      this.tr.tdRefs[this.props.column.field] = this;
    }
    _config() {
      this.props.children = "";
      const { level, isLeaf } = this.tr.props;
      const { column } = this.props;
      const { treeConfig } = this.table.props;
      const { parentField } = treeConfig;
      const { grid } = this.table;
      const { editable, excelMode } = grid?.props || {};
      if (excelMode && excelMode.alwaysEdit) {
        this.props.editMode = true;
      }
      let cellDisabled = false;
      if (
        editable &&
        editable.isCellEditable &&
        editable.isCellEditable({
          rowData: this.tr.props.data,
          field: this.props.column.field,
        }) === false
      ) {
        cellDisabled = true;
      }
      if (
        excelMode &&
        excelMode.isCellEditable &&
        excelMode.isCellEditable({
          rowData: this.tr.props.data,
          field: this.props.column.field,
        }) === false
      ) {
        cellDisabled = true;
      } // 
      if (grid) {
        const { keyField } = grid.props;
        grid.nodeList[`__key${this.tr.props.data[keyField]}`] = this.tr;
        this.tr.childrenNodes = {};
        if (this.tr.props.parentKey || this.tr.props.data[parentField]) {
          const key =
            this.tr.props.parentKey || this.tr.props.data[parentField];
          this.tr.parentNode = grid.nodeList[`__key${key}`];
        }
        if (this.tr.parentNode) {
          if (this.tr.props.data[keyField]) {
            this.tr.parentNode.childrenNodes[
              `__key${this.tr.props.data[keyField]}`
            ] = this.tr;
          }
        }
      }
      let spanProps = null;
      let children = this.props.data;
      const isEllipsis =
        ((this.table.props.ellipsis === "both" ||
          this.table.props.ellipsis === "body") &&
          this.props.column.ellipsis !== false) ||
        this.props.column.ellipsis === true;
      if (column.type === "checker") {
        children = this._renderCombinedChecker({
          row: this.tr,
          rowData: this.tr.props.data,
          index: this.tr.props.index,
        });
      }
      if (column.type === "order") {
        children = this._renderRowOrder({ index: this.tr.props.index });
      }
      if (column.type === "checker&order") {
        children = this._renderCombinedChecker({
          row: this.tr,
          rowData: this.tr.props.data,
          index: this.tr.props.index,
          renderOrder: true,
        });
      }
      if (
        column.isChecker &&
        column.field === "nom-grid-row-checker" &&
        this.table.hasGrid &&
        this.table.grid.props.rowCheckable &&
        !this.table.grid.props.rowCheckable.checkboxOnNodeColumn
      ) {
        children = this._renderRowChecker({
          row: this.tr,
          rowData: this.tr.props.data,
          index: this.tr.props.index,
        });
      }
      if (
        (this.tr.props.editMode || this.props.editMode) &&
        !cellDisabled &&
        column.editRender
      ) {
        const propsMinxin = {
          ref: (c) => {
            this.editor = c;
          },
          invalidTip: {
            align: "bottom",
            reference: document.body,
            ignoreMouseEvent: true,
          },
          compact: true,
        };
        if (this.table.hasGrid) {
          if (
            (grid.props.excelMode && !grid.props.excelMode.alwaysEdit) ||
            grid.props.editable
          )
            propsMinxin.variant = "borderless";
          if (column.immediateChange) {
            propsMinxin.onValueChange = () => {
              this.endEdit();
              grid.lastEditTd = null;
            };
          }
        }
        children = Object.assign(
          {},
          column.editRender({
            cell: this,
            row: this.tr,
            talbe: this.table,
            cellData: this.props.data,
            rowData: this.tr.props.data,
            index: this.tr.props.index,
          }),
          propsMinxin
        );
      } else if (isFunction(column.cellRender)) {
        children = column.cellRender({
          cell: this,
          row: this.tr,
          talbe: this.table,
          cellData: this.props.data,
          rowData: this.tr.props.data,
          index: this.tr.props.index,
        });
      } else if (isFunction(this.props.column.render)) {
        children = this.props.column.render.call(
          this,
          this.props.data,
          this.props.record,
          this.tr.props.index
        );
      } // if (isEllipsis && !this.props.column.autoWidth) {
      //   children = {
      //     component: 'Ellipsis',
      //     // fitContent: true,
      //     text: children
      //   }
      // }
      if (isFunction(column.cellMerge)) {
        spanProps = column.cellMerge({
          cell: this,
          row: this.tr,
          talbe: this.table,
          cellData: this.props.data,
          rowData: this.tr.props.data,
          index: this.tr.props.index,
        });
      }
      const isTreeNodeColumn =
        treeConfig.treeNodeColumn && column.field === treeConfig.treeNodeColumn;
      if (isTreeNodeColumn) {
        this.setProps({
          expanded:
            treeConfig.initExpandLevel === -1 ||
            treeConfig.initExpandLevel > level,
          expandable: {
            byClick: true,
            target: () => {
              return this.tr.props.childTrs;
            },
            byIndicator: treeConfig.byIndicator,
            indicator: {
              component: "Icon",
              classes: { "nom-tr-expand-indicator": true },
              expandable: {
                expandedProps: { type: "sort-down" },
                collapsedProps: { type: "sort-right" },
              },
            },
          },
        });
        if (isPlainObject(treeConfig.indicator)) {
          this.setProps({ expandable: { indicator: treeConfig.indicator } });
        }
        if (isLeaf) {
          this.setProps({
            expandable: {
              indicator: { attrs: { style: { visibility: "hidden" } } },
            },
          });
        }
        children = {
          classes: { "nom-grid-td-cell-tree": true },
          children: [
            {
              tag: "span",
              attrs: {
                style: { paddingLeft: `${level * treeConfig.indentSize}px` },
              },
            },
            this.getExpandableIndicatorProps(),
            this.table.hasGrid &&
              this.table.grid.props.rowCheckable &&
              this.table.grid.props.rowCheckable.checkboxOnNodeColumn &&
              this._renderCombinedChecker({
                row: this.tr,
                rowData: this.tr.props.data,
                index: this.tr.props.index,
              }),
            {
              tag: "span",
              classes: { "nom-tree-grid-td": true },
              children: children,
            },
          ],
        };
      }
      if (column.toolbar) {
        if (column.toolbar.align === "left") {
          children = {
            classes: { "nom-grid-column-with-tools": true },
            align: "center",
            component: "Flex",
            cols: [
              {
                classes: {
                  "nom-grid-column-tools": true,
                  "nom-grid-column-tools-hover": column.toolbar.hover,
                  "nom-grid-column-tools-hide": !(
                    this.props.column.toolbar.placement === "body" ||
                    this.props.column.toolbar.placement === "both"
                  ),
                },
                children: Object.assign(
                  { forceVisible: true },
                  this.props.column.toolbar.render({
                    cell: this,
                    row: this.tr,
                    cellData: this.props.data,
                    rowData: this.tr.props.data,
                    index: this.tr.props.index,
                  })
                ),
              },
              { children: children },
            ],
          };
        } else if (column.toolbar.align === "right") {
          children = {
            align: "center",
            component: "Flex",
            cols: [
              {
                classes: { "nom-grid-td-cell-ellipsis": true },
                grow: true,
                children: children,
              },
              {
                classes: {
                  "nom-grid-column-tools": true,
                  "nom-grid-column-tools-hover": column.toolbar.hover,
                  "nom-grid-column-tools-hide": !(
                    this.props.column.toolbar.placement === "body" ||
                    this.props.column.toolbar.placement === "both"
                  ),
                },
                children: Object.assign(
                  { forceVisible: true },
                  this.props.column.toolbar.render({
                    cell: this,
                    row: this.tr,
                    cellData: this.props.data,
                    rowData: this.tr.props.data,
                    index: this.tr.props.index,
                  })
                ),
              },
            ],
          };
        } else {
          children = {
            align: "center",
            component: "Flex",
            cols: [
              {
                classes: { "nom-grid-td-cell-ellipsis": true },
                children: children,
              },
              {
                classes: {
                  "nom-grid-column-tools": true,
                  "nom-grid-column-tools-hover": column.toolbar.hover,
                  "nom-grid-column-tools-hide": !(
                    this.props.column.toolbar.placement === "body" ||
                    this.props.column.toolbar.placement === "both"
                  ),
                },
                children: Object.assign(
                  { forceVisible: true },
                  this.props.column.toolbar.render({
                    cell: this,
                    row: this.tr,
                    cellData: this.props.data,
                    rowData: this.tr.props.data,
                    index: this.tr.props.index,
                  })
                ),
              },
            ],
          };
        }
      }
      const colSpan =
        spanProps &&
        spanProps.colSpan !== null &&
        spanProps.colSpan !== undefined
          ? spanProps.colSpan
          : this.props.column.colSpan;
      const rowSpan =
        spanProps &&
        spanProps.rowSpan !== null &&
        spanProps.rowSpan !== undefined
          ? spanProps.rowSpan
          : this.props.column.rowSpan;
      if (rowSpan > 1) {
        this.table.hasRowGroup = true;
      }
      const showTitle =
        (((this.table.hasGrid && this.table.grid.props.showTitle) ||
          this.table.props.showTitle) &&
          this.props.column.showTitle !== false) ||
        this.props.column.showTitle === true;
      let columnAlign = this.table.hasGrid
        ? this.table.grid.props.columnAlign
        : "left";
      if (
        column.isChecker &&
        !column.toolbar &&
        this.table.grid.props.rowCheckable.align
      ) {
        columnAlign = this.table.grid.props.rowCheckable.align;
      }
      const isExcelMode = this.table.hasGrid && this.table.grid.props.excelMode;
      children = {
        tag: "span",
        classes: {
          "nom-table-cell-content": !!column.cellRender || !!column.render,
          "nom-table-cell-content-ellipsis-wrapper":
            isEllipsis && !column.autoWidth,
          "nom-table-cell-static-ellipsis":
            isEllipsis &&
            (nomui.utils.isString(children) || nomui.utils.isNumeric(children)),
        },
        children,
      };
      if (this.table.hasGrid && this.table.grid.props.editable) {
        children = {
          classes: {
            "nom-td-editable-inner": true,
            "nom-td-auto-width": column.autoWidth,
            "nom-td-edit-disabled": cellDisabled,
          },
          children: [
            { grow: true, children },
            {
              component: "Icon",
              classes: { "nom-grid-td-edit-trigger": true },
              hidden:
                (this.table.grid.props.editable &&
                  this.table.grid.props.editable.onlyleaf &&
                  !isLeaf) ||
                this.table.parent.componentType === "GridFooter",
              type: this._getEditIconType(),
              onClick: ({ event }) => {
                event.stopPropagation();
                if (
                  grid.lastEditTd &&
                  grid.lastEditTd.props &&
                  grid.lastEditTd !== this
                ) {
                  grid.lastEditTd.endEdit();
                }
                if (grid.lastEditTd && grid.lastEditTd === this) {
                  return;
                }
                if (column.editRender) {
                  if (!cellDisabled) {
                    this.edit({ type: "editable" });
                    setTimeout(() => {
                      this.editor.triggerEdit();
                    }, 200);
                  }
                  grid.lastEditTd = this;
                } else {
                  grid.lastEditTd = null;
                }
              },
            },
          ],
        };
      }
      if (isExcelMode) {
        children = {
          tag: "span",
          classes: {
            "nom-td-excel-mode-inner": true,
            "nom-td-auto-width": column.autoWidth,
          },
          children,
        };
        this.setProps({
          classes: {
            "nom-td-excel-mode": true,
            "nom-td-edit-disabled": cellDisabled,
          },
          onClick: ({ event }) => {
            event.stopPropagation();
            grid.props.onRowClick &&
              !this.props.editMode &&
              grid._callHandler(grid.props.onRowClick, {
                event,
                rowData: this.tr.props.data,
              });
            if (
              grid.lastEditTd &&
              grid.lastEditTd.props &&
              grid.lastEditTd !== this
            ) {
              grid.lastEditTd.endEdit();
            }
            if (grid.lastEditTd && grid.lastEditTd === this) {
              return;
            }
            if (column.editRender) {
              if (!cellDisabled) {
                this.edit({ type: "excel" });
                setTimeout(() => {
                  this.editor.triggerEdit();
                }, 200);
              }
              grid.lastEditTd = this;
            } else {
              grid.lastEditTd = null;
            }
          },
        });
      } else if (this.table.hasGrid && this.table.grid.props.editable) {
        this.setProps({
          classes: { "nom-td-editable": true },
          onClick: ({ event }) => {
            event.stopPropagation();
            grid.props.onRowClick &&
              !this.props.editMode &&
              grid._callHandler(grid.props.onRowClick, {
                event,
                rowData: this.tr.props.data,
              });
            if (
              grid.lastEditTd &&
              grid.lastEditTd.props &&
              grid.lastEditTd !== this
            ) {
              grid.lastEditTd.endEdit();
            }
            if (grid.lastEditTd && grid.lastEditTd === this) {
              return;
            }
            grid.lastEditTd = null;
          },
        });
      }
      this.setProps({
        children: children,
        attrs: {
          colspan: colSpan,
          rowspan: rowSpan,
          align: this.props.column.align || columnAlign,
          "data-field": this.props.column.field,
          title: this._getAttrTitle(children, isEllipsis, showTitle),
        },
        hidden: colSpan === 0 || rowSpan === 0,
        classes: {
          "nom-td-tree-node": isTreeNodeColumn,
          "nom-td-tree-node-leaf": isTreeNodeColumn && isLeaf,
          "nom-table-fixed-left": this.props.column.fixed === "left",
          "nom-table-fixed-left-last": this.props.column.lastLeft,
          "nom-table-fixed-right": this.props.column.fixed === "right",
          "nom-table-fixed-right-first": this.props.column.firstRight,
          "nom-table-ellipsis": isEllipsis,
          "nom-table-checker": this.props.column.isChecker,
          "nom-table-checker-with-toolbar":
            !!this.props.column.toolbar && this.props.column.isChecker,
          "nom-td-always-edit": excelMode && excelMode.alwaysEdit,
        },
      });
    }
    _getAttrTitle(children, isEllipsis, showTitle) {
      // isEllipsis = truespantitlechildren.children
      if (isEllipsis || showTitle) {
        let _title = "";
        if (isEllipsis && isPlainObject(children) && children.children) {
          _title = children.children;
        } else {
          _title = children;
        }
        if (isString(_title) || isNumeric(_title)) {
          // # children html
          return _title[0] === "#" ? null : _title;
        }
      }
      return null;
    }
    _rendered() {
      this.props.column.autoWidth && this._parseTdWidth();
      const fixed = this.props.column.fixed;
      if (fixed && !this._skipFixed) {
        this._setTdsPosition();
      } // if (this.props.column.toolbar && this.props.column.toolbar.align === 'left') {
      //   this._fixThToolsPosition()
      // }
    }
    _renderRowOrder({ index }) {
      return index + 1;
    }
    _renderRowChecker({ row, rowData, index }) {
      const grid = this.table.grid;
      const { rowCheckable } = grid.props;
      let normalizedRowCheckable = rowCheckable;
      if (!isPlainObject(rowCheckable)) {
        normalizedRowCheckable = {};
      }
      const { checkedRowKeys = [], checkboxRender } = normalizedRowCheckable;
      const checkedRowKeysHash = {};
      checkedRowKeys.forEach((rowKey) => {
        checkedRowKeysHash[rowKey] = true;
      });
      let _checkboxProps = {}; //  checkboxRender  props: {hidden, value, disabled}
      if (checkboxRender && isFunction(checkboxRender)) {
        _checkboxProps = checkboxRender({ row, rowData, index });
      } //  checkbox
      _checkboxProps.value =
        _checkboxProps.value || checkedRowKeysHash[row.key] === true;
      if (_checkboxProps.value === true) {
        row._check();
      }
      if (checkedRowKeysHash[row.key] === true || _checkboxProps.value) {
        grid.checkedRowRefs[grid.getKeyValue(rowData)] = row;
      } // const { keyField } = grid.props
      // const { parentField } = grid.props.treeConfig
      // grid.nodeList[`__key${rowData[keyField]}`] = row
      // row.childrenNodes = {}
      // if (rowData[parentField]) {
      //   row.parentNode = grid.nodeList[`__key${rowData[parentField]}`]
      // }
      // if (row.parentNode) {
      //   if (rowData[keyField]) {
      //     row.parentNode.childrenNodes[`__key${rowData[keyField]}`] = row
      //   }
      // }
      if (rowCheckable.type === "checker&order") {
        return {
          classes: { "nom-grid-checker-and-order": true },
          children: [
            {
              component: "Checkbox",
              classes: { "nom-grid-checkbox": true },
              plain: true,
              _created: (inst) => {
                row._checkboxRef = inst;
              },
              _config() {
                this.setProps(_checkboxProps);
              },
              attrs: { "data-key": row.key },
              onValueChange: (args) => {
                if (args.newValue === true) {
                  grid.check(row);
                } else {
                  grid.uncheck(row);
                }
                grid.changeCheckAllState();
              },
              onClick: ({ event }) => {
                event.stopPropagation();
              },
            },
            { classes: { "nom-grid-order-text": true }, children: index + 1 },
          ],
        };
      }
      return {
        component: "Checkbox",
        classes: { "nom-grid-checkbox": true },
        plain: true,
        _created: (inst) => {
          row._checkboxRef = inst;
        },
        _config() {
          this.setProps(_checkboxProps);
        },
        attrs: { "data-key": row.key },
        onValueChange: (args) => {
          if (args.newValue === true) {
            grid.check(row);
          } else {
            grid.uncheck(row);
          }
          grid.changeCheckAllState();
        },
      };
    }
    _renderCombinedChecker({ row, rowData, index, renderOrder }) {
      const grid = this.table.grid;
      const { rowCheckable } = grid.props;
      let normalizedRowCheckable = rowCheckable;
      if (!isPlainObject(rowCheckable)) {
        normalizedRowCheckable = {};
      }
      const { checkedRowKeys = [], checkboxRender } = normalizedRowCheckable;
      const checkedRowKeysHash = {};
      checkedRowKeys.forEach((rowKey) => {
        checkedRowKeysHash[rowKey] = true;
      });
      let _checkboxProps = {}; //  checkboxRender  props: {hidden, value, disabled}
      if (checkboxRender && isFunction(checkboxRender)) {
        _checkboxProps = checkboxRender({ row, rowData, index });
      } //  checkbox
      _checkboxProps.value =
        _checkboxProps.value || checkedRowKeysHash[row.key] === true;
      if (checkedRowKeysHash[row.key] === true || _checkboxProps.value) {
        grid.checkedRowRefs[grid.getKeyValue(rowData)] = row;
      }
      if (renderOrder) {
        return {
          classes: { "nom-grid-checker-and-order": true },
          children: [
            {
              component: "Checkbox",
              classes: { "nom-grid-checkbox": true },
              onClick: ({ event }) => {
                event.stopPropagation();
              },
              plain: true,
              _created: (inst) => {
                row._checkboxRef = inst;
              },
              _config() {
                this.setProps(_checkboxProps);
              },
              attrs: { "data-key": row.key, style: { paddingRight: ".25rem" } },
              onValueChange: (args) => {
                if (args.newValue === true) {
                  grid.check(row);
                } else {
                  grid.uncheck(row);
                }
                grid._checkboxAllRef && grid.changeCheckAllState();
              },
            },
            { classes: { "nom-grid-order-text": true }, children: index + 1 },
          ],
        };
      }
      return {
        component: "Checkbox",
        classes: { "nom-grid-checkbox": true },
        plain: true,
        _created: (inst) => {
          row._checkboxRef = inst;
        },
        _config() {
          this.setProps(_checkboxProps);
        },
        onClick: ({ event }) => {
          event.stopPropagation();
        },
        attrs: { "data-key": row.key, style: { paddingRight: ".25rem" } },
        onValueChange: (args) => {
          if (args.newValue === true) {
            grid.check(row);
          } else {
            grid.uncheck(row);
          }
          grid._checkboxAllRef && grid.changeCheckAllState();
        },
      };
    }
    _setTdsPosition() {
      const fixed = this.props.column.fixed;
      const el = this.element;
      const parentEl = this.parent.element;
      if (fixed === "left") {
        this._stickyPos = el.offsetLeft;
      } else if (fixed === "right") {
        this._stickyPos =
          parentEl.clientWidth -
          el.offsetLeft -
          el.offsetWidth -
          this.table.grid.props.scrollbarWidth;
      }
      const addjustWidth =
        fixed === "right" ? this.table.grid.props.scrollbarWidth : 0;
      this._stickyPos += addjustWidth;
      this._setStyle({ [fixed]: `${this._stickyPos}px` });
    }
    _parseTdWidth() {
      let tdWidth = 0; // Tdpadding 10+10, 1pxbuffer
      let tdPaddingWidth = 21; // , padding-left: 15
      if (this.props.column.firstRight) tdPaddingWidth += 5; //  && th padding-right: 40
      const needRightPadding =
        !!this.table.grid.props.columnsCustomizable &&
        this.props.column.lastRight;
      Array.from(this.element.children).forEach((child) => {
        const { marginLeft, marginRight } = getStyle(child);
        tdWidth +=
          Math.max(child.offsetWidth, child.scrollWidth) +
          this._parseCssNumber(marginLeft) +
          this._parseCssNumber(marginRight);
      });
      if (this.table.hasGrid) {
        let maxTdWidth = tdWidth + tdPaddingWidth; // fix: td  
        maxTdWidth =
          maxTdWidth < 80 && needRightPadding ? maxTdWidth + 30 : maxTdWidth; // header,body,footer
        this.table.grid.setAllTableColMaxTdWidth({
          field: this.props.column.field,
          maxTdWidth,
        });
      } else {
        this.col.setMaxTdWidth(this.element.offsetWidth + tdPaddingWidth);
      }
    }
    _fixThToolsPosition() {
      const w = this.element.querySelector(".nom-grid-column-tools")
        .offsetWidth;
      const f = this.props.column.field;
      const target = this.table.grid.header.element
        .querySelector(`thead [data-field="${f}"]`)
        .querySelector(".nom-grid-column-th-tools");
      if (target) target.style.width = `${w}px`;
    }
    /**
     * css
     * @param {*} str 12px
     * @returns 12
     */ _parseCssNumber(str) {
      return +str.match(/\d+/g);
    }
    _expand() {
      this.tr._onExpand();
    }
    _collapse() {
      this.tr._onCollapse();
    }
    _getEditIconType() {
      const { column } = this.props;
      const { editRender } = column;
      if (!editRender) {
        return null;
      }
      const regex = /component:\s*'(\w+)'/;
      const match = editRender.toString().match(regex);
      const iconMap = {
        AutoComplete: "down",
        Cascader: "down",
        Checkbox: "edit",
        CheckboxList: "edit",
        CheckboxTree: "edit",
        ColorPicker: "down",
        DatePicker: "calendar",
        DateRangePicker: "calendar",
        Field: "edit",
        Form: "edit",
        Group: "edit",
        GroupGrid: "edit",
        GroupTree: "edit",
        GroupList: "edit",
        IconPicker: "down",
        ListSetter: "edit",
        MultilineTextbox: "edit",
        Numberbox: "edit",
        NumberInput: "edit",
        PartialDatePicker: "calendar",
        PartialDateRangePicker: "calendar",
        Password: "edit",
        RadioList: "edit",
        Rate: "edit",
        Select: "down",
        Slider: "edit",
        StaticText: "edit",
        Switch: "edit",
        Textbox: "edit",
        TimePicker: "clock",
        TimeRangePicker: "clock",
        Transfer: "edit",
        TreeSelect: "down",
        Uploader: "upload",
        Upload: "upload",
      };
      return column.editorIcon || iconMap[match[1]] || "edit";
    }
    edit({ type = "excel" }) {
      this._skipFixed = true;
      this.update({
        editMode: true,
        classes: {
          "nom-td-excel-mode-active": type === "excel",
          "nom-td-editable-active": type === "editable",
        },
      });
      this._skipFixed = false;
      this.editor.validate();
    }
    endEdit(options) {
      if (!this.props.editMode || !this.editor) {
        return;
      }
      if (!options) {
        options = { ignoreChange: false };
      }
      if (options.ignoreChange !== true) {
        this._updateTdData();
      }
      this._skipFixed = true;
      this.update({
        editMode: false,
        classes: {
          "nom-td-excel-mode-active": false,
          "nom-td-editable-active": false,
        },
      });
      this._skipFixed = false;
      if (this.table.grid.props.summary) {
        this.table.grid.updateSummary();
      }
    }
    saveEditData() {
      this._updateTdData();
    }
    _updateTdData() {
      if (!this.editor.validate()) {
        this.table.grid.props.editable.onValidateFailed &&
          this.table.grid._callHandler(
            this.table.grid.props.editable.onValidateFailed,
            { field: this.editor, value: this.editor.getValue() }
          );
        this.table.grid.props.excelMode.onValidateFailed &&
          this.table.grid._callHandler(
            this.table.grid.props.excelMode.onValidateFailed,
            { field: this.editor, value: this.editor.getValue() }
          );
        return;
      }
      const newData = this.editor.getValue();
      if (!deepEqual(this.props.data, newData)) {
        const oldData = clone(this.props.data);
        this.props.data = newData;
        const { data } = this.tr.props;
        const field = this.props.column.field;
        data[field] = newData;
        const grid = this.table.grid;
        if (grid.props.data.length) {
          for (let i = 0; i < grid.props.data.length; i++) {
            if (
              grid.props.data[i][grid.props.keyField] ===
              data[grid.props.keyField]
            ) {
              grid.props.data[i] = data;
            }
          }
        }
        grid._processModifedRows(data[grid.props.keyField]);
        this._onCellValueChange({ newValue: newData, oldValue: oldData });
      }
    }
    _onCellValueChange({ newValue, oldValue }) {
      this.table.grid.props.editable.onCellValueChange &&
        this.table.grid._callHandler(
          this.table.grid.props.editable.onCellValueChange,
          {
            newValue,
            oldValue,
            field: this.props.column.field,
            rowKey: this.tr.props.data[this.table.grid.props.keyField],
            cell: this,
          }
        );
      this.table.grid.props.excelMode.onCellValueChange &&
        this.table.grid._callHandler(
          this.table.grid.props.excelMode.onCellValueChange,
          {
            newValue,
            oldValue,
            field: this.props.column.field,
            rowKey: this.tr.props.data[this.table.grid.props.keyField],
            cell: this,
          }
        );
    }
  }
  Component.register(Td);
  class ExpandedTrTd extends Td {
    constructor(props, ...mixins) {
      const defaults = { tag: "td", data: null, column: {} };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tr = this.parent;
      this.table = this.parent.table;
    }
    _config() {}
  }
  Component.register(ExpandedTrTd);
  class ExpandedTr extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "tr", data: {} };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tbody = this.parent;
      this.table = this.tbody.table;
      this.grid = this.table.grid;
      this.hasContent = true;
    }
    _config() {
      const { rowExpandable, columns } = this.table.grid.props;
      const { parentRow } = this.props;
      if (rowExpandable) {
        let normalizedRowExpandable = rowExpandable;
        if (!isPlainObject(rowExpandable)) {
          normalizedRowExpandable = {};
        }
        const { render = () => {} } = normalizedRowExpandable;
        const content = render({
          parentRow,
          row: this,
          rowData: this.props.data,
          grid: this.grid,
        });
        if (!content) {
          this.hasContent = false;
          return;
        } // 
        setTimeout(() => {
          parentRow.expandIndicotorIconRef.show();
          parentRow.expandIndicotorIconRef.update({
            expanded: !this.props.hidden,
          });
        }, 0);
        let colspan = columns.length;
        if (
          this.grid &&
          this.grid.props.rowSortable &&
          !this.grid.props.rowSortable.customHandler
        ) {
          colspan += 1;
        }
        this.setProps({
          hidden: !normalizedRowExpandable.expanded,
          children: {
            component: ExpandedTrTd,
            attrs: { colspan: colspan },
            classes: {
              "nom-table-expanded-tr-td-compact":
                normalizedRowExpandable.compact,
            },
            children: Object.assign({}, content, {
              onCreated: ({ inst }) => {
                this.subContent = inst;
              },
            }),
          },
        });
      }
    }
  }
  Component.register(ExpandedTr); // storage key
  const STORAGE_KEY_GRID_COLUMNS = "NOM_STORAGE_KEY_GRID_COLS"; //  key
  const STORAGE_KEY_GRID_COLS_WIDTH = "NOM_STORAGE_KEY_GRID_COLS_WIDTH"; //  key
  const STORAGE_KEY_GRID_COLS_FIXED = "NOM_STORAGE_KEY_GRID_COLS_FIXED"; //  key
  const STORAGE_KEY_PAGER_CACHEABLE = "NOM_STORAGE_KEY_PAGER_CACHE";
  class ExpandIcon extends Icon {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.grid = this.props.grid;
      this.row = this.props.row;
    }
    expand() {
      if (this.grid.props.rowExpandable.expandSingle === true) {
        if (this.grid.expandedTrItem) {
          this.grid.expandedTrItem.collapse();
        }
        this.grid.expandedTrItem = this;
      }
      super.expand();
      if (this.grid.props.rowExpandable.onExpand) {
        this.grid._callHandler(this.grid.props.rowExpandable.onExpand, {
          row: this.row,
        });
      }
    }
    collapse() {
      if (this.grid.props.rowExpandable.expandSingle === true) {
        this.grid.expandedTrItem = null;
      }
      super.collapse();
      if (this.grid.props.rowExpandable.onCollapse) {
        this.grid._callHandler(this.grid.props.rowExpandable.onCollapse, {
          row: this.row,
        });
      }
    }
  }
  Component.register(ExpandIcon);
  class ColGroupCol extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "col", column: {} };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.table = this.parent.table;
      this.table.colRefs[this.props.column.field] = this;
      this.maxTdWidth = 0;
      this.tdRefs = {}; //  td
    }
    _config() {
      const { width } = this.props.column;
      let widthPx = null;
      if (width) {
        widthPx = `${width}px`;
      }
      if (this.maxTdWidth) {
        widthPx = `${this.maxTdWidth}px`;
      }
      this.setProps({
        attrs: {
          style: { width: widthPx, minWidth: !widthPx ? "60px" : null },
          "data-field": this.props.column.field || null,
        },
      });
    }
    setMaxTdWidth(width) {
      if (this.maxTdWidth < 60 && width < 60) {
        this.maxTdWidth = 0;
      } else {
        this.maxTdWidth = Math.max(this.maxTdWidth, width);
      }
    }
  }
  Component.register(ColGroupCol);
  class ColGroup extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "colgroup" };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.table = this.parent;
      this.table.colGroup = this;
      this.columns = this.table.props.columns;
      this.colList = [];
      this.hasColumnGroup = false;
    }
    _config() {
      const children = [];
      if (
        this.table.grid &&
        this.table.grid.props.rowSortable &&
        !this.table.grid.props.rowSortable.customHandler
      ) {
        children.push({ component: ColGroupCol, column: { width: 36 } });
      }
      if (Array.isArray(this.columns)) {
        this.colList = [];
        children.push(...this.createCols(this.columns));
      }
      this.table.colLength = children.length; // if (this.table.grid && this.table.parent.componentType !== 'GridBody') {
      //   children.push({
      //     component: ColGroupCol,
      //     classes: { 'nomui-grid-scrollbar-col': true },
      //     column: {
      //       width: this.table.grid.props.scrollbarWidth,
      //     },
      //   })
      // }
      this.setProps({ children: children });
    }
    createCols(data) {
      const that = this;
      let index = -1;
      data.forEach(function (column) {
        if (column.children && column.children.length > 0) {
          that.createCols(column.children);
        } else {
          index += 1;
          that.colList.push({
            component: ColGroupCol,
            name: column.field,
            column: column,
            index: index,
          });
        }
      });
      return that.colList;
    }
  }
  Component.register(ColGroup);
  class Tr extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "tr", data: {} };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tbody = this.parent;
      this.table = this.tbody.table;
      this.tdRefs = {}; // keyField(id)  undefined, null
      const dataHaskeyField = !isNullish(
        this.props.data[this.table.props.keyField]
      );
      if (this.table.hasGrid && dataHaskeyField) {
        // key
        const _rowRefKey = this.props.data[this.table.props.keyField];
        const _rowRef = this.table.grid.rowsRefs[_rowRefKey];
        if (_rowRef) {
          // eslint-disable-next-line no-console
          console.warn(
            `Duplicate keys detected: '${_rowRefKey}'.This may cause an update error.`
          );
        } else {
          this.table.grid.rowsRefs[_rowRefKey] = this;
        }
      }
      if (this.table.parent.componentType === "GridFooter") {
        this.table.grid.footerTrRef = this;
      }
    }
    _config() {
      const columns = this.table.props.columns;
      const { data, level } = this.props;
      this.tdList = [];
      const grid = this.table.grid;
      const children = [];
      let hidden = false;
      if (grid) {
        const { treeConfig } = grid.props;
        hidden =
          treeConfig.initExpandLevel !== -1 &&
          treeConfig.initExpandLevel < level;
      }
      if (
        grid &&
        grid.props.rowSortable &&
        !grid.props.rowSortable.customHandler
      ) {
        children.push({
          component: Td,
          classes: { "nom-grid-drag-handler": true },
          data: {
            component: "Icon",
            type: "drag",
            attrs: { style: { cursor: "pointer" } },
          },
        });
      }
      if (Array.isArray(columns)) {
        this.tdList = [];
        children.push(...this.createTds(columns));
      }
      if (
        this.table.hasGrid &&
        this.table.grid.props &&
        this.table.grid.props.editMode
      ) {
        this.setProps({ editMode: true });
      }
      this.setProps({
        key: data[this.table.props.keyField],
        attrs: { level: level, isLeaf: this.props.isLeaf ? "true" : undefined },
        hidden: hidden,
        children: children,
      });
    }
    _rendered() {
      setTimeout(() => {
        this._processModifiedStyle();
      }, 0);
    }
    check(checkOptions) {
      const grid = this.table.grid;
      checkOptions = extend({ triggerChange: true }, checkOptions);
      this._check();
      this._checkboxRef.setValue(true, false);
      grid._checkboxAllRef && grid.changeCheckAllState();
      if (checkOptions.triggerChange) {
        this._onCheck();
        grid._onRowCheck(this);
      }
    }
    partCheck() {
      const grid = this.table.grid;
      this._checkboxRef.partCheck(false);
      this.props.checked = false;
      this.props.partChecked = true;
      this.removeClass("s-checked");
      delete grid.checkedRowRefs[this.key];
      grid.partCheckedRowRefs[this.key] = this;
    }
    _onCheck() {
      this._callHandler("onCheck");
    }
    _check() {
      this.props.checked = true;
      this.props.partChecked = false;
      this.addClass("s-checked");
      const grid = this.table.grid;
      grid.checkedRowRefs[this.key] = this;
      delete grid.partCheckedRowRefs[this.key];
    }
    uncheck(uncheckOptions) {
      const grid = this.table.grid;
      uncheckOptions = extend({ triggerChange: true }, uncheckOptions);
      this._checkboxRef.setValue(false, false);
      this._uncheck();
      grid._checkboxAllRef && grid.changeCheckAllState();
      if (uncheckOptions.triggerChange) {
        this._onUncheck();
        grid._onRowUncheck(this);
      }
    }
    _uncheck() {
      this.props.checked = false;
      this.props.partChecked = false;
      this.removeClass("s-checked");
      const grid = this.table.grid;
      delete grid.checkedRowRefs[this.key];
      delete grid.partCheckedRowRefs[this.key];
    }
    _onUncheck() {
      this._callHandler("onUncheck");
    }
    createTds(item) {
      const data = this.props.data;
      const that = this;
      item.forEach(function (column) {
        if (column.children && column.children.length > 0) {
          that.createTds(column.children);
        } else {
          that.tdList.push({
            component: Td,
            name: column.field,
            column: column,
            record: data,
            data: column.flatData
              ? data[column.field]
              : accessProp(data, column.field),
          });
        }
      });
      return that.tdList;
    }
    _onExpand() {
      this.setProps({ classes: { "s-expanded": true } });
      this.addClass("s-expanded");
      this._expanded = true;
    }
    _onCollapse() {
      this.setProps({ classes: { "s-expanded": false } });
      this.removeClass("s-expanded");
      this._expanded = false;
    }
    _processModifiedStyle() {
      const { data } = this.props;
      const { grid } = this.table;
      if (!grid) {
        return;
      }
      if (
        grid.props &&
        grid.props.highlightModifiedRows &&
        grid.modifiedRowKeys.includes(data[grid.props.keyField])
      ) {
        this.element.classList.add("nom-grid-tr-modified");
      }
    }
    _updateRowData() {
      let dataChanged = false;
      const { data } = this.props;
      for (const key in this.tdRefs) {
        const item = this.tdRefs[key];
        const { editor } = item;
        if (editor && data[key] !== editor.getValue()) {
          dataChanged = true;
          data[key] = editor.getValue();
        }
      }
      if (dataChanged) {
        this.props.data = data;
        const grid = this.table.grid;
        if (grid.props.data.length) {
          for (let i = 0; i < grid.props.data.length; i++) {
            if (
              grid.props.data[i][grid.props.keyField] ===
              data[grid.props.keyField]
            ) {
              grid.props.data[i] = data;
            }
          }
        }
        grid._processModifedRows(data[grid.props.keyField]);
      }
    }
    validate() {
      let validated = true;
      for (const key in this.tdRefs) {
        const item = this.tdRefs[key];
        const { editor } = item;
        if (editor) {
          const result = editor.validate();
          if (result !== true) {
            validated = result;
          }
        }
      }
      return validated;
    }
    edit() {
      this.update({ editMode: true });
    }
    endEdit(options) {
      if (!options) {
        options = { ignoreChange: false };
      }
      if (options.ignoreChange !== true) {
        this._updateRowData();
      }
      this.update({ editMode: false });
    }
    saveEditData() {
      this._updateRowData();
    } // childTrs show 
    _show() {
      if (this.firstRender) {
        return;
      }
      const { childTrs, classes } = this.props; // :  tr expanded: false childTr
      if (Array.isArray(childTrs) && classes["s-expanded"]) {
        childTrs.forEach((_childTr) => {
          _childTr.show && _childTr.show();
        });
      }
    } //  childTrs hide
    _hide() {
      if (this.firstRender) {
        return;
      }
      const { childTrs } = this.props;
      if (Array.isArray(childTrs)) {
        childTrs.forEach((_childTr) => {
          _childTr.hide && _childTr.hide();
        });
      }
    }
    remove(options = {}) {
      if (options.removeExpandedRow) {
        this.expandedRow.remove();
      }
      super.remove();
    }
    _remove() {
      const dataHaskeyField = !isNullish(
        this.props.data[this.table.props.keyField]
      );
      if (this.table.hasGrid && dataHaskeyField) {
        // key
        const _rowRefKey = this.props.data[this.table.props.keyField];
        delete this.table.grid.rowsRefs[_rowRefKey];
        this.table.grid._processRemovedRows(this.props.data);
      }
    }
  }
  Component.register(Tr);
  class Tbody extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "tbody" };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.table = this.parent;
      this.table.tbody = this;
      this.props.showEmpty = this.table.props.showEmpty;
    }
    _config() {
      const { data = [], rowDefaults, keyField } = this.table.props;
      const rows = [];
      Array.isArray(data) && this._getRows(data, rows, 0, 0, {});
      let props = {
        children: rows,
        childDefaults: Component.extendProps(
          {
            component: Tr,
            key: function () {
              return this.props.data[keyField];
            },
            _config: function () {
              this.setProps({
                attrs: { "data-key": this.props.data[keyField] },
              });
            },
            onClick: (args) => {
              const { event, sender } = args;
              this.table.hasGrid &&
                this.table.grid.props.onRowClick &&
                this.table.grid._callHandler("onRowClick", {
                  event,
                  rowData: sender.props.data,
                });
              this.table.hasGrid &&
                this.table.grid.props.rowSelectable &&
                this.table.selectTr(args.sender);
            },
          },
          rowDefaults
        ),
      };
      if (
        this.props.showEmpty &&
        this.table.props.data &&
        !this.table.props.data.length
      ) {
        props = {
          children: {
            tag: "tr",
            classes: { "nom-tr-empty": true },
            hidden: !!this.table.grid,
            children: {
              tag: "Td",
              attrs: {
                colspan: this.table.colLength,
                style: { "vertical-align": "middle" },
              },
              children: {
                component: "Empty",
                description: this.table.props.emptyText,
              },
            },
          },
        };
      }
      this.setProps(props);
    }
    _rendered() {
      if (this.table.hasGrid && this.table.grid.props.rowSortable) {
        const me = this;
        const { grid } = this.table;
        new Sortable(this.element, {
          group: this.key,
          animation: 150,
          fallbackOnBody: true,
          swapThreshold: 0.65,
          handle: ".nom-grid-drag-handler",
          filter: ".nom-grid-tr-no-drag",
          onEnd: function ({ item, oldIndex, newIndex }) {
            me.table._showExpandedTr();
            grid.handleDrag({ item, oldIndex, newIndex });
          },
          onStart: function () {
            me.table._hideExpandedTr();
          },
        });
      }
    }
    _getRows(data, rows, index, level, lastRowRef = {}, parentKey = null) {
      const curLevel = level;
      const { treeConfig, keyField } = this.table.props;
      const { childrenField } = treeConfig; // currRowRef: tr
      // lastRowRef: leveltr
      //  data.children trchildTrs
      // expand, collapse
      //  key tr
      data.forEach((item) => {
        let currRowRef = { childTrs: [] };
        rows.push({
          // component: Tr,
          parentKey,
          data: item,
          index: index++,
          level: curLevel,
          isLeaf: !(item[childrenField] && item[childrenField].length > 0),
          childTrs: currRowRef.childTrs,
          _created: function () {
            currRowRef = this;
            if (!lastRowRef.childTrs) lastRowRef.childTrs = [];
            lastRowRef.childTrs.push(this);
          },
        });
        if (
          treeConfig.treeNodeColumn &&
          item[childrenField] &&
          item[childrenField].length > 0
        ) {
          this._getRows(
            item[childrenField],
            rows,
            index,
            curLevel + 1,
            currRowRef,
            item[keyField]
          );
        }
      });
    }
  }
  Component.register(Tbody);
  class Th extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "th", column: {}, sortDirection: null };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tr = this.parent;
      this.table = this.tr.table;
      this.resizer = null;
      this.lastDistance = 0;
      this._stickyPos = 0; //  thsticy.style.left(right) 
      this.table.thRefs[this.props.column.field] = this;
      this.filterValue = null;
    }
    _config() {
      const that = this;
      this.filterValue = this.table.hasGrid
        ? this.table.grid.filter[this.props.column.field]
        : null;
      let columnAlign = this.table.hasGrid
        ? this.table.grid.props.columnAlign
        : "left";
      if (
        this.props.column.isChecker &&
        !this.props.column.toolbar &&
        this.table.grid.props.rowCheckable.align
      ) {
        columnAlign = this.table.grid.props.rowCheckable.align;
      }
      let sortIcon = "sort";
      if (this.props.column.sortDirection === "asc") {
        sortIcon = "sort-up";
      }
      if (this.props.column.sortDirection === "desc") {
        sortIcon = "sort-down";
      }
      const isEllipsis =
        (this.table.props.ellipsis === "both" ||
          this.table.props.ellipsis === "header") &&
        this.props.column.ellipsis !== false;
      let titleStr = this.props.column.header || this.props.column.title;
      if (!isString(titleStr)) {
        titleStr = null;
      }
      let thContent = this.props.column.header || this.props.column.title;
      if (
        this.props.column.isChecker ||
        this.props.column.type === "checker" ||
        this.props.column.type === "checker&order"
      ) {
        thContent = {
          component: "Checkbox",
          attrs: { style: { display: "inline-flex", paddingRight: ".25rem" } },
          uncheckPart: true,
          plain: true,
          _created: (inst) => {
            that.table.grid._checkboxAllRef = inst;
          },
          onValueChange: (args) => {
            if (args.newValue === true) {
              that.table.grid.checkAllRows(false);
            } else {
              that.table.grid.uncheckAllRows(false);
            }
          },
          onClick: ({ event }) => {
            event.stopPropagation();
          },
        };
      }
      const headerProps = {
        tag: "span",
        attrs: { title: isEllipsis ? titleStr : null },
        classes: { "nom-table-cell-title": true }, // children: isEllipsis ? {
        //   classes: {
        //     'nom-table-cell-ellipsis': true
        //   },
        //   children: thContent
        // } : thContent
        children: thContent,
      };
      if (that.props.column.sortable && that.props.column.colSpan > 0) {
        headerProps.onClick = function () {
          that.onSortChange();
        };
      }
      this.resizable =
        this.table.hasGrid &&
        this.table.grid.props.columnResizable &&
        this.props.column.resizable !== false &&
        this.props.column.colSpan === 1; // 
      if (
        this.table.hasGrid &&
        this.table.grid.props.columnResizable.allowFixedCol === false &&
        this.props.column.fixed
      ) {
        this.resizable = false;
      }
      let children = [
        this.props.column.toolbar &&
          this.props.column.toolbar.align === "left" && {
            classes: {
              "nom-grid-column-th-tools": true,
              "nom-grid-column-th-tools-hover": this.props.column.toolbar.hover,
              "nom-grid-column-th-tools-hide": !(
                this.props.column.toolbar.placement === "header" ||
                this.props.column.toolbar.placement === "both"
              ),
            },
            children: Object.assign(
              { forceVisible: true },
              this.props.column.toolbar.render({
                isHeader: true,
                field: this.props.column.field,
              })
            ),
          },
        headerProps,
        this.props.column.sortable &&
          this.props.column.colSpan > 0 && {
            component: "Icon",
            classes: { "nom-table-sort-handler": true },
            type: sortIcon,
            onClick: function () {
              that.onSortChange();
            },
          },
        this.props.column.filter &&
          this.props.column.colSpan > 0 && {
            component: "Icon",
            type: "filter",
            ref: (c) => {
              this.filterBtn = c;
            },
            classes: { "nom-table-filter-handler": true },
            attrs: { style: { cursor: "pointer" } },
            tooltip: this.filterValue
              ? this.table.grid.filterValueText[this.props.column.field]
              : null,
            popup: {
              align: "bottom right",
              ref: (c) => {
                this.filterPopup = c;
              },
              onShow: () => {
                that.filterGroup && that.filterGroup.setValue(that.filterValue);
              },
              children: {
                attrs: {
                  style: {
                    padding: "10px",
                    "min-width": "180px",
                    "max-width": "250px",
                  },
                },
                children: [
                  {
                    component: "Group",
                    ref: (c) => {
                      this.filterGroup = c;
                    },
                    fields: [
                      Object.assign(
                        {},
                        isFunction(that.props.column.filter)
                          ? that.props.column.filter()
                          : that.props.column.filter,
                        { name: that.props.column.field }
                      ),
                    ],
                  },
                  {
                    attrs: {
                      style: { "text-align": "right", padding: "0 10px" },
                    },
                    children: {
                      component: "Cols",
                      justify: "end",
                      gutter: "sm",
                      items: [
                        {
                          component: "Button",
                          text: this.table.props.okText,
                          size: "small",
                          onClick: () => {
                            this.onFilterChange();
                          },
                        },
                        {
                          component: "Button",
                          text: this.table.props.resetText,
                          size: "small",
                          onClick: () => {
                            this.onFilterReset();
                          },
                        },
                      ],
                    },
                  },
                ],
              },
            },
          },
        that.table.hasGrid &&
          that.table.grid.props.allowFrozenCols &&
          that.table.grid.props.allowFrozenCols.showPinner &&
          !this.table.hasMultipleThead &&
          !(this.props.column.width && this.props.column.width > 600) &&
          !this.props.column.isChecker &&
          !this.props.column.isTreeMark &&
          this.props.column.fixed !== "right" &&
          this.props.column.frozenable !== false && {
            component: "Icon",
            type: this.props.column.fixed ? "pin-fill" : "pin",
            attrs: {
              title: this.props.column.fixed
                ? this.table.props.unfreezeText
                : this.table.props.freezeText,
            },
            classes: { "nom-table-pin-handler": true },
            onClick: function () {
              that.table.grid.handlePinClick(that.props.column);
            },
          },
        this.props.column.toolbar &&
          this.props.column.toolbar.align !== "left" && {
            classes: {
              "nom-grid-column-th-tools": true,
              "nom-grid-column-th-tools-float-right":
                this.props.column.toolbar.align === "right",
              "nom-grid-column-th-tools-hover": this.props.column.toolbar.hover,
              "nom-grid-column-th-tools-hide": !(
                this.props.column.toolbar.placement === "header" ||
                this.props.column.toolbar.placement === "both"
              ),
            },
            children: Object.assign(
              { forceVisible: true },
              this.props.column.toolbar.render({
                isHeader: true,
                field: this.props.column.field,
              })
            ),
          },
        that.resizable && {
          // component: 'Icon',
          ref: (c) => {
            that.resizer = c;
          }, // type: 'resize-handler',
          classes: { "nom-table-resize-handler": true },
        },
      ]; // span
      if (isEllipsis) {
        children = {
          tag: "span",
          classes: { "nom-table-cell-content": true },
          children: children,
        };
      }
      if (that.table.hasGrid) {
        const { column } = this.props;
        const { treeConfig, rowCheckable } = that.table.grid.props;
        if (rowCheckable && rowCheckable.checkboxOnNodeColumn) {
          const isTreeNodeColumn =
            treeConfig.treeNodeColumn &&
            column.field === treeConfig.treeNodeColumn;
          if (isTreeNodeColumn) {
            children.unshift({
              component: "Checkbox",
              attrs: {
                style: { display: "inline-flex", paddingRight: ".25rem" },
              },
              plain: true,
              _created: (inst) => {
                that.table.grid._checkboxAllRef = inst;
              },
              onValueChange: (args) => {
                if (args.newValue === true) {
                  that.table.grid.checkAllRows(false);
                } else {
                  that.table.grid.uncheckAllRows(false);
                }
              },
            });
          }
        }
      }
      this.setProps({
        children: children,
        classes: {
          "nom-table-fixed-left": this.props.column.fixed === "left",
          "nom-table-fixed-left-last": this.props.column.lastLeft,
          "nom-table-fixed-right": this.props.column.fixed === "right",
          "nom-table-fixed-right-first": this.props.column.firstRight,
          "nom-table-parent-th": this.props.column.colSpan > 1,
          "nom-table-leaf-th": this.props.column.colSpan === 1,
          "nom-table-sortable": !!(
            this.props.column.sortable && this.props.column.colSpan > 0
          ),
          "nom-table-filter": !!(
            this.props.column.filter && this.props.column.colSpan > 0
          ),
          "nom-table-ellipsis": isEllipsis,
          "nom-table-checker-column": !!this.props.column.isChecker,
          "nom-table-checker-with-toolbar":
            !!this.props.column.toolbar && this.props.column.isChecker,
        },
        attrs: {
          colspan: this.props.column.colSpan,
          rowspan: this.props.column.rowSpan,
          align: this.props.column.align || columnAlign,
          "data-field": this.props.column.field,
          onmouseenter:
            this.table.grid &&
            function () {
              const mask = that.table.grid.highlightMask;
              mask &&
                !that.mouseDowning &&
                mask.update({
                  attrs: {
                    style: {
                      zIndex: that.props.column.fixed ? 99 : null,
                      left: `${this.offsetLeft}px`,
                      width: `${this.offsetWidth}px`,
                    },
                  },
                });
            },
          onmouseleave: this._hideHighLightMask.bind(this),
        },
      });
    }
    _rendered() {
      this.props.column.filter &&
        this.props.column.colSpan > 0 &&
        this.resetFilterStatus(); // 
      const fixed = this.props.column.fixed;
      if (fixed) {
        setTimeout(() => {
          this.setStickyPosition();
        }, 0);
      }
      this.resizer && this.handleResize();
    }
    /**
     * th width style.left
     * @param {boolean} externalTrigger 
     * @returns
     */ setStickyPosition(externalTrigger = false) {
      // _renderthis.props
      if (!this.props) return;
      if (externalTrigger) {
        this._setPositionByExter();
      } else {
        this._setPositionByIndide();
      }
      this._setAllTdsPosition();
    } //   offsetLeftoffsetWidth
    _setPositionByIndide() {
      const fixed = this.props.column.fixed;
      const el = this.element;
      const parentEl = this.parent.element;
      if (fixed === "left") {
        this._stickyPos = el.offsetLeft;
      } else if (fixed === "right") {
        this._stickyPos = parentEl.clientWidth - el.offsetLeft - el.offsetWidth;
      }
      this._setStyle({ [fixed]: `${this._stickyPos}px` });
    } //  preEl  nextEl offsetWidth 
    _setPositionByExter() {
      const fixed = this.props.column.fixed;
      const el = this.element;
      if (fixed === "left") {
        const preEl = el.previousElementSibling;
        this._stickyPos = preEl
          ? preEl.component._stickyPos + preEl.offsetWidth
          : 0;
      } else if (fixed === "right") {
        const nextEl = el.nextElementSibling;
        this._stickyPos = nextEl
          ? nextEl.component._stickyPos + nextEl.offsetWidth
          : 0;
      }
      this._setStyle({ [fixed]: `${this._stickyPos}px` });
    }
    _gridBodyHasScrollbar() {
      if (!this.table.grid) {
        return false;
      }
      const body = this.table.grid.element.querySelector(".nom-grid-body"); // 
      const hasVScrollbar = body && body.scrollHeight > body.clientHeight;
      return hasVScrollbar;
    }
    _setAllTdsPosition() {
      const { table, props } = this;
      const { body, footer } = table.grid;
      const { field } = props.column;
      if (body) {
        this._setTdsPosition(body.table.colRefs[field].tdRefs);
      }
      if (footer) {
        this._setTdsPosition(footer.table.colRefs[field].tdRefs);
      }
    }
    _setTdsPosition(tdRefs) {
      const { props, _stickyPos } = this;
      const { fixed } = props.column;
      Object.keys(tdRefs).forEach((key) => {
        tdRefs[key]._setStyle({ [fixed]: `${_stickyPos}px` });
      });
    }
    handleResize() {
      const resizer = this.resizer.element;
      const that = this;
      const { columnResizable } = this.table.grid.props;
      resizer.onmousedown = function (evt) {
        isPlainObject(columnResizable) &&
          columnResizable.onStart &&
          that.table.grid._callHandler(columnResizable.onStart);
        const startX = evt.clientX;
        that.lastDistance = 0;
        that._hideHighLightMask();
        that.mouseDowning = true;
        document.onmousemove = function (e) {
          const endX = e.clientX;
          const moveLen = endX - startX;
          const distance = moveLen - that.lastDistance;
          that._triggerGridResize(distance);
          that.lastDistance = moveLen;
          isPlainObject(columnResizable) &&
            columnResizable.onMove &&
            that.table.grid._callHandler(columnResizable.onMove);
        };
        document.onmouseup = function () {
          that.mouseDowning = false;
          const grid = that.table.grid;
          if (that.resizable && grid.props.columnResizable.cache) {
            grid.storeColsWidth(that.props.column.field);
          } //  scroller 
          const header = grid.header;
          if (header.scrollbar) {
            const gRect = grid.element.getBoundingClientRect();
            const size = {
              width: `${gRect.width}px`,
              innerWidth: `${header.element.scrollWidth}px`,
            };
            header.scrollbar.update({ size });
          }
          header && header._processFixedColumnSticky(that);
          that._triggerGridResize(0);
          isPlainObject(columnResizable) &&
            columnResizable.onEnd &&
            that.table.grid._callHandler(columnResizable.onEnd);
          document.onmousemove = null;
          document.onmouseup = null;
        };
      };
    }
    _hideHighLightMask() {
      if (!this.table.grid) return;
      const mask = this.table.grid.highlightMask;
      mask && mask.update({ attrs: { style: { width: 0 } } });
    }
    /**
     * @param {number} distance 
     */ _triggerGridResize(distance) {
      this.table.grid.calcResizeCol(
        { field: this.props.column.field, distance: distance },
        this
      );
    }
    onSortChange() {
      const that = this;
      that.table.grid._setScrollPlace();
      if (that.props.column.sortDirection === "desc") {
        that.update({
          column: Object.assign({}, that.props.column, {
            sortDirection: "asc",
          }),
        });
      } else if (that.props.column.sortDirection === "asc") {
        that.update({
          column: Object.assign({}, that.props.column, { sortDirection: null }),
        });
      } else {
        that.update({
          column: Object.assign({}, that.props.column, {
            sortDirection: "desc",
          }),
        });
      }
      that.table.grid.handleSort(that.props.column);
    }
    resetSort() {
      this.update({ column: { sortDirection: null } });
      this.table.grid && this.table.grid.setSortDirection();
    }
    onFilterChange(isReset) {
      if (this.filterGroup.getValue()[this.props.column.field]) {
        this.filterValue = Object.assign({}, this.filterGroup.getValue());
      }
      this.table.grid.filter = Object.assign(
        {},
        this.table.grid.filter,
        this.filterGroup.getValue()
      );
      this.table.grid.filterValueText[
        this.props.column.field
      ] = this.filterGroup
        .getField(this.props.column.field)
        .getValueText()
        .toString();
      this.filterPopup.hide();
      this.table.grid.handleFilter(isReset);
    }
    onFilterReset() {
      this.filterGroup.reset();
      this.filterValue = null;
      this.onFilterChange(true);
    }
    resetFilterStatus() {
      this.filterBtn.update({
        classes: { "nom-filter-active": !!this.filterValue },
      });
    }
  }
  Component.register(Th);
  class TheadTr extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "tr", columns: null };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.thead = this.parent;
      this.table = this.thead.table;
    }
    _config() {
      const { columns } = this.props;
      const thArr = [];
      if (
        this.table.grid &&
        this.table.grid.props.rowSortable &&
        !this.table.grid.props.rowSortable.customHandler
      ) {
        thArr.push({ component: Th });
      }
      const children =
        Array.isArray(columns) &&
        columns.map(function (column) {
          return { component: Th, column: column };
        });
      thArr.push(...children);
      this.setProps({ children: thArr });
    }
  }
  Component.register(TheadTr);
  class Thead extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "thead" };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.table = this.parent;
    }
    _config() {
      const columns = this.getColumns();
      const arr = this.mapHeadData(columns);
      this.table.hasMultipleThead = arr.length > 1;
      const children = [];
      for (let i = 0; i < arr.length; i++) {
        children.push({
          component: TheadTr,
          columns: arr[i],
          isRootTr: i === 0,
        });
      }
      this.setProps({ children: children });
    }
    getColumns() {
      return this.table.props.columns;
    }
    mapHeadData(rootColumns) {
      const rows = [];
      function fillRowCells(columns, colIndex, rowIndex) {
        // Init rows
        rows[rowIndex] = rows[rowIndex] || [];
        let currentColIndex = colIndex;
        const colSpans = columns.filter(Boolean).map((column) => {
          const cell = Object.assign({}, column);
          let colSpan = 1;
          const subColumns = column.children;
          if (subColumns && subColumns.length > 0) {
            colSpan = fillRowCells(
              subColumns,
              currentColIndex,
              rowIndex + 1
            ).reduce((total, count) => total + count, 0);
            cell.hasSubColumns = true;
          } // if ('colSpan' in column) {
          //   ;({ colSpan } = column)
          // }
          if ("rowSpan" in column) {
            cell.rowSpan = column.rowSpan;
          }
          cell.colSpan = colSpan; // cell.colEnd = cell.colStart + colSpan - 1
          rows[rowIndex].push(cell);
          currentColIndex += colSpan;
          return colSpan;
        });
        return colSpans;
      } // Generate `rows` cell data
      fillRowCells(rootColumns, 0, 0); // Handle `rowSpan`
      const rowCount = rows.length;
      for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
        rows[rowIndex].forEach((cell) => {
          if (!("rowSpan" in cell) && !cell.hasSubColumns) {
            cell.rowSpan = rowCount - rowIndex;
          }
        });
      }
      return rows;
    }
  }
  Component.register(Thead);
  class Table extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Table.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.colRefs = [];
      this.thRefs = [];
      this.hasGrid = ["GridHeader", "GridBody", "GridFooter"].some(
        (item) => this.parent.componentType === item
      );
      if (this.hasGrid) {
        this.grid = this.parent.parent;
        this.parent.table = this;
      }
      this.hasRowGroup = false;
      this.hasMultipleThead = false;
    }
    _config() {
      const that = this;
      this._propStyleClasses = ["line", "bordered"];
      const isStriped =
        (this.hasGrid && this.grid.props.striped === true) ||
        this.props.striped === true ||
        false;
      let hasMask = false;
      if (this.hasGrid) {
        this.props.ellipsis = this.grid.props.ellipsis;
        hasMask = this.grid.props.highlightCol;
      }
      this.setProps({
        tag: "table",
        classes: { "nom-table-striped": isStriped },
        children: [
          { component: ColGroup },
          this.props.onlyBody !== true && { component: Thead },
          this.props.onlyHead !== true && { component: Tbody },
          hasMask &&
            this.parent.componentType === "GridBody" && {
              tag: "div",
              classes: { "nom-table-th-hover-mask": true },
              _created() {
                that.grid.highlightMask = this;
              },
            },
        ],
      });
    }
    _rendered() {
      if (this.loadingInst) {
        this.loadingInst.remove();
        this.loadingInst = null;
      }
      if (
        (this.hasGrid && this.grid.props.autoMergeColumns) ||
        this.hasRowGroup
      ) {
        this.grid.setProps({ classes: { "nom-table-has-row-group": true } });
      }
    }
    _hideExpandedTr() {
      const ele = this.tbody.element;
      const sibs = ele.childNodes;
      sibs.forEach((sib) => {
        if (sib.classList.contains("nom-expanded-tr")) {
          sib.classList.add("nom-grid-tr-hidden");
        }
      });
    }
    _showExpandedTr() {
      const ele = this.tbody.element;
      const sibs = ele.childNodes;
      sibs.forEach((sib) => {
        if (sib.classList.contains("nom-expanded-tr")) {
          sib.classList.remove("nom-grid-tr-hidden");
        }
      });
    }
    loading() {
      this.loadingInst = new Loading({ container: this.parent });
    }
    appendRow(rowProps) {
      if (!this.props.data) {
        this.props.data = [];
      }
      if (!this.props.data.length) {
        this.tbody.update({ showEmpty: false });
      }
      const row = this.tbody.appendChild(
        Object.assign({}, rowProps, { index: this.props.data.length })
      );
      this.props.data.push(rowProps.data);
      if (this.hasGrid) {
        this.grid.rowsRefs[row.key] = row;
      }
    }
    getRows() {
      return this.tbody.getChildren();
    }
    selectTr(tr) {
      if (this.activeTr) {
        this.activeTr.element.classList.remove("nom-tr-selected");
      }
      this.activeTr = tr;
      this.activeTr.element.classList.add("nom-tr-selected");
      this.hasGrid &&
        this.grid.props.rowSelectable &&
        this.grid.props.rowSelectable.onSelect &&
        this.grid._callHandler(this.grid.props.rowSelectable.onSelect, {
          row: tr,
          rowData: tr.props.data,
        });
    }
  }
  Table.defaults = {
    tag: "table",
    columns: [],
    rowDefaults: {},
    onlyHead: false,
    onlyBody: false,
    keyField: "id",
    striped: false,
    treeConfig: {
      childrenField: "children",
      treeNodeColumn: null,
      initExpandLevel: -1,
      indentSize: 6,
    },
    showTitle: false,
    ellipsis: false,
    showEmpty: true,
    emptyText: "",
    okText: "",
    resetText: "",
    freezeText: "",
    unfreezeText: "",
  };
  Component.register(Table);
  var GridTableMixin = {
    methods: {
      calcResizeCol: function (data, thRef) {
        const col = this.table.colRefs[data.field];
        const tdWidth = this.table.element.rows[0].cells[col.props.index]
          .offsetWidth;
        const colWidth = col.props.column.width || tdWidth;
        let result = colWidth + data.distance;
        if (result < 60) {
          result = 60;
        }
        col.update({ column: { width: result } });
        if (this.componentType === "GridHeader" && col.props.column.fixed) {
          // Header   mixin 
          this._processFixedColumnSticky(thRef);
        }
      },
      resizeCol: function ({ field, width = 0 }) {
        const col = this.table.colRefs[field];
        col && col.update({ column: { width } });
      },
      setColMaxTdWidth: function ({ field, maxTdWidth }) {
        const col = this.table.colRefs[field];
        col && col.setMaxTdWidth(maxTdWidth);
      },
    },
  };
  class GridBody extends Component {
    constructor(props, ...mixins) {
      const defaults = { children: { component: Table } };
      super(Component.extendProps(defaults, props), GridTableMixin, ...mixins);
    }
    _created() {
      this.grid = this.parent;
      this.grid.body = this;
    }
    _config() {
      let children = {
        component: "Table",
        columns: this.grid.props.columns,
        data: this.grid.props.data,
        attrs: { style: { minWidth: `${this.grid.minWidth}px` } },
        onlyBody: true,
        line: this.props.line,
        rowDefaults: this.props.rowDefaults,
        treeConfig: this.grid.props.treeConfig,
        keyField: this.grid.props.keyField,
        showEmpty: this.grid.props.showEmpty,
      };
      if (
        this.grid.props.showEmpty &&
        this.grid.props.data &&
        !this.grid.props.data.length
      ) {
        children = [
          children,
          {
            component: "Component",
            classes: { "nom-grid-body-empty": true },
            ref: (c) => {
              this.grid.emptyRef = c;
            },
            children: {
              component: "Empty",
              description: this.grid.props.emptyText,
            },
          },
        ];
      }
      this.setProps({
        children: children,
        attrs: {
          onscroll: () => {
            const { scrollLeft } = this.element;
            this.grid.header.element.scrollLeft = scrollLeft;
            if (this.grid.footer) {
              this.grid.footer.element.scrollLeft = scrollLeft;
            }
            this.grid.header.scrollbar &&
              this.grid.header.scrollbar.setScrollLeft(scrollLeft);
          },
        },
      });
    }
    _rendered() {
      // fix: chrome,,dom,
      if (isChrome49()) {
        this._elWidth = this.element.offsetWidth;
      }
    }
  }
  Component.register(GridBody);
  class GridFooter extends Component {
    constructor(props, ...mixins) {
      const defaults = { children: { component: Table } };
      super(Component.extendProps(defaults, props), GridTableMixin, ...mixins);
    }
    _created() {
      this.grid = this.parent;
      this.grid.footer = this;
    }
    _config() {
      this.setProps({
        attrs: {
          style: { paddingRight: `${this.grid.props.scrollbarWidth}px` },
        },
        children: {
          columns: this._getSummaryColumns(),
          data: this._getSummaryDataList(),
          attrs: { style: { minWidth: `${this.grid.minWidth}px` } },
          onlyBody: true,
          line: this.props.line,
          rowDefaults: this.props.rowDefaults,
          treeConfig: this.grid.props.treeConfig,
          keyField: this.grid.props.keyField,
        },
      });
    }
    _getSummaryColumns() {
      const { summary } = this.grid.props;
      const columns =
        this.grid.props.summary && this.grid.props.summary.columns
          ? this.grid.props.summary.columns
          : this.grid.props.columns;
      const footColumns = [...columns];
      if (
        this.grid.props.rowCheckable &&
        footColumns.length &&
        footColumns.findIndex((n) => {
          return n.isCheckerSpace;
        }) === -1
      ) {
        const col = footColumns[0];
        const { fixed } = col;
        footColumns.splice(0, 1, {
          width: this.grid.props.rowCheckable.width || 50,
          resizable: false,
          isCheckerSpace: true,
          field: "nom-grid-row-checker",
          fixed,
        });
      }
      const ignoreCellRender = !!(summary && summary.ignoreCellRender);
      return footColumns.map((col) => {
        return Object.assign({}, col, {
          cellRender:
            col.cellRender && !ignoreCellRender ? col.cellRender : null,
        });
      });
    }
    _getSummaryDataList() {
      const { summary } = this.grid.props;
      let list = [];
      if (!this.grid.props.columns.length) {
        return list;
      }
      if (Array.isArray(summary)) {
        list = summary.map((i) => {
          return this._getSummaryData(i);
        });
      } else if (summary.rows) {
        list = summary.rows.map((i) => {
          return this._getSummaryData(i);
        });
      } else {
        list.push(this._getSummaryData(summary));
      }
      return list;
    }
    _getMappedColumns(columns) {
      const arr = [];
      function mapColumns(data) {
        data.forEach(function (item) {
          if (item.children) {
            mapColumns(item.children);
          }
          arr.push(item);
        });
      }
      mapColumns(columns);
      return arr;
    }
    _getSummaryData(param) {
      const {
        data = [],
        rowCheckable,
        rowExpandable,
        totalizeText,
      } = this.grid.props;
      const columns =
        this.grid.props.summary && this.grid.props.summary.columns
          ? this.grid.props.summary.columns
          : this.grid.props.columns;
      const { method, text = totalizeText } = param;
      const flatColumns = this._getMappedColumns(columns);
      let res = {};
      let textColumnIndex = 0;
      rowCheckable && textColumnIndex++;
      rowExpandable && textColumnIndex++;
      if (method && isFunction(method)) {
        res = method({ columns: flatColumns, data, text: text });
        res[flatColumns[textColumnIndex].field] = text;
      } else {
        flatColumns.forEach((col, index) => {
          if (index === textColumnIndex) {
            res[col.field] = text;
            return;
          }
          const values = (data || []).map((item) => Number(item[col.field]));
          let sum = 0;
          for (let i = 0; i < values.length; i++) {
            if (Number.isNaN(values[i])) {
              res[col.field] = "-";
              return;
            }
            sum += values[i];
          }
          res[col.field] = sum;
        });
      }
      return res;
    }
  }
  Component.register(GridFooter);
  class Scrollbar extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        target: null,
        hidden: true,
        position: { left: 0, bottom: 0 },
        size: { width: 0, innerWidth: 0 },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const { position, size } = this.props;
      this.setProps({
        attrs: {
          style: {
            width: size.width,
            left: position.left,
            bottom: position.bottom,
            "overflow-x": "auto",
            "overflow-y": "hidden",
          },
          onscroll: () => {
            const { scrollLeft } = this.element;
            this._scrollLeft = scrollLeft;
            if (!this._setScrollFlag) {
              this.props.target.body.element.scrollLeft = scrollLeft;
            }
            this._setScrollFlag = false;
          },
        },
        children: {
          classes: { "nom-scrollbar-inner": true },
          attrs: { style: { width: size.innerWidth } },
        },
      });
    } //  scrollBar  scrollLeft
    setScrollLeft(scrollLeft) {
      // scrollbar scrollLeft 
      //  _rendered
      if (this.props.hidden) {
        this._scrollLeft = scrollLeft;
      } else {
        // _setScrollFlag: true 
        //  gridbody scrollLeft,  onscroll
        this._setScrollFlag = true;
        this.element.scrollLeft = scrollLeft;
      }
    }
    _rendered() {
      this.element.scrollLeft = this._scrollLeft || 0;
    }
    show() {
      this.props.hidden && this.update({ hidden: false });
    }
    hide() {
      !this.props.hidden && this.update({ hidden: true });
    }
    _remove() {
      this.element.remove();
    }
  }
  Component.register(Scrollbar);
  class GridHeader extends Component {
    constructor(props, ...mixins) {
      const defaults = { children: { component: Table } };
      super(Component.extendProps(defaults, props), GridTableMixin, ...mixins);
    }
    _created() {
      this.grid = this.parent;
      this.grid.header = this;
    }
    _config() {
      const { summary } = this.grid.props;
      const minWidth = this.grid.minWidth;
      this._summaryHeight = summary ? 36 : 0;
      this.setProps({
        classes: { "nom-grid-highlight-col": this.grid.props.highlightCol },
        attrs: {
          style: { paddingRight: `${this.grid.props.scrollbarWidth}px` },
        },
        children: {
          component: Table,
          columns: this.grid.props.columns,
          data: this.grid.data,
          attrs: { style: { minWidth: `${minWidth}px` } },
          onlyHead: true,
          line: this.props.line,
        },
      });
    }
    _rendered() {
      const that = this;
      this._fixSettingHeight(); // this._fixRightPadding()
      if (!this.grid.props.sticky) {
        return;
      }
      if (!this.scrollbar) {
        this.scrollbar = new Scrollbar({ target: this.grid });
      }
      this._hideScrolls();
      this.position = null;
      this.size = null;
      if (this.grid.props.sticky === true) {
        this.scrollParent = window;
        this.scrollParent.onscroll = function () {
          that._onPageScroll();
        };
      } else {
        if (isFunction(this.grid.props.sticky)) {
          this.scrollParent = this.grid.props.sticky();
        } else {
          this.scrollParent = this.grid.props.sticky;
        }
        this.scrollParent._on("scroll", function () {
          that._onPageScroll();
        });
        setTimeout(() => {
          if (this.scrollParent) {
            this.scrollParent.element.scrollTop += 1;
            this.scrollParent.element.scrollTop -= 1;
          }
        }, 0);
      }
    }
    _remove() {
      this.scrollbar && this.scrollbar._remove();
    }
    _fixSettingHeight() {
      const h = this.element.offsetHeight;
      const settingEl = this.grid.element.querySelector(".nom-grid-setting");
      if (settingEl) settingEl.style.height = `${h - 1}px`;
    }
    _fixRightPadding() {
      this.element.style.overflowY = "auto";
      setTimeout(() => {
        if (!this.element) {
          return;
        }
        const offset = this.element.offsetWidth - this.element.scrollWidth;
        if (!offset > 1) {
          this.element.style.overflowY = "hidden";
        }
      }, 200);
    }
    _hideScrolls() {
      const scrolls = document.getElementsByClassName("nom-scrollbar");
      if (!scrolls.length) {
        return;
      }
      for (let i = 0; i < scrolls.length; i++) {
        scrolls[i].classList.add("s-hidden");
      }
    }
    _onPageScroll() {
      if (!this.props) {
        return;
      }
      this.element.style.transform = `translateY(0px)`;
      let pRect = null;
      if (this.grid.props.sticky === true) {
        pRect = { top: 0, height: window.innerHeight };
      } else {
        pRect = this.scrollParent.element.getBoundingClientRect();
      }
      const gRect = this.grid.element.getBoundingClientRect();
      !this.position && this._setScrollerRect({ pRect: pRect, gRect: gRect });
      this._setScrollerVisible({ pRect: pRect, gRect: gRect });
    }
    _setScrollerRect(data) {
      const { pRect, gRect } = data;
      const innerWidth = this.element.scrollWidth;
      const bottom = window.innerHeight - (pRect.top + pRect.height);
      this.position = {
        left: `${gRect.left}px`,
        bottom: `${bottom < 0 ? 0 : bottom}px`,
      };
      this.size = { width: `${gRect.width}px`, innerWidth: `${innerWidth}px` };
      this.scrollbar.update({ position: this.position, size: this.size });
    }
    _setScrollerVisible(data) {
      const { pRect, gRect } = data;
      const { scrollbarWidth } = this.grid.props;
      if (gRect.top < pRect.top && gRect.top + gRect.height > pRect.top) {
        this.element.style.transform = `translateY(${
          pRect.top - gRect.top - 2
        }px)`;
        if (this.grid.settingContainer) {
          this.grid.settingContainer.element.style.transform = `translateY(${
            pRect.top - gRect.top - 2
          }px)`;
        }
      } else if (this.grid.settingContainer) {
        this.grid.settingContainer.element.style.transform = `translateY(0px)`;
      }
      if (
        gRect.top < pRect.height + pRect.top &&
        gRect.top + gRect.height - scrollbarWidth - this._summaryHeight >
          pRect.top + pRect.height
      ) {
        this.scrollbar.show();
      } else {
        this.scrollbar.hide();
      }
    }
    /**
     *  style.left style.right 
     * @param {number} triggerTh  th 
     */ _processFixedColumnSticky(triggerTh) {
      const { table } = triggerTh;
      const { thRefs } = table;
      const { colList } = table.colGroup;
      colList.forEach((col) => {
        if (col.column.fixed) {
          thRefs[col.name] && thRefs[col.name].setStickyPosition(true);
        }
      });
    }
  }
  Component.register(GridHeader);
  class GridSettingTransfer extends Field {
    constructor(props, ...mixins) {
      super(
        Component.extendProps(GridSettingTransfer.defaults, props),
        ...mixins
      );
    }
    _created() {
      super._created();
      this.grid = this.props.grid;
      this.warningFunc = null;
      this.selectedKeys = [];
      this.selectedData = this.props.allowFrozenCols
        ? [
            {
              title: this.grid.props.frozenText,
              field: "isFrozen",
              isDivider: true,
            },
            {
              title: this.grid.props.unfreezeText,
              field: "isFree",
              isDivider: true,
            },
          ]
        : [];
    }
    _config() {
      const me = this;
      const { data, dataFields, value, showSearch } = this.props;
      let initKeys = [];
      if (this.props.value) {
        if (isString(value)) {
          initKeys = [value];
        } else {
          initKeys = value;
        }
      }
      this.setProps({
        control: {
          children: {
            component: "Flex",
            classes: { "nom-grid-setting-transfer-container": true },
            align: "center",
            gutter: "large",
            cols: [
              {
                children: {
                  component: "Layout",
                  classes: { "nom-grid-setting-transfer-box": true },
                  header: {
                    children: {
                      component: "Flex",
                      align: "center",
                      fit: true,
                      cols: [
                        {
                          grow: true,
                          children: {
                            component: "Button",
                            text: me.grid.props.selectAllText,
                            size: "small",
                            ref: (c) => {
                              me.checkAllBtn = c;
                            },
                            type: "link",
                            onClick: ({ sender }) => {
                              if (
                                sender.props.text ===
                                me.grid.props.selectAllText
                              ) {
                                sender.update({
                                  text: me.grid.props.clearText,
                                });
                                me.checkAll();
                              } else {
                                sender.update({
                                  text: me.grid.props.selectAllText,
                                });
                                me.clear();
                              }
                            },
                          },
                        },
                        {
                          ref: (c) => {
                            me.sourceCount = c;
                          },
                          children: "",
                        },
                      ],
                    },
                  },
                  body: {
                    children: {
                      component: "Layout",
                      header: showSearch
                        ? {
                            _created: function () {
                              me.sourceSearchContainer = this;
                            },
                            children: {
                              component: "Textbox",
                              allowClear: true,
                              _created: function () {
                                me.sourceSearch = this;
                              },
                              placeholder: me.grid.props.searchAllText,
                              onValueChange: debounce(({ newValue }) => {
                                me._onSourceSearch(newValue);
                              }, 1000),
                            },
                          }
                        : false,
                      body: {
                        children: {
                          component: "Tree",
                          _created: function () {
                            me.sourceTree = this;
                          },
                          data: data,
                          dataFields: dataFields,
                          nodeSelectable: false,
                          expandable: { byIndicator: true },
                          nodeCheckable: {
                            cascade: true,
                            checkedNodeKeys: initKeys,
                            onCheckChange: ({ sender }) => {
                              me._setSourceCount();
                              me._handleCheckNode(sender);
                            },
                          },
                          nodeDefaults: {
                            onConfig: ({ inst }) => {
                              inst.setProps({
                                classes: {
                                  "nom-grid-setting-target-node": false,
                                },
                                data: { tools: null },
                              });
                            },
                            onClick: ({ sender, event }) => {
                              if (sender.checkboxRef.props.disabled) {
                                return;
                              }
                              if (sender.props.checked) {
                                sender.uncheck();
                              } else {
                                sender.check();
                              }
                              event.stopPropagation();
                            },
                          },
                        },
                      },
                    },
                  },
                  footer:
                    this.props.pagination || this.props.footerRender
                      ? {
                          children: this.props.footerRender
                            ? this.props.footerRender()
                            : {
                                component: "Flex",
                                fit: true,
                                align: "center",
                                justify: "end",
                                cols: [
                                  {
                                    children: {
                                      component: "Pager",
                                      itemsSort: ["pages"],
                                      totalCount: 50,
                                      simple: true,
                                      pageIndex: 1,
                                      pageSize: 20,
                                    },
                                  },
                                ],
                              },
                        }
                      : false,
                },
              },
              {
                children: {
                  component: "Layout",
                  classes: { "nom-grid-setting-transfer-box": true },
                  header: {
                    children: {
                      component: "Flex",
                      align: "center",
                      fit: true,
                      cols: [
                        {
                          grow: true,
                          children: {
                            component: "List",
                            items: [
                              { children: me.grid.props.shownColumnText },
                            ],
                          },
                        },
                      ],
                    },
                  },
                  body: {
                    children: {
                      component: "Layout",
                      header: showSearch
                        ? {
                            _created: function () {
                              me.targetSearchContainer = this;
                            },
                            children: {
                              component: "Textbox",
                              allowClear: true,
                              _created: function () {
                                me.targetSearch = this;
                              },
                              placeholder: me.grid.props.searchAddedText,
                              onValueChange: debounce(({ newValue }) => {
                                me._onTargetSearch(newValue);
                              }, 1000),
                            },
                          }
                        : false,
                      body: {
                        children: {
                          component: "Tree",
                          _created: function () {
                            me.targetTree = this;
                          },
                          data: [],
                          flatData: me.props.displayAsTree,
                          dataFields: Object.assign({}, dataFields),
                          nodeSelectable: false,
                          sortable: {
                            filter: ".nom-grid-setting-group-title",
                            onMove: function (evt) {
                              if (!me.props.allowFrozenCols) {
                                return;
                              }
                              me.warningFunc = null;
                              const toKey = evt.related.component.key;
                              const siblings =
                                evt.dragged.parentNode.childNodes;
                              let idx = 0;
                              let dividerIdx = 0;
                              siblings.forEach((n, i) => {
                                if (n.component.key === toKey) {
                                  idx = i;
                                }
                                if (n.component.key === "isFree") {
                                  dividerIdx = i;
                                }
                              });
                              const str = me.grid.props.maxColumnText.replace(
                                "{{limit}}",
                                me.grid.props.frozenLimit
                              );
                              if (dividerIdx > me.grid.props.frozenLimit) {
                                me.warningFunc = () => {
                                  new nomui.Message({
                                    content: str,
                                    type: "warning",
                                  });
                                };
                                return false;
                              }
                              if (
                                evt.dragged.querySelector(".nom-tree-nodes") &&
                                idx <= dividerIdx
                              ) {
                                me.warningFunc = () => {
                                  new nomui.Message({
                                    content: me.grid.props.noGroupFronzeText,
                                    type: "warning",
                                  });
                                };
                                return false;
                              }
                              if (
                                evt.related.innerHTML.includes(
                                  me.grid.props.frozenText
                                )
                              ) {
                                return 1;
                              }
                            },
                            onEnd: function () {
                              const keys = me._getChildNodeKeys(
                                me.targetTree.getChildNodes(),
                                true
                              );
                              me.selectedData = keys.map((n) => {
                                const _me$targetTree$getNod = me.targetTree.getNode(
                                    n
                                  ).props.data,
                                  obj = _objectWithoutPropertiesLoose2(
                                    _me$targetTree$getNod,
                                    ["children"]
                                  );
                                return obj;
                              });
                              me.warningFunc && me.warningFunc();
                            },
                          },
                          expandable: { byIndicator: true },
                          nodeCheckable: false,
                          nodeDefaults: {
                            onConfig: ({ inst }) => {
                              if (inst.props.data.isDivider) {
                                inst.setProps({
                                  disabled: true,
                                  classes: {
                                    "nom-grid-setting-group-title": true,
                                  },
                                });
                              } else {
                                inst.setProps({
                                  classes: {
                                    "nom-grid-setting-target-node": true,
                                  },
                                  data: {
                                    tools: ({ node }) => {
                                      if (node.props.data.disabled) {
                                        return;
                                      }
                                      return {
                                        component: "Button",
                                        type: "text",
                                        icon: "times",
                                        inline: true,
                                        onClick: ({ event }) => {
                                          me._handleRemoveNode(node);
                                          event.stopPropagation();
                                        },
                                      };
                                    },
                                  },
                                });
                              }
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _rendered() {
      if (this.firstRender) {
        this._setSourceCount();
        this._initAddNodes();
      }
    }
    _getChildNodeKeys(nodes, ignoreCheck) {
      const result = [];
      nodes.forEach((node) => {
        if (ignoreCheck || node.isChecked()) {
          result.push(node.key);
        }
        if (node.getChildNodes().length) {
          Array.prototype.push.apply(
            result,
            this._getChildNodeKeys(node.getChildNodes(), ignoreCheck)
          );
        }
      });
      return result;
    }
    _getChildNodes(nodes, ignoreCheck) {
      const result = [];
      nodes.forEach((node) => {
        if (ignoreCheck || node.isChecked()) {
          result.push(node);
        }
        if (node.getChildNodes().length) {
          Array.prototype.push.apply(
            result,
            this._getChildNodes(node.getChildNodes(), ignoreCheck)
          );
        }
      });
      return result;
    }
    _showParent(node) {
      const p = node.parentNode.parentNode;
      if (p.classList.contains("nom-tree-node")) {
        p.classList.remove("s-hidden");
        this._showParent(p);
      }
    }
    _onSourceSearch(val) {
      this.sourceTree.element
        .querySelectorAll(".nom-tree-node")
        .forEach((n) => {
          if (
            !val ||
            n
              .querySelector(".nom-tree-node-content-text")
              .innerHTML.includes(val)
          ) {
            n.classList.remove("s-hidden");
            this._showParent(n);
          } else {
            n.classList.add("s-hidden");
          }
        });
    }
    _onTargetSearch(val) {
      this.targetTree.element
        .querySelectorAll(".nom-tree-node")
        .forEach((n) => {
          if (
            !val ||
            n
              .querySelector(".nom-tree-node-content-text")
              .innerHTML.includes(val)
          ) {
            n.classList.remove("s-hidden");
            this._showParent(n);
          } else {
            n.classList.add("s-hidden");
          }
        });
    }
    _setSourceCount() {
      const u = this.sourceTree.getCheckedNodeKeys().length;
      const d = this._getChildNodeKeys(this.sourceTree.getChildNodes(), true)
        .length;
      const str = this.grid.props.columnStatsText
        .replace("{{current}}", u)
        .replace("{{total}}", d);
      this.sourceCount.update({ children: str });
      if (u === d) {
        this.checkAllBtn.update({ text: this.grid.props.clearText });
      } else {
        this.checkAllBtn.update({ text: this.grid.props.selectAllText });
      }
    }
    _processChecked(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const node = this.sourceTree.getNode(nodes[i]);
        if (!node.isChecked()) {
          continue;
        } // 
        if (!this.selectedKeys.includes(node.key)) {
          this.selectedKeys.push(node.key);
          if (node.parentNode) {
            node.props.data.parentKey = node.parentNode.key;
          }
          this.selectedData.push(node.props.data);
        }
      }
    }
    _initAddNodes() {
      const nodes = this._getChildNodeKeys(this.sourceTree.getChildNodes());
      this._processChecked(nodes);
      if (this.props.allowFrozenCols && this.props.frozenCount > 0) {
        this.selectedData = this.selectedData.filter((n) => {
          return n.field !== "isFree";
        });
        this.selectedData.splice(this.props.frozenCount + 1, 0, {
          title: this.grid.props.unfreezeText,
          field: "isFree",
          isDivider: true,
        });
      }
      this.targetTree.update({ data: this.selectedData });
      this._setSourceCount();
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: this.getValue() });
    }
    _handleCheckNode(node) {
      if (node.props.checked === true) {
        this._cascadeAddNodes(node);
      } else if (node.props.checked === false) {
        this._cascadeRemoveNodes(node);
      }
      this.targetTree.update({ data: this.selectedData });
      this._setSourceCount();
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: this.getValue() });
    }
    _handleRemoveNode(node) {
      const keys = this._getChildNodeKeys([node], true);
      this.checkAllBtn.update({ text: this.grid.props.selectAllText });
      this._uncheckItem(keys);
      this._removeItem(keys);
    }
    _cascadeAddNodes() {
      const tmp = this.sourceTree.getCheckedNodeKeys();
      const arr = [];
      tmp.forEach((n) => {
        if (!this.selectedKeys.includes(n)) {
          arr.push(n);
        }
      });
      arr.forEach((n) => {
        this.selectedKeys.push(n);
        const node = this.sourceTree.getNode(n);
        if (node.parentNode) {
          node.props.data.parentKey = node.parentNode.key;
        }
        this.selectedData.push(node.props.data);
      });
      this.targetTree.update({ data: this.selectedData });
    }
    _cascadeRemoveNodes() {
      const tmp = this.sourceTree.getCheckedNodeKeys();
      const arr = [];
      this.selectedKeys.forEach((n) => {
        if (!tmp.includes(n)) {
          arr.push(n);
        }
      });
      this._removeItem(arr);
    }
    _uncheckItem(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const nodeKey = nodes[i];
        if (this.sourceTree.getNode(nodeKey)) {
          this.sourceTree.getNode(nodeKey).uncheck();
        }
      }
    }
    _removeItem(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const nodeKey = nodes[i];
        this.selectedKeys = this.selectedKeys.filter((n) => {
          return n !== nodeKey;
        });
        if (
          this.targetTree.getNode(nodeKey) &&
          this.targetTree.getNode(nodeKey).props
        ) {
          this.targetTree.getNode(nodeKey).remove();
        }
      }
      this.selectedData = this.selectedData.filter((n) => {
        return this.selectedKeys.includes(n.field) || n.isDivider === true;
      });
    }
    checkAll() {
      this.sourceTree.checkAllNodes();
      this._initAddNodes();
    }
    clear() {
      this.checkAllBtn.update({ text: this.grid.props.selectAllText });
      this.selectedKeys = [];
      this.selectedData = this.selectedData.filter((n) => {
        if (n.disabled) {
          this.selectedKeys.push(n.field);
        }
        return n.isDivider || n.disabled;
      });
      this.sourceTree.update({
        data: this.props.data,
        nodeCheckable: { checkedNodeKeys: this.selectedKeys },
      });
      this.targetTree.update({ data: this.selectedData });
      this._setSourceCount();
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: this.getValue() });
    }
    getValue() {
      const keys = this._getChildNodeKeys(
        this.targetTree.getChildNodes(),
        true
      );
      if (!keys || !keys.length) {
        return null;
      }
      return keys;
    }
    getData() {
      return this.sourceTree.getData();
    }
    getFrozenCount() {
      let num = 0;
      this.targetTree.getData().forEach((n, i) => {
        if (n.field === "isFree") {
          num = i - 1;
        }
      });
      return num;
    }
    getSelectedData() {
      function mapTree(arr) {
        return arr.map((n) => {
          const obj = n.props.data;
          const c = n.getChildNodes();
          if (c.length) {
            obj.children = mapTree(c);
          }
          return obj;
        });
      }
      const data = mapTree(this.targetTree.getChildNodes()).filter((n) => {
        return n.isDivider !== true;
      });
      return data;
    }
  }
  GridSettingTransfer.defaults = {
    data: [],
    value: null,
    itemRender: null,
    showSearch: true,
    frozenCount: null,
    displayAsTree: true,
    dataFields: {
      key: "field",
      text: "title",
      children: "children",
      parentKey: "parentKey",
    },
  };
  Component.register(GridSettingTransfer);
  class GridSettingPopup extends Modal {
    constructor(props, ...mixins) {
      const defaults = { size: { width: 545 } };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.grid = this.props.grid;
      this.tree = null;
      this.tempArr = [];
    }
    _config() {
      const that = this;
      const { okText, cancelText } = this.grid.props;
      const rowCheckerCount =
        that.grid.props.rowCheckable &&
        !that.grid.props.rowCheckable.checkboxOnNodeColumn
          ? 1
          : 0;
      this.setProps({
        classes: { "nom-grid-setting-panel": true },
        content: {
          component: "Panel",
          uistyle: "card",
          header: { caption: { title: that.grid.props.columnSettingText } },
          body: {
            children: {
              component: GridSettingTransfer,
              ref: (c) => {
                that.transferRef = c;
              },
              grid: this.grid,
              allowFrozenCols: that.grid.props.allowFrozenCols,
              frozenLimit: that.grid.props.frozenLimit,
              value: this.grid.getMappedColumns(this.grid.props.columns),
              frozenCount: that.grid.props.frozenLeftCols - rowCheckerCount,
              data: that.customizableColumns(that.grid.popupTreeData),
            },
          },
          footer: {
            children: {
              component: "Flex",
              gutter: "small",
              attrs: { style: { width: "100%" } },
              cols: [
                { grow: true },
                {
                  children: {
                    component: "Button",
                    type: "primary",
                    text: okText,
                    onClick: function () {
                      that._fixDataOrder();
                    },
                  },
                },
                {
                  children: {
                    component: "Button",
                    text: cancelText,
                    onClick: () => {
                      this.hide();
                    },
                  },
                },
              ],
              items: null,
            },
          },
        },
      });
      super._config();
    }
    _fixDataOrder() {
      const { columnsLimitTitle, columnsLimitDescription } = this.grid.props;
      const list = this.transferRef.getSelectedData();
      const selected = JSON.parse(JSON.stringify(list));
      const frozenCount = this.transferRef.getFrozenCount();
      const lockedList = list.filter((n) => {
        return n.disabled === true;
      });
      if (
        list.length === 0 ||
        (list.length === lockedList.length &&
          list.length === 1 &&
          !(
            this.grid.props.rowCheckable &&
            this.grid.props.rowCheckable.checkboxOnNodeColumn
          ))
      ) {
        new nomui.Alert({
          type: "info",
          title: columnsLimitTitle,
          description: columnsLimitDescription,
        });
        return false;
      }
      const originData = this.transferRef.getData();
      const result = this._mapTree(list, originData);
      this.grid._updateOriginColumns(result);
      this.grid.handleColumnsSetting(
        this._sortCustomizableColumns(selected),
        frozenCount
      );
    }
    _findItem(arr, key) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i].field === key) {
          this.tempArr = arr[i].children;
          break;
        }
        if (arr[i].children) {
          this._findItem(arr[i].children, key);
        }
      }
    }
    _mapTree(data, origin) {
      data = this._concatArr(data, origin);
      for (let i = 0; i < data.length; i++) {
        if (data[i].children) {
          this._findItem(origin, data[i].field);
          const related = this.tempArr;
          data[i].children = this._mapTree(data[i].children, related || []);
        }
      }
      return data;
    }
    _concatArr(target, related) {
      const restItem = related.filter((n) => {
        return (
          target.findIndex((x) => {
            return x.field === n.field;
          }) === -1
        );
      });
      return [...target, ...restItem];
    }
    getMappedColumns(param) {
      const arr = [];
      function mapColumns(data) {
        data.forEach(function (item) {
          if (item.children) {
            mapColumns(item.children);
          }
          arr.push(item.field);
        });
      }
      mapColumns(param);
      return arr;
    }
    customizableColumns(val) {
      const that = this;
      function mapColumns(data) {
        data.forEach(function (item) {
          if (item.isChecker === true || item.customizable === false) {
            item.hidden = true;
            item.disabled = true;
          }
          if (
            that.grid.props.treeConfig &&
            that.grid.props.treeConfig.treeNodeColumn === item.field
          ) {
            item.disabled = true;
          }
          if (item.children) {
            mapColumns(item.children);
          }
        });
      }
      mapColumns(val);
      return val;
    } // customizable: false
    _sortCustomizableColumns(arr) {
      arr = arr.filter((n) => {
        return n.customizable !== false;
      });
      const disableColumns = this.grid.originColumns.filter((n) => {
        return n.customizable === false;
      });
      arr = [...arr, ...disableColumns];
      return arr;
    }
    _toogleCheckall() {
      const { selectAllText, deselectAllText } = this.grid.props;
      if (this.checkallBtn.props.text === selectAllText) {
        this.tree.checkAllNodes({ ignoreDisabled: true });
        this.checkallBtn.update({ text: deselectAllText });
      } else {
        this.tree.uncheckAllNodes({ ignoreDisabled: true });
        this.checkallBtn.update({ text: selectAllText });
      }
    }
  }
  Component.register(GridSettingPopup);
  class Grid extends Component {
    constructor(props, ...mixins) {
      Grid._loopSetValue(props.treeConfig, [
        "cascadeCheckParent",
        "cascadeCheckChildren",
        "cascadeUncheckParent",
        "cascadeUncheckChildren",
      ]);
      super(Component.extendProps(Grid.defaults, props), ...mixins);
    }
    _created() {
      this.minWidth = 0;
      this.lastSortField = null;
      this._alreadyProcessedFlat = false;
      this.rowsRefs = {};
      this.checkedRowRefs = {};
      this.partCheckedRowRefs = {};
      this._shouldAutoScroll = true;
      this._customColumnFlag = false; // 
      this._pinColumnFlag = false; // 
      this._defaultData = extend([], this.props.data);
      this.props.columns = this.props.columns.filter((n) => {
        return Object.keys(n).length;
      });
      this.pinColumns = [];
      this.originColumns = [...this.props.columns];
      this._needSortColumnsFlag = true; // 
      this.sortUpdated = false;
      this.filter = {};
      this.filterValueText = {};
      this._resetFixCount();
      this.pageIndex = 1;
      this.modifiedRowKeys = [];
      this.addedRowKeys = [];
      this.removedRowKeys = [];
      this.removedRowData = [];
      if (this.props.frozenLeftCols > 0) {
        this.props.rowCheckable &&
          !this.props.rowCheckable.checkboxOnNodeColumn &&
          this.props.frozenLeftCols++;
        this.props.rowExpandable && this.props.frozenLeftCols++;
      }
    }
    _update(props) {
      //  updatecolumns, 
      if (props.columns) {
        const c = props.columns.filter((n) => {
          return Object.keys(n);
        });
        this._customColumnFlag = false;
        this._pinColumnFlag = false;
        this._needSortColumnsFlag = true;
        this.originColumns = [...c];
      } // data
      if (props.data && this.props) {
        this.pageIndex = 1;
        const { treeConfig } = this.props; // data, flatDataTree
        if (treeConfig && treeConfig.flatData) {
          this._alreadyProcessedFlat = false;
        } // modifiedRowKeys
        this._resetChangeCache();
        this._defaultData = extend([], props.data);
      }
      if (
        (props.hasOwnProperty("rowCheckable") &&
          !props.rowCheckable.checkboxOnNodeColumn) ||
        props.hasOwnProperty("rowExpandable")
      ) {
        this._resetFixCount();
      }
    }
    _resetFixCount() {
      this._fixedCount = 0;
      this.props.rowCheckable &&
        !this.props.rowCheckable.checkboxOnNodeColumn &&
        this._fixedCount++;
      this.props.rowExpandable && this._fixedCount++;
    }
    _config() {
      this.nodeList = {};
      if (this.props.lazyLoadLimit && this.props.lazyLoadLimit > 0) {
        const current = this.props.data.slice(0, this.props.lazyLoadLimit);
        this._storedData = this.props.data.slice(this.props.lazyLoadLimit);
        this.props.data = current;
      }
      if (this.props.frozenLeftCols || this.props.frozenRightCols) {
        this.props.forceSort = true;
      } //  data check
      this.rowsRefs = {};
      this.checkedRowRefs = {};
      this._propStyleClasses = ["bordered"];
      if (this.props.ellipsis === true) {
        this.props.ellipsis = "both";
      } // excelModeeditable, editable
      if (this.props.excelMode && this.props.editable) {
        this.props.editable = false;
      }
      this._processData(); // 
      this.checkSortInfo();
      this._processColumns();
      this._calcMinWidth();
      const { line, rowDefaults, scrollbarWidth } = this.props;
      if (!scrollbarWidth || !isNumeric(scrollbarWidth)) {
        this.props.scrollbarWidth = this._getScrollbarWidth() || 8;
      }
      this.setProps({
        classes: {
          "m-frozen-header": this.props.frozenHeader,
          "m-with-setting": !!this.props.columnsCustomizable,
          "m-excel-mode": !!this.props.excelMode,
          "m-editable": !!this.props.editable,
        },
        children: [
          {
            ref: (c) => {
              this.settingContainer = c;
            },
            classes: {
              "nom-grid-setting": true,
              [`p-line-${this.props.line}`]: true,
            },
            renderIf: !!this.props.columnsCustomizable,
            children: {
              component: "Button",
              ref: (c) => {
                this.settingBtn = c;
              },
              icon: "setting",
              size: "small",
              type: "text",
              classes: { "nom-grid-setting-btn": true },
              attrs: { title: this.props.columnSettingText },
              onClick: () => {
                this.showSetting();
              },
            },
          },
          this.props.header !== false && { component: GridHeader, line: line },
          { component: GridBody, line: line, rowDefaults: rowDefaults },
          this.props.summary && { component: GridFooter, line: line },
        ],
      });
    }
    _processData() {
      const { treeConfig } = this.props; //  flatData
      if (treeConfig && treeConfig.flatData && !this._alreadyProcessedFlat) {
        this.setProps({ data: this._setTreeGridData(this.props.data) });
        this._alreadyProcessedFlat = true;
      }
    } // 
    _processColumns() {
      this._processColumnsCustom();
      this._processPinColumn();
      this._processColumnSort();
      this._processCheckableColumn();
      this._processExpandableColumn();
      this._processFrozenColumn();
    }
    _processPinColumn() {
      const { columnFrozenable } = this.props;
      if (this._pinColumnFlag || !columnFrozenable || !columnFrozenable.cache)
        return;
      this._gridColumsFixedStoreKey = this._getStoreKey(
        true,
        STORAGE_KEY_GRID_COLS_FIXED
      );
      if (!this._gridColumsFixedStoreKey) return; // 
      let storeFields = localStorage.getItem(this._gridColumsFixedStoreKey);
      if (storeFields && storeFields.length) {
        storeFields = JSON.parse(storeFields); // columns storeFields
        this.pinColumns = this._getColsFromFields(
          this.props.columns,
          storeFields,
          false
        );
        this.setProps({
          frozenLeftCols: this.pinColumns.length
            ? this._fixedCount + this.pinColumns.length
            : 0,
        });
        this._pinColumnFlag = true;
      }
    }
    _getScrollbarWidth() {
      const outer = document.createElement("div");
      outer.style.visibility = "hidden";
      outer.style.overflow = "scroll";
      document.body.appendChild(outer); // 
      const scrollbarWidth = outer.offsetWidth - outer.clientWidth;
      document.body.removeChild(outer);
      return scrollbarWidth;
    }
    _sortColumnsOrder(arr) {
      arr.sort((curr, next) => {
        if (next.customizable === false) return -1;
        return 0;
      });
      return arr;
    } // originColumns columns
    _processColumnSort() {
      if (this._needSortColumnsFlag) {
        let customFields = localStorage.getItem(this._gridColumsStoreKey);
        let fixedFields = localStorage.getItem(this._gridColumsFixedStoreKey);
        customFields = JSON.parse(customFields); //  pinColumns
        fixedFields =
          JSON.parse(fixedFields) || this.pinColumns.map((item) => item.field);
        this._sortColumnsFromFields(this.originColumns, customFields);
        this._sortColumnsFromFields(this.originColumns, fixedFields);
        this._sortColumnsFromFields(this.props.columns, customFields);
        this._sortColumnsFromFields(this.props.columns, fixedFields);
        this._needSortColumnsFlag = false;
      }
    }
    _processFrozenColumn() {
      this._parseBrowerVersion();
      const { frozenLeftCols, frozenRightCols } = this.props;
      if (frozenLeftCols !== null || frozenRightCols !== null) {
        const rev = this.props.columns.length - frozenRightCols;
        const c = this.props.columns.map(function (n, i, arr) {
          if (i + 1 <= frozenLeftCols) {
            return Object.assign({}, n, {
              fixed: "left",
              lastLeft: i + 1 === frozenLeftCols ? true : null,
            });
          }
          if (i >= rev) {
            return Object.assign({}, n, {
              fixed: "right",
              firstRight: i === rev ? true : null,
              lastRight: i === arr.length - 1 ? true : null,
            });
          }
          return Object.assign({}, n, {
            fixed: null,
            lastLeft: null,
            firstRight: null,
            lastRight: null,
          });
        });
        this.setProps({ columns: c });
      }
    }
    _setTreeGridData(arr) {
      const { keyField } = this.props;
      const { parentField, childrenField } = this.props.treeConfig;
      if (!keyField || keyField === "" || !arr) return []; //   childrenField,
      arr.forEach(function (item) {
        delete item[childrenField];
      });
      const map = {}; // map
      arr.forEach((i) => {
        map[i[keyField]] = i; // keyField 
      });
      const treeData = [];
      arr.forEach((child) => {
        const mapItem = map[child[parentField]]; // parentFieldmap
        if (mapItem) {
          (mapItem[childrenField] || (mapItem[childrenField] = [])).push(child); // mapItemchildrenField, , childrenField[]
        } else {
          // 
          treeData.push(child);
        }
      });
      return treeData;
    }
    _resetChangeCache() {
      this.modifiedRowKeys = [];
      this.addedRowKeys = [];
      this.removedRowKeys = [];
      this.removedRowData = [];
      if (this.element) {
        this.element.querySelectorAll(".nom-grid-tr-modified").forEach((n) => {
          n.classList.remove("nom-grid-tr-modified");
        });
      }
    }
    _processModifedRows(key) {
      if (
        !this.addedRowKeys.includes(key) &&
        !this.modifiedRowKeys.includes(key)
      ) {
        this.modifiedRowKeys.push(key);
      }
    }
    _processAddedRows(key) {
      if (!this.addedRowKeys.includes(key)) {
        this.addedRowKeys.push(key);
      }
    }
    _processRemovedRows(data) {
      const key = data[this.props.keyField];
      if (this.addedRowKeys.includes(key)) {
        this.addedRowKeys = this.addedRowKeys.filter((n) => {
          return n !== key;
        });
      } else if (!this.removedRowKeys.includes(key)) {
        if (this.modifiedRowKeys.includes(key)) {
          this.modifiedRowKeys = this.modifiedRowKeys.filter((n) => {
            return n !== key;
          });
        }
        this.removedRowKeys.push(key);
        this.removedRowData.push(data);
      }
    }
    updateSummary() {
      if (this.props.summary) {
        this.footer.update({});
      }
    }
    getRemovedRowKeys() {
      return this.removedRowKeys;
    }
    validate() {
      const keys = Object.keys(this.rowsRefs);
      let validated = true;
      keys.forEach((n) => {
        if (validated === true && this.rowsRefs[n].validate() === false) {
          validated = false;
        }
      });
      return validated;
    }
    edit() {
      const keys = Object.keys(this.rowsRefs);
      keys.forEach((n) => {
        this.rowsRefs[n].edit();
      });
    }
    endEdit(options) {
      if (!options) {
        options = { ignoreChange: false };
      }
      const keys = Object.keys(this.rowsRefs);
      keys.forEach((n) => {
        this.rowsRefs[n].endEdit({ ignoreChange: options.ignoreChange });
      });
    }
    saveEditData() {
      const keys = Object.keys(this.rowsRefs);
      keys.forEach((n) => {
        this.rowsRefs[n].saveEditData();
      });
    }
    acceptChange() {
      this._resetChangeCache();
    }
    reset() {
      this.update({ data: this._defaultData, isSelfUpdate: true });
    }
    getChangedData() {
      this.saveEditData();
      const data = this.getData();
      const result = {};
      result.addedData = data.filter((n) => {
        return this.addedRowKeys.includes(n[this.props.keyField]);
      });
      result.modifiedData = data.filter((n) => {
        return this.modifiedRowKeys.includes(n[this.props.keyField]);
      });
      result.removedData = this.removedRowData;
      return result;
    }
    _parseBrowerVersion() {
      // stickyfrozen null
      if (!isBrowerSupportSticky()) {
        this.props.frozenLeftCols = null;
        this.props.frozenRightCols = null;
        this.props.allowFrozenCols = false;
        this.props.columnFrozenable = false;
      }
    }
    _processColumnsCustom() {
      const { columnsCustomizable } = this.props; // 
      if (!columnsCustomizable) return; // selectedcache
      if (this._customColumnFlag) return;
      const { selected, cache } = columnsCustomizable;
      if (selected && selected.length) {
        // originColumns selected
        this.setProps({
          columns: this._getColsFromSelectCols(this.originColumns, selected),
        });
        this._customColumnFlag = true;
      } //  key
      this._gridColumsStoreKey = this._getStoreKey(
        cache,
        STORAGE_KEY_GRID_COLUMNS
      );
      if (!this._gridColumsStoreKey) return; // colfield
      let storeFields = localStorage.getItem(this._gridColumsStoreKey);
      if (storeFields && storeFields.length) {
        storeFields = JSON.parse(storeFields);
        this.setProps({
          columns: this._sortColumnsOrder(
            this._getColsFromFields(this.originColumns, storeFields)
          ),
        });
        this._customColumnFlag = true;
      }
    }
    _getStoreKey(cache, prefix) {
      if (!cache) return null;
      const _isAutoKey = this.key.startWith("__key");
      if (_isAutoKey && !isString(cache)) {
        console.warn(
          `Please set a key for Grid or set the cache to a unique value of string type.`
        );
        return null;
      }
      return `${prefix}_${_isAutoKey ? cache : this.key}`;
    }
    _calcMinWidth() {
      this.minWidth = 0;
      const { props } = this;
      for (let i = 0; i < props.columns.length; i++) {
        const column = props.columns[i];
        if (column.width) {
          this.minWidth += column.width;
        } else {
          this.minWidth += 120;
        }
      }
    }
    _setScrollbarOnResize() {
      const updateScrollbarCol = () => {
        if (!this.element) {
          return;
        }
        const body = this.element.querySelector(".nom-grid-body"); // 
        const hasVScrollbar = body && body.scrollHeight > body.clientHeight; // footercolgroup nomui-grid-scrollbar-col
        const scrollbarCols = this.element.querySelectorAll(
          ".nomui-grid-scrollbar-col"
        );
        scrollbarCols.forEach((col) => {
          col.style.display = hasVScrollbar ? "" : "none";
        });
      }; // 
      updateScrollbarCol(); // 
      if (!this._resizeObserver) {
        this._resizeObserver = new ResizeObserver(updateScrollbarCol);
        this._resizeObserver.observe(this.element);
      }
    }
    _rendered() {
      const me = this;
      if (this.loadingInst) {
        this.loadingInst.remove();
        this.loadingInst = null;
      } // this._handleScrollbarVisibility()
      // this._setScrollbarOnResize()
      if (this.props.rowCheckable && this._checkboxAllRef) {
        this.changeCheckAllState();
      }
      if (
        this.props.data &&
        this.props.autoMergeColumns &&
        this.props.autoMergeColumns.length > 0
      ) {
        this.autoMergeCols();
      } // 
      if (this.props.excelMode || this.props.editable) {
        document.addEventListener("click", ({ target }) => {
          if (!me || !me.props) {
            return;
          }
          let outSider = true;
          if (
            target.closest(".nom-grid") &&
            target.closest(".nom-grid") === this.element
          ) {
            if (
              target.classList.contains("nom-grid-body") ||
              target.classList.contains("nom-th")
            ) {
              outSider = true;
            } else {
              outSider = false;
            }
          } else if (target.closest(".nom-popup")) {
            outSider = this._findPopupRoot(target);
          }
          if (outSider && this.lastEditTd) {
            this.lastEditTd.props && this.lastEditTd.endEdit();
            this.lastEditTd = null;
          }
        });
      }
      this._processColumnsWidth();
      this._processAutoScroll();
      this.overflowAncestor = this._checkOverflowAncestor();
      this.props.rowSortable && defaultSortableOndrop();
      if (this.props.lazyLoadLimit > 0 || this.props.lazyLoadRemote) {
        this._watchLazyLoad();
      }
    }
    _handleScrollbarVisibility() {
      const body = this.element.querySelector(".nom-grid-body");
      const checkScroll = () => {
        const hasScroll = body.scrollHeight > body.clientHeight;
        if (hasScroll) {
          body.style.overflowY = "scroll";
          body.style.paddingRight = "0";
        } else {
          body.style.overflowY = "hidden";
          body.style.paddingRight = `${this.props.scrollbarWidth}px`;
        }
      };
      checkScroll();
      if (!this._scrollResizeObserver) {
        this._scrollResizeObserver = new ResizeObserver(checkScroll);
        this._scrollResizeObserver.observe(body);
      }
      body.addEventListener("scroll", checkScroll);
    }
    _watchLazyLoad() {
      let ele = this.body.element;
      if (!this.element.style.height && this.overflowAncestor) {
        ele = this.overflowAncestor;
      } // Remove previous listener if it exists
      if (this._lazyLoadScrollHandler) {
        ele.removeEventListener("scroll", this._lazyLoadScrollHandler);
        this._lazyLoadScrollHandler = null;
      } // Create new handler
      this._lazyLoadScrollHandler = () => {
        if (ele.scrollHeight - ele.scrollTop === ele.clientHeight) {
          if (this.props.lazyLoadLimit) {
            this._storedData.length > 0 && this._addFromStoredData();
          }
          if (this.props.lazyLoadRemote) {
            this._addFromRemote();
          }
        }
      }; // Add new listener
      ele.addEventListener("scroll", this._lazyLoadScrollHandler); // Return cleanup function
      return () => {
        if (this._lazyLoadScrollHandler) {
          ele.removeEventListener("scroll", this._lazyLoadScrollHandler);
          this._lazyLoadScrollHandler = null;
        }
      };
    }
    _addFromRemote() {
      const { pageSize, loadData } = this.props.lazyLoadRemote;
      if (!isFunction(loadData)) {
        return;
      }
      loadData({ pageSize, pageIndex: this.pageIndex + 1 }).then((res) => {
        if (!res || !res.length) {
          return;
        }
        this.pageIndex += 1;
        res.forEach((n) => {
          this.appendRow({ data: n });
        });
      });
    }
    _addFromStoredData() {
      const arr = this._storedData.slice(0, this.props.lazyLoadLimit);
      this._storedData = this._storedData.slice(this.props.lazyLoadLimit);
      arr.forEach((n) => {
        this.appendRow({ data: n });
      });
    }
    _checkOverflowAncestor() {
      let currentElement = this.element;
      let overflowAncestor = null;
      while (currentElement !== null && currentElement instanceof Element) {
        const style = window.getComputedStyle(currentElement); //  overflow-y  overflow  auto  scroll
        if (
          ["auto", "scroll"].includes(style.overflowY) ||
          ["auto", "scroll"].includes(style.overflow)
        ) {
          overflowAncestor = currentElement;
          break;
        } //  <html>
        if (currentElement === document.documentElement) {
          break;
        } // 
        currentElement = currentElement.parentNode;
      }
      if (overflowAncestor) {
        return overflowAncestor;
      }
    }
    _findPopupRoot(target) {
      let flag = true;
      const popupRef = target.closest(".nom-popup").component;
      if (popupRef.opener && popupRef.opener.element) {
        const ele = popupRef.opener.element;
        if (ele.closest(".nom-grid") === this.element) {
          flag = false;
        } else if (ele.closest(".nom-popup")) {
          flag = this._findPopupRoot(ele);
        }
      }
      return flag;
    }
    getColumns() {
      return this.props.columns;
    }
    loading() {
      this.loadingInst = new Loading({ container: this.parent });
    }
    getMappedColumns(columns) {
      const arr = [];
      function mapColumns(data) {
        data.forEach(function (item) {
          if (item.children) {
            mapColumns(item.children);
          }
          arr.push(item.field);
        });
      }
      mapColumns(columns || this.originColumns);
      return arr;
    }
    setSortDirection(sorter) {
      const c = this.getColumns().map(this._setColumnItemDire(sorter));
      this.originColumns = this.originColumns.map(
        this._setColumnItemDire(sorter)
      ); // onSort update, autoScroll
      if (!isFunction(sorter.sortable) && !isString(sorter.sortable)) {
        this._shouldAutoScroll = false;
      }
      this.setProps({ columns: c });
      !this.firstRender && this.render();
    } // 
    _setColumnItemDire(sorter) {
      return (item) => {
        if (!sorter) {
          return Object.assign({}, item, { sortDirection: null });
        }
        if (item.field === sorter.field) {
          return Object.assign({}, item, {
            sortDirection: sorter.sortDirection,
          });
        }
        if (item.children) {
          item.children = item.children.map(this._setColumnItemDire(sorter));
        }
        return Object.assign({}, item, { sortDirection: null });
      };
    }
    handleSort(sorter) {
      this.props.sortCacheable && this.saveSortInfo(sorter);
      const key = sorter.field;
      if (!sorter.sortDirection && !this.props.forceSort) return;
      if (isFunction(sorter.sortable)) {
        let arr = [];
        if (this.lastSortField === key) {
          arr = this.props.data.reverse();
        } else {
          arr = this.props.data.sort(sorter.sortable);
        }
        this.setProps({ data: arr });
        this.setSortDirection(sorter);
        this.lastSortField = key;
        return;
      }
      if (nomui.utils.isString(sorter.sortable)) {
        let arr = [];
        if (this.lastSortField === key) {
          arr = this.props.data.reverse();
        } else if (sorter.sortable === "string") {
          arr = this.props.data.sort((a, b) =>
            localeCompareString(b, a, sorter.field)
          );
        } else if (sorter.sortable === "number") {
          arr = this.props.data.sort((a, b) => {
            return b[sorter.field] - a[sorter.field];
          });
        } else {
          arr = this.props.data.sort((a, b) => ascCompare(b, a, sorter.field));
        }
        this.setProps({ data: arr });
        this.setSortDirection(sorter);
        this.lastSortField = key;
        return;
      }
      this._callHandler(this.props.onSort, {
        field: sorter.field,
        sortDirection: sorter.sortDirection,
      });
      this.setSortDirection(sorter);
      this.lastSortField = key;
    }
    resetSort() {
      if (this.lastSortField) {
        this.header.table.thRefs[this.lastSortField].resetSort();
      }
      this.lastSortField = null;
      this.saveSortInfo(null);
    }
    saveSortInfo(sorter) {
      localStorage.setItem(`${this.key}-sort-info`, JSON.stringify(sorter));
      this.sortInfo = sorter;
    }
    getSortInfo() {
      return JSON.parse(localStorage.getItem(`${this.key}-sort-info`));
    }
    checkSortInfo() {
      //  ||  
      if (!this.firstRender || this.sortUpdated || this.startSort) return; // 
      const _sortInfo = this.getSortInfo();
      if (this.props.sortCacheable && _sortInfo) {
        this.startSort = true;
        this.setSortDirection(_sortInfo);
        this._callHandler(this.props.onSort, {
          field: _sortInfo.field,
          sortDirection: _sortInfo.sortDirection,
        });
      } else if (this.props.defaultSort && this.firstRender) {
        // 
        this.startSort = true;
        this.setSortDirection(this.props.defaultSort);
      }
      this.sortUpdated = true;
    } // update
    setScrollPlace(callback) {
      this._shouldAutoScroll = true;
      const info = this._setScrollPlace();
      if (callback) {
        callback(info);
      }
    } // 
    _setScrollPlace() {
      // grid headerbody
      const headerEl = this.header.element;
      const bodyEl = this.body.element; // grid sticky
      const { scrollParent } = this.header; // 3
      // 1.sticky, scrollTop  header.scrollParent
      // 2.Gridheight, scrollTop body
      // 3., overflow
      const headerLeft = headerEl.scrollLeft;
      const headerTop =
        scrollParent && scrollParent.element
          ? scrollParent.element.scrollTop
          : 0;
      const bodyLeft = bodyEl.scrollLeft;
      const bodyTop = bodyEl.scrollTop;
      let parentTop = null;
      if (
        !this.props.sticky &&
        !this.element.style.height &&
        this.overflowAncestor
      ) {
        parentTop = this.overflowAncestor.scrollTop;
      }
      this._headerScrollInfo = { top: headerTop, left: headerLeft };
      this._bodyScrollInfo = { top: bodyTop, left: bodyLeft };
      this._parentScrollInfo = { top: parentTop };
      return {
        header: this._headerScrollInfo,
        body: this._bodyScrollInfo,
        parent: this._parentScrollInfo,
      };
    }
    resetColumnsCustom() {
      if (this._gridColumsStoreKey) {
        localStorage.removeItem(this._gridColumsStoreKey);
      }
      this.setProps({ columns: this.originColumns });
      this._processColumns();
      this._calcMinWidth();
      this.render();
    }
    handleFilter(isReset) {
      const that = this;
      if (
        !isReset &&
        Object.keys(this.filter).filter(function (key) {
          return key !== "sender" && that.filter[key] !== null;
        }) < 1
      ) {
        return;
      }
      this.props.onFilter &&
        this._callHandler(this.props.onFilter, this.filter);
    }
    getRow(param) {
      let result = null;
      if (param instanceof Component) {
        return param;
      }
      if (isFunction(param)) {
        for (const key in this.rowsRefs) {
          if (this.rowsRefs.hasOwnProperty(key)) {
            if (param.call(this.rowsRefs[key]) === true) {
              result = this.rowsRefs[key];
              break;
            }
          }
        }
      } else if (isPlainObject(param)) {
        return this.rowsRefs[param[this.props.keyField]];
      } else {
        return this.rowsRefs[param];
      }
      return result;
    }
    removeRow(param, options = {}) {
      const row = this.getRow(param);
      row.remove(options);
    }
    getCheckedRows(options = { includePartialChecked: true }) {
      const arr = Object.keys(this.checkedRowRefs).map((key) => {
        return this.checkedRowRefs[key];
      });
      if (
        options.includePartialChecked !== false &&
        this.props.rowCheckable &&
        this.props.rowCheckable.includePartialChecked !== false
      ) {
        const partCheckedRows = Object.keys(this.partCheckedRowRefs).map(
          (key) => {
            return this.partCheckedRowRefs[key];
          }
        );
        arr.push(...partCheckedRows);
      }
      return arr.filter((rowRef) => !isNullish(rowRef.key));
    }
    getCheckedRowKeys(options = { includePartialChecked: true }) {
      const arr = Object.keys(this.checkedRowRefs).map((key) => {
        return this.checkedRowRefs[key].key;
      });
      if (
        options.includePartialChecked !== false &&
        this.props.rowCheckable &&
        this.props.rowCheckable.includePartialChecked !== false
      ) {
        const partCheckedKeys = Object.keys(this.partCheckedRowRefs).map(
          (key) => {
            return this.partCheckedRowRefs[key].key;
          }
        );
        arr.push(...partCheckedKeys);
      }
      return arr.filter((key) => !isNullish(key));
    } //  rowTr check
    checkAllRows(options) {
      const { rowsRefs } = this;
      Object.keys(rowsRefs).forEach((key) => {
        const refItem = rowsRefs[key];
        const { props } = refItem._checkboxRef; // _checkboxRef disabled || hidden, 
        if (!props || props.disabled || props.hidden) return;
        if (
          refItem.props &&
          !isNullish(refItem.props.data[this.props.keyField])
        ) {
          refItem.check(options);
        }
      });
    }
    uncheckAllRows(options) {
      const { rowsRefs } = this;
      Object.keys(rowsRefs).forEach((key) => {
        const refItem = rowsRefs[key];
        const { props } = refItem._checkboxRef; // _checkboxRef disabled || hidden, 
        if (!props || props.disabled || props.hidden) return;
        if (
          refItem.props &&
          !isNullish(refItem.props.data[this.props.keyField])
        ) {
          refItem.uncheck(options);
        }
      });
    }
    checkRows(rows, options) {
      rows = Array.isArray(rows) ? rows : [rows];
      rows.forEach((row) => {
        const rowRef = this.getRow(row);
        rowRef && rowRef.check(options);
      });
    }
    changeCheckAllState() {
      // 
      const operableRows = Object.keys(this.rowsRefs).filter((key) => {
        const refItem = this.rowsRefs[key];
        const { props } = refItem._checkboxRef;
        return props && !props.disabled && !props.hidden;
      }); // 
      const checkedOperableRows = Object.keys(this.checkedRowRefs).filter(
        (key) => {
          const refItem = this.rowsRefs[key]?._checkboxRef;
          return (
            refItem?.props && !refItem.props.disabled && !refItem.props.hidden
          );
        }
      );
      const operableRowsLength = operableRows.length;
      const checkedOperableRowsLength = checkedOperableRows.length;
      if (operableRowsLength === 0);
      else if (checkedOperableRowsLength === 0) {
        // 
        this._checkboxAllRef.setValue(false, false);
      } else if (operableRowsLength === checkedOperableRowsLength) {
        // 
        this._checkboxAllRef.setValue(true, false);
      } else {
        // 
        this._checkboxAllRef.partCheck(false);
      }
    }
    getKeyValue(rowData) {
      return rowData[this.props.keyField];
    }
    showSetting() {
      //  tree
      this.popupTreeData = this.originColumns;
      this.popup = new GridSettingPopup({
        align: "center",
        alignTo: window,
        grid: this, // fit: true,
      });
    }
    _updateOriginColumns(data) {
      this.popupTreeData = this.originColumns = data;
    }
    handleColumnsSetting(params, frozenCount) {
      const tree = params;
      const that = this;
      let treeInfo = null;
      function findTreeInfo(origin, key) {
        origin.forEach(function (item) {
          if (item.children) {
            findTreeInfo(item.children, key);
          }
          if (item.field === key) {
            treeInfo = item;
          }
        });
        if (treeInfo !== null) return treeInfo;
      }
      function addTreeInfo(data) {
        data.forEach(function (item) {
          if (item.children) {
            addTreeInfo(item.children);
          }
          const myinfo = findTreeInfo(that.originColumns, item.key);
          if (myinfo) {
            Object.keys(myinfo).forEach(function (key) {
              if (key !== "children") {
                item[key] = myinfo[key];
              }
            });
          }
        });
      }
      addTreeInfo(tree);
      const { columnsCustomizable } = this.props;
      if (this._gridColumsStoreKey) {
        localStorage.setItem(
          this._gridColumsStoreKey,
          JSON.stringify(this.getMappedColumns(tree))
        );
      }
      const rowCheckerCount =
        this.props.rowCheckable && !this.props.rowCheckable.checkboxOnNodeColumn
          ? 1
          : 0;
      this._customColumnFlag = false;
      this._processPinColumnFromSetting(tree);
      this.setProps({ columns: tree });
      if (this.props.allowFrozenCols) {
        this.setProps({
          frozenLeftCols: frozenCount < 1 ? 0 : frozenCount + rowCheckerCount,
        });
      }
      this._processColumns();
      this._calcMinWidth();
      this.render();
      this.popup.hide();
      columnsCustomizable.callback &&
        this._callHandler(columnsCustomizable.callback(tree));
    } //  pinColumns
    _processPinColumnFromSetting(columns) {
      if (!this._gridColumsFixedStoreKey) return;
      const { frozenLeftCols } = this.props;
      if (frozenLeftCols) {
        this.pinColumns = columns.slice(0, frozenLeftCols - this._fixedCount);
        localStorage.setItem(
          this._gridColumsFixedStoreKey,
          JSON.stringify(this.pinColumns.map((col) => col.field))
        );
      }
    }
    handleDrag({ item, oldIndex, newIndex }) {
      this._resortExpandedTr({ item, oldIndex, newIndex });
      if (this.props.rowSortable && this.props.rowSortable.onEnd) {
        this._callHandler(this.props.rowSortable.onEnd);
      }
    }
    _resortExpandedTr({ item }) {
      const row = item.component;
      if (!row) {
        return;
      } //  expandedRows
      this._adjustExpandedRows();
    }
    _adjustExpandedRows() {
      const table = this.body.table.element;
      const mainRows = Array.from(table.querySelectorAll("tr[data-key]"));
      const expandedRows = Array.from(
        table.querySelectorAll("tr.nom-expanded-tr")
      );
      mainRows.forEach((mainRow) => {
        const dataKey = mainRow.getAttribute("data-key");
        const correspondingExpandedRow = expandedRows.find(
          (row) => row.getAttribute("data-key") === dataKey
        );
        if (correspondingExpandedRow) {
          mainRow.insertAdjacentElement("afterend", correspondingExpandedRow);
        }
      });
    }
    getData(options = {}) {
      if (!this.props.data || !this.props.data.length) {
        return [];
      }
      if (options.saveEdit) {
        this.saveEditData();
      }
      const that = this;
      const keys = this.getDataKeys();
      const data = keys.map(function (key) {
        return that.props.data.filter(function (item) {
          return `${item[that.props.keyField]}` === `${key}`;
        })[0];
      });
      if (this.props.lazyLoadLimit && this._storedData.length) {
        return [...data, ...this._storedData];
      }
      return data;
    }
    getDataKeys() {
      const order = [];
      const trs = this.body.table.element.rows;
      for (let i = 0; i < trs.length; i++) {
        if (
          !!this.props.rowExpandable &&
          order.indexOf(trs[i].dataset.key) > -1
        ) {
          continue;
        }
        order.push(trs[i].dataset.key);
      }
      return order;
    }
    appendRow(rowProps) {
      this.emptyRef && this.emptyRef.props && this.emptyRef.hide();
      this.body.table.appendRow(rowProps);
      if (rowProps.data && rowProps.data[this.props.keyField]) {
        this._processAddedRows(rowProps.data[this.props.keyField]);
      }
    }
    checkChildren(row) {
      const { checked } = row.props;
      const { cascadeCheckChildren } = this.props.treeConfig;
      cascadeCheckChildren === true &&
        Object.keys(row.childrenNodes).forEach((key) => {
          this.checkChildren(row.childrenNodes[key]);
        });
      if (checked === true) {
        return;
      }
      row.check();
    } // 
    propagateParentState(node, isCheckOperation) {
      if (!node || !node.parentNode) return;
      const parent = node.parentNode; // 
      const newState = this.calculateParentState(parent, isCheckOperation); // 
      if (newState === "checked" && !parent.props.checked) {
        this.check(parent, true, false);
      } else if (
        newState === "unchecked" &&
        (parent.props.checked || parent.props.partChecked)
      ) {
        this.uncheck(parent, true);
      } else if (newState === "partial" && !parent.props.partChecked) {
        parent.partCheck();
      } // 
      this.propagateParentState(parent, isCheckOperation);
    }
    calculateParentState(parent, isCheckOperation) {
      const siblings = parent.childrenNodes;
      let hasChecked = false;
      let hasUnchecked = false;
      for (const k in siblings) {
        const sibling = siblings[k];
        if (sibling.props.checked) {
          hasChecked = true;
        } else if (sibling.props.partChecked) {
          return "partial"; // 
        } else {
          hasUnchecked = true;
        } // 
        if (hasChecked && hasUnchecked) {
          return "partial";
        }
      } // 
      return isCheckOperation
        ? hasChecked
          ? "checked"
          : "unchecked"
        : hasUnchecked
        ? "unchecked"
        : "checked";
    } // check
    check(row, fromChild, isPartCheck) {
      const { checked, partChecked } = row.props;
      const {
        cascadeCheckChildren,
        cascadeCheckParent,
      } = this.props.treeConfig; // 
      cascadeCheckChildren &&
        !fromChild &&
        Object.keys(row.childrenNodes).forEach((key) =>
          this.checkChildren(row.childrenNodes[key])
        ); // 
      if (isPartCheck ? !partChecked : !checked) {
        isPartCheck ? row.partCheck() : row.check();
      } else {
        return false;
      } // cascadeCheckParent
      cascadeCheckParent && this.propagateParentState(row, true);
    } // uncheck
    uncheck(row, fromChild) {
      const { checked, partChecked } = row.props;
      const {
        cascadeUncheckChildren,
        cascadeUncheckParent,
      } = this.props.treeConfig; // 
      cascadeUncheckChildren &&
        !fromChild &&
        Object.keys(row.childrenNodes).forEach((key) =>
          this.uncheck(row.childrenNodes[key])
        ); // 
      if (checked || partChecked) {
        row.uncheck();
      } else {
        return false;
      } // cascadeUncheckParent
      cascadeUncheckParent && this.propagateParentState(row, false);
    }
    _processCheckableColumn() {
      const { rowCheckable } = this.props;
      let { columns } = this.props;
      if (rowCheckable) {
        //  checkbox
        columns = columns.filter((item) => !item.isChecker);
        let normalizedRowCheckable = rowCheckable;
        if (!isPlainObject(rowCheckable)) {
          normalizedRowCheckable = {};
        }
        const { checkedRowKeys = [], toolbar } = normalizedRowCheckable;
        checkedRowKeys.forEach((rowKey) => {});
        if (!rowCheckable.checkboxOnNodeColumn) {
          columns.unshift({
            width: rowCheckable.width || 50,
            isChecker: true,
            resizable: false,
            field: "nom-grid-row-checker",
            classes: { "nom-grid-checkbox": true },
            toolbar,
          });
        }
        this.setProps({ columns: columns });
      }
    } // 
    _processColumnsWidth() {
      const { columnResizable } = this.props;
      const { cache } = columnResizable;
      this._gridColumsWidthStoreKey = this._getStoreKey(
        cache,
        STORAGE_KEY_GRID_COLS_WIDTH
      );
      const colWithString = localStorage.getItem(this._gridColumsWidthStoreKey);
      const _widthInfo = JSON.parse(colWithString) || {}; //  autoWidthcol.update
      this.originColumns.forEach((col) => {
        if (col.autoWidth) {
          _widthInfo[col.field] = 0;
        }
      });
      Object.keys(_widthInfo).forEach((key) => {
        const data = { field: key, width: _widthInfo[key] };
        this.resizeCol(data);
      });
    } // 
    _processAutoScroll() {
      // 
      this._shouldAutoScroll && this.autoScrollGrid();
      this._shouldAutoScroll = true;
    }
    autoMergeCols() {
      const that = this;
      this.props.autoMergeColumns.forEach(function (key) {
        that._mergeColumn(key);
      });
    }
    _mergeColumn(key) {
      const el = this.body.element.getElementsByTagName("table")[0];
      function getIndex(data) {
        for (let i = 0; i < el.rows[0].cells.length; i++) {
          if (el.rows[0].cells[i].getAttribute("data-field") === data) {
            return i;
          }
        }
      }
      const index = getIndex(key);
      for (let i = el.rows.length - 1; i > 0; i--) {
        el.rows[i].cells[index].rowSpan = el.rows[i].cells[index].rowSpan || 1;
        if (
          el.rows[i].cells[index].innerHTML ===
          el.rows[i - 1].cells[index].innerHTML
        ) {
          el.rows[i - 1].cells[index].rowSpan =
            el.rows[i].cells[index].rowSpan + 1;
          el.rows[i].cells[index].rowSpan = 0;
          el.rows[i].cells[index].style.display = "none";
        }
      }
    }
    autoScrollGrid(param) {
      let { _headerScrollInfo, _bodyScrollInfo, _parentScrollInfo } = this;
      if (param) {
        _headerScrollInfo = param.header;
        _bodyScrollInfo = param.body;
        _parentScrollInfo = param.parent;
      }
      if (_headerScrollInfo) {
        if (this.header.scrollParent) {
          this.header.scrollParent.element.scrollTop =
            _headerScrollInfo.top || 0;
        }
        this.header.element.scrollLeft = _headerScrollInfo.left || 0;
      }
      if (_bodyScrollInfo) {
        this.body.element.scrollLeft = _bodyScrollInfo.left || 0;
        this.body.element.scrollTop = _bodyScrollInfo.top || 0;
      }
      if (_parentScrollInfo && this.overflowAncestor) {
        this.overflowAncestor.scrollTop = _parentScrollInfo.top || 0;
      }
      this._headerScrollInfo = null;
      this._bodyScrollInfo = null;
      this._parentScrollInfo = null;
    }
    /**
     * width
     * @param {*} data {field, distance}
     */ calcResizeCol(data, thRef) {
      this.header &&
        this.header.props &&
        this.header.calcResizeCol(data, thRef);
      if (this.props.data && this.props.data.length) {
        this.body && this.body.props && this.body.calcResizeCol(data, thRef);
      }
      this.footer && this.footer.calcResizeCol(data, thRef);
    }
    /**
     * width
     * @param {*} data {field, width}
     */ resizeCol(data) {
      this.header && this.header.props && this.header.resizeCol(data);
      this.body && this.body.props && this.body.resizeCol(data);
      this.footer && this.footer.props && this.footer.resizeCol(data);
    }
    /**
     *  autoWidthTdcolmaxTdWidth
     * @param {*} data {field, maxTdWidth}
     */ setAllTableColMaxTdWidth(data) {
      this.header && this.header.props && this.header.setColMaxTdWidth(data);
      this.body && this.body.props && this.body.setColMaxTdWidth(data);
      this.footer && this.footer.props && this.footer.setColMaxTdWidth(data);
    } // 
    storeColsWidth(field) {
      const { _gridColumsWidthStoreKey: _storeKey } = this;
      if (!_storeKey) return; // storeKey _gridKey, cache 
      const colWithString = localStorage.getItem(_storeKey);
      const _widthInfo = colWithString ? JSON.parse(colWithString) : {};
      const col = this.header.table.colRefs[field];
      _widthInfo[field] = col.props.column.width;
      localStorage.setItem(_storeKey, JSON.stringify(_widthInfo));
    }
    /**
     *  colwidth
     * @param {string} field col 
     */ resetColsWidth(field = null) {
      const { _gridColumsWidthStoreKey: _storeKey } = this;
      if (!_storeKey) return; // originColumnswidth
      let resetCols = this.originColumns.filter(
        (item) => item.resizable || isNullish(item.resizable)
      );
      if (!field) {
        localStorage.removeItem(_storeKey);
      } else {
        resetCols = [this.originColumns.find((col) => col.field === field)];
        const colWithString = localStorage.getItem(_storeKey);
        const _widthInfo = colWithString ? JSON.parse(colWithString) : {};
        delete _widthInfo[field];
        if (Object.keys(_widthInfo).length) {
          localStorage.setItem(_storeKey, JSON.stringify(_widthInfo));
        } else {
          localStorage.removeItem(_storeKey);
        }
      }
      resetCols.forEach((col) => {
        const data = { field: col.field, width: col.width };
        this.resizeCol(data);
      });
    }
    _getColsFromSelectCols(originCols = [], selectCols = []) {
      return selectCols.reduce((acc, curr) => {
        const sameCol = originCols.find(
          (originCol) => originCol.field === curr.field
        );
        if (sameCol) {
          acc.push(
            Object.assign({}, curr, {
              children: this._getColsFromSelectCols(
                sameCol.children,
                curr.children
              ),
            })
          );
        }
        return acc;
      }, []);
    } //  columns
    _sortColumnsFromFields(columns, fields = []) {
      if (!fields || !fields.length) return; // Array.prototype.sort Firefoxfor
      for (let i = 0; i < fields.length; i++) {
        for (let j = i; j < columns.length; j++) {
          //  field
          if (isNullish(columns[j].field)) {
            const nullCol = columns.splice(j, 1);
            columns.push(nullCol[0]);
          } else if (columns[j].field === fields[i]) {
            // fields 
            const sameCol = columns.splice(j, 1);
            columns.splice(i, 0, sameCol[0]);
          }
        }
      }
    }
    _getColsFromFields(columns = [], fields = [], includeNullish = true) {
      return columns.reduce((acc, curr) => {
        // field
        if (isNullish(curr.field) && includeNullish) {
          acc.push(curr);
        } else if (fields.includes(curr.field)) {
          acc.push(
            Object.assign({}, curr, {
              children: this._getColsFromFields(curr.children, fields),
            })
          );
        }
        return acc;
      }, []);
    }
    _processExpandableColumn() {
      const { rowExpandable } = this.props;
      let { columns } = this.props;
      if (rowExpandable) {
        columns = columns.filter((item) => !item.isTreeMark);
        this.setProps({
          columns: [
            {
              width: 50,
              isTreeMark: true,
              resizable: false,
              cellRender: ({ row, rowData }) => {
                if (!row.expandedRow) {
                  row.expandedRow = row.after({
                    component: ExpandedTr,
                    data: rowData,
                    hidden: true,
                    parentRow: row,
                  });
                } else {
                  row.expandedRow.update({ data: rowData });
                }
                return {
                  component: ExpandIcon,
                  ref: (c) => {
                    row.expandIndicotorIconRef = c;
                  },
                  grid: this,
                  row,
                  hidden: true,
                  expandable: Object.assign(
                    {},
                    {
                      expandedProps: { type: "up-circle" },
                      collapsedProps: { type: "down-circle" },
                    },
                    rowExpandable,
                    {
                      byClick: true,
                      expanded: rowExpandable.expanded,
                      target: () => {
                        if (!row.expandedRow) {
                          row.expandedRow = row.after({
                            component: ExpandedTr,
                            data: rowData,
                          });
                        }
                        return row.expandedRow;
                      },
                    }
                  ),
                };
              },
            },
            ...columns,
          ],
        });
      }
    }
    _onRowCheck(row) {
      const { rowCheckable } = this.props;
      if (rowCheckable) {
        let normalizedRowCheckable = rowCheckable;
        if (!isPlainObject(rowCheckable)) {
          normalizedRowCheckable = {};
        }
        const { onCheck } = normalizedRowCheckable;
        this._callHandler(onCheck, { row: row });
      }
    }
    _onRowUncheck(row) {
      const { rowCheckable } = this.props;
      if (rowCheckable) {
        let normalizedRowCheckable = rowCheckable;
        if (!isPlainObject(rowCheckable)) {
          normalizedRowCheckable = {};
        }
        const { onUncheck } = normalizedRowCheckable;
        this._callHandler(onUncheck, { row: row });
      }
    }
    getRows() {
      return this.body.table.getRows();
    }
    handlePinClick(data) {
      if (this.pinColumns.length >= this.props.frozenLimit && !data.fixed) {
        new nomui.Message({
          content: `${this.props.frozenLimit}`,
          type: "warning",
        });
        return;
      } // ()
      if (data.fixed && this.pinColumns.length < 1) {
        let num = this.props.frozenLeftCols;
        if (num - 1 > this._fixedCount) {
          this.fixPinOrder(data);
          num--;
        } else {
          num = 0;
        }
        this.setProps({ frozenLeftCols: num }); // columns config
        this._processFrozenColumn();
        this.render();
        return;
      }
      if (this.pinColumns.find((n) => n.field === data.field)) {
        this.pinColumns = this.removeColumn(this.pinColumns, data);
      } else {
        this.pinColumns.push(data);
      }
      this._gridColumsFixedStoreKey &&
        localStorage.setItem(
          this._gridColumsFixedStoreKey,
          JSON.stringify(this.pinColumns.map((col) => col.field))
        );
      this.setProps({
        columns: this.getPinOrderColumns(),
        frozenLeftCols: this.pinColumns.length
          ? this.pinColumns.length + this._fixedCount
          : 0,
      });
      this._needSortColumnsFlag = !data.lastLeft;
      this._processColumns();
      this.render();
    }
    fixPinOrder(data) {
      const { columns } = this.props;
      const num = this.props.frozenLeftCols;
      if (columns[num - 1].field === data.field) {
        return;
      }
      let idx;
      for (let i = 0; i < columns.length; i++) {
        if (data.field === columns[i].field) {
          idx = i;
          break;
        }
      }
      const c = this.props.columns;
      const item = c.splice(idx, 1);
      c.splice(num - 1, 0, item[0]);
      this.setProps({ columns: c });
    }
    removeColumn(array, data) {
      if (array.length < 1) {
        return [];
      }
      return array.filter((n) => {
        return n.field !== data.field;
      });
    }
    getPinOrderColumns() {
      if (!this.pinColumns.length) {
        return this.props.columns;
      }
      let arr = [];
      this.pinColumns
        .slice()
        .reverse()
        .forEach((n) => {
          const arr2 = arr.length > 0 ? arr : this.props.columns;
          arr = this.removeColumn(arr2, n);
          arr.unshift(n);
        });
      return arr;
    }
    static getRowSortableHandler() {
      return {
        component: "Icon",
        classes: { "nom-grid-drag-handler": true },
        type: "drag",
      };
    }
  }
  Grid.defaults = {
    columns: [],
    data: null,
    frozenHeader: false,
    frozenLeftCols: null,
    frozenRightCols: null,
    allowFrozenCols: true,
    frozenLimit: 5, // 
    onSort: null,
    forceSort: false,
    sortCacheable: false,
    onFilter: null,
    rowSelectable: false,
    rowCheckable: false,
    keyField: "id",
    treeConfig: {
      flatData: false, // 
      parentField: "parentKey",
      childrenField: "children",
      treeNodeColumn: null,
      initExpandLevel: -1,
      indentSize: 16,
      cascadeCheckParent: true,
      cascadeCheckChildren: true,
      cascadeUncheckParent: true,
      cascadeUncheckChildren: true,
      cascade: false,
    },
    columnsCustomizable: false, // columnsCustomizable.selected: selected 
    // columnsCustomizable.cache: localstoragecachekey
    // columnsCustomizable.callback: 
    autoMergeColumns: null,
    columnResizable: false, // columnResizable.cache: boolean localstorage
    // columnResizable.allowFixedCol: ( data, false)
    columnFrozenable: false, // 
    // columnFrozenable.cache: boolean localstorage
    highlightModifiedRows: true, // 
    striped: false,
    showTitle: false,
    ellipsis: false,
    sticky: false,
    line: "row",
    bordered: false,
    scrollbarWidth: false,
    summary: null,
    showEmpty: true,
    columnAlign: "left",
    columnSettingText: "",
    totalizeText: "",
    okText: "",
    cancelText: "",
    columnsLimitTitle: "",
    columnsLimitDescription: "",
    selectAllText: "",
    clearText: "",
    deselectAllText: "",
    frozenText: "",
    unfreezeText: "",
    searchAllText: "",
    searchAddedText: "",
    shownColumnText: "",
    maxColumnText: "{{limit}}",
    noGroupFronzeText: "",
    columnStatsText: "{{current}}/{{total}}",
    onRowClick: null,
    excelMode: false, // excel
    editable: false, // 
    lazyLoadRemote: false,
    lazyLoadLimit: false,
  };
  Grid._loopSetValue = function (key, arry) {
    if (key === undefined || key.cascade === undefined) return false;
    arry.forEach(function (currentValue) {
      if (key[currentValue] === undefined) {
        key[currentValue] = key.cascade;
      }
    });
  };
  Component.register(Grid);
  class Toolbar extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Toolbar.defaults, props), ...mixins);
    }
    _config() {
      const {
        items,
        type,
        gutter,
        size,
        visibleItems,
        inline,
        itemDefaults,
        menuClasses,
        forceVisible,
        dropdownProps,
      } = this.props;
      const before = items.slice(0, visibleItems).map((item) => {
        return Object.assign(
          { component: "Button", type, size, inline },
          itemDefaults,
          item
        );
      });
      const dropdowns = Object.assign(
        {
          component: "Dropdown",
          rightIcon: "ellipsis",
          items: items.slice(visibleItems),
          itemDefaults,
          type,
          inline,
          size,
          menuClasses,
        },
        dropdownProps
      );
      const arr = [...before];
      if (items.length > visibleItems || forceVisible) {
        arr.push(dropdowns);
      }
      this.setProps({
        children: { component: "Cols", gutter: gutter, items: arr },
        onClick: ({ event }) => {
          this.props.stopPropagation && event.stopPropagation();
        },
      });
    }
  }
  Toolbar.defaults = {
    type: "default",
    visibleItems: 2,
    gutter: "sm",
    size: null,
    items: [],
    itemDefaults: {},
    stopPropagation: true,
    menuClasses: null,
    dropdownProps: {},
  };
  Component.register(Toolbar);
  let nameSeq = 0;
  class GroupGridTr extends Tr {
    constructor(props, ...mixins) {
      const defaults = { hideAction: false };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.fields = [];
      const { name, value, data } = this.props;
      this.currentData = data;
      this.initValue = value !== undefined ? clone(this.props.value) : null;
      this.oldValue = null;
      this.currentValue = this.initValue;
      if (name) {
        this.name = name;
        this._autoName = false;
      } else {
        this._autoName = true;
        this.name = `__field_grid${++nameSeq}`;
      }
      this.group = this.table.grid.groupGrid;
      this.rootField = this.group === null ? this : this.group.rootField;
      this.rules = [];
    }
    getValue(options) {
      const { valueOptions, hiddenColumns } = this.props;
      options = extend(
        { ignoreDisabled: true, ignoreHidden: true, merge: false },
        options,
        valueOptions
      );
      const value = {};
      const len = this.fields.length;
      for (let i = 0; i < len; i++) {
        const field = this.fields[i];
        if (field.getValue && this._needHandleValue(field, options)) {
          const fieldValue = field.getValue(options);
          if (field.props.flatValue === true) {
            extend(value, fieldValue);
          } else {
            value[field.name] = fieldValue;
          }
        }
      }
      hiddenColumns.forEach((element) => {
        if (!options.ignoreHidden) {
          if (this.currentData.hasOwnProperty(element.field)) {
            value[element.field] = this.currentData[element.field];
          } else if (element.value) {
            value[element.field] = element.value;
          }
        }
      });
      if (options.merge === true) {
        return extend(this.currentValue, value);
      }
      return value;
    }
    setValue(value, options) {
      this.currentData = value;
      options = extend({ ignoreDisabled: false, ignoreHidden: false }, options);
      const len = this.fields.length;
      for (let i = 0; i < len; i++) {
        const field = this.fields[i];
        if (field.setValue && this._needHandleValue(field, options)) {
          let fieldValue = value;
          if (field.props.flatValue === false) {
            if (isPlainObject(value)) {
              fieldValue = value[field.name];
            }
          }
          if (fieldValue === undefined) {
            fieldValue = null;
          }
          field.setValue(fieldValue, options);
        }
      }
    }
    validate(fromParent = false) {
      this.invalids = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i],
          { disabled, hidden } = field.props;
        if (!(disabled || hidden) && field.validate) {
          const valResult = field.validate();
          if (valResult !== true) {
            this.invalids.push(field);
          }
        }
      } // GroupGrid focus
      if (!fromParent && this.invalids.length > 0) {
        this.invalids[0].focus();
      }
      return this.invalids.length === 0;
    }
    _focusInvalid() {
      if (this.invalids.length) {
        this.invalids[0].focus();
      }
    }
    getField(fieldName) {
      if (typeof fieldName === "string") {
        // Handle nested keys, e.g., "foo.bar" "foo[1].bar" "foo[key].bar"
        const parts = fieldName.split(".");
        let curField = this;
        if (parts.length) {
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            curField = curField._getSubField(part);
            if (!curField) {
              break;
            }
          }
        }
        return curField;
      }
    }
    _getSubField(fieldName) {
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.name === fieldName) {
          return field;
        }
      }
      return null;
    }
    _onValueChange(args) {
      const that = this;
      this.oldValue = clone(this.currentValue);
      this.currentValue = clone(this.getValue());
      this.props.value = this.currentValue;
      args = extend(true, args, {
        name: this.props.name,
        oldValue: this.oldValue,
        newValue: this.currentValue,
      });
      setTimeout(function () {
        that._callHandler(that.props.onValueChange, args);
        that.group &&
          that.group._onValueChange({
            changedField: args.changedField || that,
          });
        isFunction(that._valueChange) && that._valueChange(args);
        if (that.validateTriggered) {
          that._validate();
        }
      }, 0);
    }
    focus() {
      this.element.focus();
    }
    reset() {
      this.setValue(this.initValue);
    }
    _clear() {
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.setValue) {
          field.setValue(null);
        }
      }
    }
    _needHandleValue(field, options) {
      const { disabled, hidden } = field.props;
      const { ignoreFields = [] } = options;
      if (field._autoName) {
        return false;
      }
      if (options.ignoreDisabled && disabled === true) {
        return false;
      }
      if (options.ignoreHidden && hidden === true) {
        return false;
      }
      if (ignoreFields.includes(field.name)) {
        return false;
      }
      return true;
    }
  }
  class GroupGrid extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(GroupGrid.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      const that = this;
      const { groupDefaults, value, gridProps } = this.props;
      const actionRender = groupDefaults.actionRender;
      const actionWidth = groupDefaults.actionWidth || 100;
      let columns = [];
      this.hiddenColumns = [];
      groupDefaults.fields.forEach((f) => {
        if (f.hidden !== true) {
          columns.push({
            field: f.name,
            title: f.label,
            width: f.width,
            cellRender: ({ cellData, row }) => {
              return Component.extendProps(f, {
                notShowLabel: true,
                plain: true,
                value: cellData,
                __group: row,
                invalidTip: { reference: this },
                _created: function () {
                  row.fields.push(this);
                },
              });
            },
          });
        } else {
          this.hiddenColumns.push({
            field: f.name,
            title: f.label,
            width: f.width,
            value: f.value,
          });
        }
      });
      if (isFunction(actionRender)) {
        columns = [
          ...columns,
          {
            width: actionWidth,
            cellRender: ({ row }) => {
              return {
                component: Toolbar,
                items: actionRender({ row: row, grid: that }),
              };
            },
          },
        ];
      } else if (actionRender === true || actionRender === undefined) {
        columns = [
          ...columns,
          {
            width: actionWidth,
            cellRender: ({ row }) => {
              return {
                component: Toolbar,
                items: [
                  {
                    component: "Button",
                    text: that.props.removeText,
                    onClick: () => {
                      row.remove();
                      that._onValueChange();
                    },
                  },
                ],
              };
            },
          },
        ];
      }
      this.setProps({
        control: {
          children: Component.extendProps(gridProps, {
            component: Grid,
            columns: columns,
            data: value,
            line: "both",
            rowDefaults: {
              component: GroupGridTr,
              hiddenColumns: this.hiddenColumns,
            },
            onCreated: ({ inst }) => {
              that.grid = inst;
              inst.groupGrid = that;
            },
          }),
        },
        controlAction: [
          {
            component: "Button",
            type: "dashed",
            text: this.props.addText,
            span: 12,
            block: true,
            onClick: () => {
              that.addGroup();
            },
            hidden: that.props.hideAction,
          },
        ],
      });
      super._config();
    }
    getValue(options) {
      const { valueOptions } = this.props;
      const opts = extend(
        { ignoreDisabled: false, ignoreHidden: true, merge: false },
        options,
        valueOptions
      );
      const value = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.getValue) {
          const fieldValue = field.getValue(opts);
          value.push(fieldValue);
        }
      }
      return value;
    }
    setValue(value, options) {
      if (Array.isArray(value)) {
        for (let i = 0; i < this.fields.length; i++) {
          const field = this.fields[i];
          if (field.setValue) {
            field.setValue(value[i], options);
          }
        }
      }
    }
    validate() {
      if (this.props.required && !this.fields.length) {
        return false;
      }
      const invalids = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i],
          { disabled, hidden } = field.props;
        if (!(disabled || hidden) && field.validate) {
          const valResult = field.validate(true);
          if (valResult !== true) {
            invalids.push(field);
          }
        }
      }
      if (invalids.length > 0) {
        invalids[0]._focusInvalid();
      }
      return invalids.length === 0;
    }
    getField(fieldName) {
      if (typeof fieldName === "string") {
        // Handle nested keys, e.g., "foo.bar" "foo[1].bar" "foo[key].bar"
        const parts = fieldName.split(".");
        let curField = this;
        if (parts.length) {
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            curField = curField._getSubField(part);
            if (!curField) {
              break;
            }
          }
        }
        return curField;
      }
    }
    _getSubField(fieldName) {
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.name === fieldName) {
          return field;
        }
      }
      return null;
    }
    focus() {}
    addGroup() {
      const gridData = this.grid.props.data || [];
      const { addDefaultValue } = this.props;
      let rowData = isFunction(addDefaultValue)
        ? addDefaultValue.call(this)
        : addDefaultValue;
      if (!rowData) {
        rowData = this.props.groupDefaults.fields.map((n) => {
          const item = {};
          item[n.name] = null;
          return item;
        });
      }
      gridData.length === 0
        ? this.grid.update({ data: [rowData] })
        : this.grid.appendRow({ data: rowData });
      this._onValueChange();
    }
    _clear() {
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.setValue) {
          field.setValue(null);
        }
      }
    }
  }
  GroupGrid.defaults = {
    hideAction: false,
    addText: "",
    removeText: "",
  };
  Object.defineProperty(GroupGrid.prototype, "fields", {
    get: function () {
      return this.grid.getRows();
    },
  });
  Component.register(GroupGrid);
  class GroupList extends Group {
    constructor(props, ...mixins) {
      super(Component.extendProps(GroupList.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.extGroupDefaults = null;
    }
    _config() {
      const that = this;
      const { groupDefaults, value, disabled, controlAction } = this.props;
      const actionRender = groupDefaults.actionRender || null;
      this.extGroupDefaults = Component.extendProps(groupDefaults, {
        _config: function () {
          const group = this;
          if (isFunction(actionRender)) {
            this.setProps({
              action: actionRender({ group: group, groupList: that }),
            });
          } else {
            this.setProps({
              action: [
                {
                  component: "Button",
                  text: that.props.removeText,
                  disabled: disabled,
                  onClick: () => {
                    that.removeGroup(group);
                  },
                },
              ],
            });
          }
        },
      });
      const groups = [];
      if (Array.isArray(value)) {
        value.forEach(function (item) {
          groups.push(
            Component.extendProps(that.extGroupDefaults, { value: item })
          );
        });
      }
      let realControlAction = controlAction;
      if (that.props.hideAction) {
        realControlAction = null;
      } else if (isNullish(realControlAction)) {
        realControlAction = [
          {
            component: "Button",
            type: "dashed",
            text: this.props.addText,
            span: 12,
            block: true,
            disabled: disabled,
            onClick: () => {
              that.addGroup();
            },
          },
        ];
      }
      this.setProps({
        fields: groups,
        fieldDefaults: that.extGroupDefaults,
        controlAction: realControlAction,
      });
      super._config();
    }
    getValue(options) {
      const { valueOptions } = this.props;
      const opts = extend(
        { ignoreDisabled: true, ignoreHidden: true, merge: false },
        valueOptions,
        options
      );
      const value = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i];
        if (field.getValue) {
          const fieldValue = field.getValue(opts);
          value.push(fieldValue);
        }
      }
      return value;
    }
    setValue(value, options) {
      if (Array.isArray(value)) {
        for (let i = 0; i < this.fields.length; i++) {
          const field = this.fields[i];
          if (field.setValue) {
            field.setValue(value[i], options);
          }
        }
      }
    }
    validate(options) {
      let selfValid = true;
      if (this.props.required && !this.fields.length) {
        const rules = [
          { type: "required", message: this._propStyleClasses.requiredMessage },
        ];
        const validationResult = RuleManager.validate(
          rules,
          this.fields.length ? true : null
        );
        if (validationResult === true) {
          this.removeClass("s-invalid");
          this.trigger("valid");
          selfValid = true;
        } else {
          this.addClass("s-invalid");
          this.trigger("invalid", validationResult);
          this._invalid(validationResult);
          selfValid = false;
        }
      }
      const invalids = [];
      for (let i = 0; i < this.fields.length; i++) {
        const field = this.fields[i],
          { disabled, hidden } = field.props;
        if (!(disabled || hidden) && field.validate) {
          const valResult = field.validate(options);
          if (valResult !== true) {
            invalids.push(field);
          }
        }
      }
      if (invalids.length > 0) {
        invalids[0].focus();
      }
      return invalids.length === 0 && selfValid === true;
    }
    addGroup(groupProps) {
      if (isNullish(groupProps)) {
        groupProps = {};
      }
      const { addDefaultValue } = this.props;
      if (isNullish(groupProps.value)) {
        groupProps.value = isFunction(addDefaultValue)
          ? addDefaultValue.call(this)
          : addDefaultValue;
      }
      groupProps = Component.extendProps(this.extGroupDefaults, groupProps);
      this.appendField(groupProps);
      this._onValueChange();
      this.removeClass("s-invalid");
      if (this.errorTip) {
        this.errorTip.remove();
        delete this.errorTip;
      }
    }
    removeGroup(group) {
      group.remove();
      this._onValueChange();
    }
  }
  GroupList.defaults = {
    fieldDefaults: { component: Group },
    hideAction: false,
    addText: "",
    removeText: "",
  };
  Component.register(GroupList);
  class GroupTree extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(GroupTree.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.valid = true;
    }
    _config() {
      const me = this;
      const { value, columnWidth, dataFields } = this.props;
      const { fields } = this.props.groupDefaults;
      const { text, key, children } = dataFields;
      const treeValue = value;
      const hd = fields.map((n) => {
        return {
          text: n.label || "",
          name: n.name || "",
          width: n.width || columnWidth,
        };
      });
      this.setProps({
        control: {
          children: {
            component: "Flex",
            rows: [
              {
                component: "List",
                classes: { "nom-group-tree-hd": true },
                _created: function () {
                  me.headerRef = this;
                },
                items: [{ width: 276 }, ...hd],
                itemDefaults: {
                  _config: function () {
                    this.setProps({
                      children: {
                        attrs: {
                          style: {
                            width: `${this.props.width}px`,
                            paddingLeft: ".5rem",
                          },
                          "field-name": this.props.name,
                        },
                        children: this.props.text,
                      },
                    });
                  },
                },
              },
              {
                hidden: treeValue && treeValue.length > 0,
                _created: function () {
                  me.addBtn = this;
                },
                classes: { "nom-group-tree-add": true },
                children: {
                  component: "Button",
                  type: "dashed",
                  text: me.props.addText,
                  span: 12,
                  block: true,
                  onClick: () => {
                    me._addNode();
                  },
                },
              },
              {
                component: "Tree",
                _created: function () {
                  me.tree = this;
                },
                sortable: true,
                data: treeValue,
                nodeSelectable: false,
                expandable: { byIndicator: true },
                dataFields: dataFields,
                nodeDefaults: {
                  _config: function () {
                    const that = this;
                    this.setProps({
                      data: {
                        tools: {
                          justify: "start",
                          render: (param) => {
                            const cols = fields.map((n) => {
                              const defaultProp = {
                                controlWidth: n.width || columnWidth,
                                label: null,
                                onValueChange: debounce(({ newValue }) => {
                                  that.props.data[n.name] = newValue;
                                  me._handleChange();
                                }, 1000),
                                value: that.props.data[n.name],
                                attrs: { "field-name": n.name },
                              };
                              if (n.render) {
                                return Component.extendProps(
                                  n.render(param),
                                  defaultProp
                                );
                              }
                              return Component.extendProps(n, defaultProp);
                            });
                            return {
                              component: "Group",
                              classes: { "nom-group-tree-group": true },
                              _created: function () {
                                that.group = this;
                              },
                              _config: function () {
                                const node = this.parent.parent.parent.parent
                                  .node;
                                this.setProps({
                                  attrs: {
                                    style: {
                                      marginLeft: `-${node.level * 16}px`,
                                    },
                                  },
                                });
                              },
                              fields: [
                                {
                                  component: "Toolbar",
                                  _created: function () {
                                    that.rowOptions = this;
                                  },
                                  classes: {
                                    "nom-group-tree-row-options": true,
                                  },
                                  icon: "edit",
                                  visibleItems: 0, // size: 'small',
                                  type: "text",
                                  attrs: { style: { width: "40px" } },
                                  items: [
                                    {
                                      text: me.props.renameText,
                                      onClick: () => {
                                        let rowText = that.props.data[text];
                                        new nomui.Modal({
                                          size: "xsmall",
                                          content: {
                                            header: false,
                                            body: {
                                              children: [
                                                {
                                                  component: "Textbox",
                                                  value: rowText,
                                                  onValueChange: ({
                                                    newValue,
                                                  }) => {
                                                    rowText = newValue;
                                                  },
                                                },
                                              ],
                                            },
                                          },
                                          onOk: ({ sender }) => {
                                            that.update({
                                              data: { text: rowText },
                                            });
                                            sender.close();
                                          },
                                        });
                                      },
                                    },
                                    {
                                      text: me.props.removeNodeText,
                                      onClick: () => {
                                        const parentNode = that.parent.parent;
                                        const isRoot =
                                          parentNode.componentType === "Tree";
                                        const c = parentNode.getData() || [];
                                        const i = c.findIndex((n) => {
                                          return (
                                            n[key] === that.props.data[key]
                                          );
                                        });
                                        const newChildren = me._removeItem(
                                          c,
                                          i
                                        );
                                        if (isRoot) {
                                          parentNode.props.data = newChildren;
                                        } else {
                                          parentNode.props.data[
                                            children
                                          ] = newChildren;
                                        }
                                        setTimeout(() => {
                                          parentNode.update({
                                            data: parentNode.props.data,
                                          });
                                          if (
                                            isRoot &&
                                            !parentNode.getData().length
                                          ) {
                                            me.addBtn.show();
                                          }
                                        }, 200);
                                        const _that$props$data =
                                            that.props.data,
                                          source = _objectWithoutPropertiesLoose2(
                                            _that$props$data,
                                            ["tools", "hidden"]
                                          );
                                        me.props.onNodeDeleted &&
                                          me._callHandler(
                                            me.props.onNodeDeleted,
                                            source
                                          );
                                      },
                                    },
                                    {
                                      text: me.props.addRowText,
                                      onClick: () => {
                                        const obj = { __isNew: true };
                                        obj[key] = nomui.utils.newGuid();
                                        obj[text] = me.props.newNodeText;
                                        new nomui.Modal({
                                          size: "xsmall",
                                          content: {
                                            header: false,
                                            body: {
                                              children: [
                                                {
                                                  component: "Textbox",
                                                  value: obj[text],
                                                  onValueChange: ({
                                                    newValue,
                                                  }) => {
                                                    obj[text] = newValue;
                                                  },
                                                },
                                              ],
                                            },
                                          },
                                          onOk: ({ sender }) => {
                                            const parentNode =
                                              that.parent.parent;
                                            const c =
                                              parentNode.getData() || [];
                                            const i = c.findIndex((n) => {
                                              return (
                                                n[key] === that.props.data[key]
                                              );
                                            });
                                            const newChildren = me._insertItem(
                                              c,
                                              i + 1,
                                              obj
                                            );
                                            if (
                                              parentNode.componentType ===
                                              "Tree"
                                            ) {
                                              parentNode.props.data = newChildren;
                                            } else {
                                              parentNode.props.data[
                                                children
                                              ] = newChildren;
                                            }
                                            parentNode.update({
                                              data: parentNode.props.data,
                                            });
                                            sender.close();
                                          },
                                        });
                                      },
                                    },
                                    {
                                      text: me.props.addNodeText,
                                      onClick: () => {
                                        const obj = { __isNew: true };
                                        obj[key] = nomui.utils.newGuid();
                                        obj[text] = me.props.newNodeText;
                                        new nomui.Modal({
                                          size: "xsmall",
                                          content: {
                                            header: false,
                                            body: {
                                              children: [
                                                {
                                                  component: "Textbox",
                                                  value: obj[text],
                                                  onValueChange: ({
                                                    newValue,
                                                  }) => {
                                                    obj[text] = newValue;
                                                  },
                                                },
                                              ],
                                            },
                                          },
                                          onOk: ({ sender }) => {
                                            const c =
                                              that.props.data[children] || [];
                                            const newChildren = [...c, obj];
                                            that.props.data[
                                              children
                                            ] = newChildren;
                                            that.update({
                                              data: that.props.data,
                                            });
                                            sender.close();
                                          },
                                        });
                                      },
                                    },
                                  ],
                                },
                                ...cols,
                              ],
                              inline: true,
                            };
                          },
                        },
                      },
                    });
                  },
                  _rendered: function () {
                    this.contentText.element.style.paddingRight = `${
                      this.level * 16
                    }px`;
                  },
                },
                _rendered: function () {
                  // 
                  setTimeout(() => {
                    me._fixColsWidth();
                  }, 100);
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _addNode() {
      const { text, key } = this.props.dataFields;
      const defaultObj = {};
      defaultObj[text] = this.props.newNodeText;
      defaultObj[key] = nomui.utils.newGuid();
      this.update({ value: [defaultObj] });
    }
    _insertItem(arr, index, value) {
      arr.splice(index, 0, value);
      return arr;
    }
    _removeItem(arr, index) {
      arr.splice(index, 1);
      return arr;
    }
    _handleChange() {
      if (this.props.onValueChange) {
        this._callHandler(this.props.onValueChange, {
          newValue: this._getValue(),
        });
      }
    }
    _getValue() {
      const data = this.tree.getData();
      this._cleanData(data);
      if (!data.length) {
        return null;
      }
      return data;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      if (value === null || !value.length) {
        this.tree.update({ data: [] });
        this.addBtn.show();
      } else {
        this.tree.update({ data: value });
        this.addBtn.hide();
      }
    }
    _cleanData(arr) {
      const { children } = this.props.dataFields;
      for (let i = 0; i < arr.length; i++) {
        delete arr[i].tools;
        delete arr[i].hidden;
        if (arr[i][children] && arr[i][children].length) {
          this._cleanData(arr[i][children]);
        }
      }
    }
    _validate(options) {
      this.valid = true;
      return this._validateTree(options);
    }
    _validateTree(opts, node) {
      opts = opts || {};
      node = node || this.tree;
      const childNodes = node.getChildNodes();
      childNodes.forEach((childNode) => {
        if (childNode.group.validate() === false) {
          this.valid = false;
        }
        this._validateTree(opts, childNode);
      });
      return this.valid;
    } // 
    _fixColsWidth() {
      const rows = this.tree.getChildNodes();
      if (!rows.length) {
        return;
      }
      const firstGroup = rows[0].group.element;
      const fields = firstGroup.querySelector(".nom-control").childNodes;
      fields.forEach((n) => {
        const fieldName = n.getAttribute("field-name");
        if (fieldName) {
          const target = this.headerRef.element.querySelector(
            `[field-name=${fieldName}]`
          );
          target.style.width = `${n.offsetWidth}px`;
        }
      });
    }
  }
  GroupTree.defaults = {
    columnWidth: 200,
    groupDefaults: { fields: [] },
    dataFields: { key: "key", text: "text", children: "children" },
    onNodeDeleted: null,
    addText: "",
    renameText: "",
    removeNodeText: "",
    addRowText: "",
    newNodeText: "",
    addNodeText: "",
  };
  Component.register(GroupTree);
  class IconPicker extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(IconPicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.itemsRef = {};
      if (!this.props.data) {
        this.props.data = this.props.interalData;
      }
    }
    _config() {
      const { iconRender, value, allowClear } = this.props;
      this.setProps({
        classes: { "nom-icon-picker-simple": !!iconRender },
        control: {
          children: [
            iconRender
              ? {
                  ref: (c) => {
                    this.iconRef = c;
                  },
                  children: iconRender(value),
                }
              : {
                  component: "Icon",
                  classes: { "nom-icon-picker-icon": true },
                  ref: (c) => {
                    this.iconRef = c;
                  },
                  type: value,
                },
            !this.props.iconRender && {
              ref: (c) => {
                this.textRef = c;
              },
              hidden: !value,
              classes: { "nom-icon-picker-text": true },
              children: this._getIconValueText(),
            },
            !this.props.iconRender && {
              ref: (c) => {
                this.placeholder = c;
              },
              hidden: !!value,
              classes: { "nom-icon-picker-text-placeholder": true },
              children: this.props.placeholder,
            },
            !this.props.iconRender && {
              classes: { "nom-icon-picker-arrow": true },
              component: "Icon",
              type: "down",
            },
            !this.props.iconRender &&
              allowClear && {
                component: "Icon",
                type: "times",
                classes: {
                  "nom-icon-picker-clear": true,
                  "nom-field-clear-handler": true,
                },
                hidden: !value,
                ref: (c) => {
                  this.clearIcon = c;
                },
                onClick: (args) => {
                  this._clear();
                  args.event && args.event.stopPropagation();
                },
              },
          ],
        },
      });
      super._config();
    }
    _rendered() {
      const me = this;
      const {
        data,
        popupContainer,
        iconRender,
        clearText,
        popupWidth,
        searchPlaceholder,
      } = this.props;
      let container;
      if (popupContainer === "self") {
        this.element.style.position = "relative";
        container = this.element;
      } else if (
        Object.prototype.toString.call(popupContainer) === "[object Function]"
      ) {
        const ref = popupContainer();
        ref.element.style.position = "relative";
        container = ref.element;
      }
      let w = popupWidth;
      if (isNumeric(popupWidth)) {
        w = `${popupWidth}px`;
      }
      this.popup = new nomui.Popup({
        classes: { "nom-icon-picker-popup": true },
        attrs: { style: { width: w } },
        reference: container,
        trigger: this.control,
        content: {
          component: "Flex",
          vertical: true,
          fit: true,
          items: [
            me.props.searchable && {
              component: "Textbox",
              placeholder: searchPlaceholder,
              leftIcon: "search",
              onValueChange: debounce(function ({ newValue }) {
                me._filterItem(newValue);
              }, 500),
            },
            {
              component: "List",
              vertical: true,
              classes: { "nom-icon-picker-list": true },
              data: data,
              itemRender: ({ itemData }) => {
                return {
                  component: "Flex",
                  rows: [
                    itemData.category &&
                      itemData.text && { tag: "h6", children: itemData.text },
                    {
                      component: "List",
                      items: itemData.icons,
                      classes: { "nom-icon-picker-sub-list": true },
                      itemDefaults: {
                        onCreated: ({ inst }) => {
                          me.itemsRef[inst.props.type] = inst;
                        },
                        onConfig: ({ inst }) => {
                          inst.setProps({
                            classes: { "nom-icon-picker-list-item": true },
                            tooltip: inst.props.text || undefined,
                            attrs: {
                              "data-icon-type": inst.props.type,
                              "data-icon-tooltip": inst.props.text,
                            },
                            onClick: () => {
                              me._handleIconClick(
                                inst.props.type,
                                inst.props.text
                              );
                            },
                            children: me.props.itemRender
                              ? me.props.itemRender(inst.props.type)
                              : {
                                  attrs: {
                                    style: {
                                      padding: "1rem",
                                      fontSize: "1.2rem",
                                    },
                                  },
                                  component: "Icon",
                                  type: inst.props.type,
                                },
                          });
                        },
                      },
                    },
                  ],
                };
              },
            },
            !!iconRender && {
              component: "Flex",
              justify: "end",
              classes: { "nom-icon-picker-popup-tools": true },
              cols: [
                {
                  component: "Button",
                  size: "small",
                  text: clearText,
                  onClick: () => {
                    me.clear();
                    me.popup.hide();
                  },
                },
              ],
            },
          ],
        },
        onShow: () => {
          this.selectIcon();
        },
      });
      this._valueChange({ newValue: this.currentValue });
    }
    _getValue() {
      return this.props.value;
    }
    _valueChange({ newValue }) {
      const { iconRender } = this.props;
      if (newValue) {
        this.iconRef.show();
        this.textRef && this.textRef.show();
        this.placeholder && this.placeholder.hide();
        this.clearIcon && this.clearIcon.show();
      } else {
        !iconRender && this.iconRef.hide();
        this.textRef && this.textRef.hide();
        this.placeholder && this.placeholder.show();
        this.clearIcon && this.clearIcon.hide();
      }
      if (iconRender) {
        this.iconRef.update({ children: iconRender(newValue) });
      } else {
        this.iconRef.update({ type: newValue });
      }
      this.textRef &&
        this.textRef.update({ children: this._getIconValueText() });
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      const newValue = value;
      this.props.value = value;
      this.oldValue = this.currentValue;
      if (options.triggerChange) {
        if (newValue !== this.oldValue) {
          super._onValueChange();
        }
      }
      this.currentValue = newValue;
    }
    selectIcon() {
      const value = this.getValue();
      this.popup.element
        .querySelectorAll(".nom-icon-picker-list-item.s-selected")
        .forEach((n) => {
          n.component.unselect();
        });
      if (value && this.itemsRef[value]) {
        this.itemsRef[value].select();
        setTimeout(() => {
          value &&
            this.itemsRef[value].element.scrollIntoView({ behavior: "smooth" });
        }, 250);
      }
    }
    _getIconValueText() {
      const { value, data } = this.props;
      let str = "";
      data.forEach((n) => {
        if (n.icons && n.icons.length) {
          n.icons.forEach((x) => {
            if (x.type === value) {
              str = x.text;
            }
          });
        }
      });
      return str;
    }
    _handleIconClick(type) {
      this.setValue(type);
      this.popup.hide();
    }
    _filterItem(val) {
      if (val) {
        this.popup.element.querySelectorAll("h6").forEach((n) => {
          n.classList.add("s-hidden");
        });
      } else {
        this.popup.element.querySelectorAll("h6").forEach((n) => {
          n.classList.remove("s-hidden");
        });
      }
      this.popup.element
        .querySelectorAll(".nom-icon-picker-list-item")
        .forEach((n) => {
          if (
            !val ||
            n.getAttribute("data-icon-tooltip").includes(val) ||
            n.getAttribute("data-icon-type").includes(val)
          ) {
            n.classList.remove("s-hidden");
          } else {
            n.classList.add("s-hidden");
          }
        });
    }
  }
  IconPicker.defaults = {
    popupContainer: "body",
    searchable: false,
    allowClear: true,
    placeholder: "",
    searchPlaceholder: "",
    clearText: "",
    popupWidth: 340,
    interalData: [
      {
        category: "Direction",
        text: "",
        icons: [
          { type: "up", text: "" },
          { type: "down", text: "" },
          { type: "left", text: "" },
          { type: "right", text: "" },
          { type: "swap", text: "" },
        ],
      },
      {
        category: "Prompt",
        text: "",
        icons: [
          { type: "square", text: "" },
          { type: "info-circle", text: "" },
          { type: "question-circle", text: "" },
          { type: "exclamation-circle", text: "" },
          { type: "close-circle", text: "" },
          { type: "check-circle", text: "" },
          { type: "check-circle-fill", text: "" },
          { type: "info-circle-fill", text: "" },
          { type: "warning-circle-fill", text: "" },
          { type: "help-circle-fill", text: "" },
          { type: "close-circle-fill", text: "" },
          { type: "up-circle", text: "" },
          { type: "down-circle", text: "" },
          { type: "check", text: "" },
          { type: "close", text: "" },
          { type: "ellipsis", text: "" },
          { type: "eye", text: "" },
          { type: "eye-invisible", text: "" },
          { type: "pin", text: "" },
          { type: "pin-fill", text: "" },
        ],
      },
      {
        category: "Editor",
        text: "",
        icons: [
          { type: "form", text: "" },
          { type: "plus", text: "" },
          { type: "minus", text: "" },
          { type: "edit", text: "" },
          { type: "delete", text: "" },
          { type: "blank-square", text: "" },
          { type: "checked-square", text: "" },
          { type: "half-square", text: "" },
          { type: "times", text: "" },
          { type: "search", text: "" },
          { type: "filter", text: "" },
          { type: "filter-remove", text: "" },
          { type: "sort", text: "" },
          { type: "sort-down", text: "" },
          { type: "sort-up", text: "" },
          { type: "sort-right", text: "" },
          { type: "sort-left", text: "" },
        ],
      },
      {
        category: "Common",
        text: "",
        icons: [
          { type: "cloud-upload", text: "" },
          { type: "upload", text: "" },
          { type: "download", text: "" },
          { type: "star", text: "" },
          { type: "refresh", text: "" },
        ],
      },
      {
        category: "FileType",
        text: "",
        icons: [
          { type: "folder", text: "" },
          { type: "folder-filled", text: "" },
          { type: "file", text: "" },
        ],
      },
      {
        category: "Uncategorized",
        text: "",
        icons: [
          { type: "clock", text: "" },
          { type: "calendar", text: "" },
          { type: "image", text: "" },
          { type: "table", text: "" },
          { type: "profile", text: "" },
          { type: "user", text: "" },
          { type: "company", text: "" },
          { type: "image-pending", text: "" },
          { type: "sandbox", text: "" },
        ],
      },
    ],
  };
  Component.register(IconPicker);
  class Image extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Image.defaults, props), ...mixins);
    }
    _created() {}
    _config() {
      const { alt, width, height, iconWidth, iconHeight } = this.props;
      const size = this._sizeComputing([iconWidth, iconHeight]);
      this.setProps({
        children: [
          {
            component: "Icon",
            ref: (c) => {
              this.pendingRef = c;
            },
            classes: { "nom-image-pending": true },
            type: "image-pending",
            attrs: {
              style: {
                width: `${iconWidth}px`,
                height: `${iconHeight}px`,
                "font-size": `${size < 3 ? 3 : size}rem`,
              },
            },
          },
          {
            tag: "img",
            ref: (c) => {
              this.imgRef = c;
            },
            hidden: true,
            attrs: {
              alt,
              style: {
                width: isNumeric(width) ? `${width}px` : width,
                height: isNumeric(height) ? `${height}px` : height,
              },
            },
          },
        ],
      });
    }
    _sizeComputing(arry) {
      return parseInt(Math.min(...arry) / 22, 10);
    }
    _loadImageAsync(url) {
      return new Promise((resolve, reject) => {
        const image = this.imgRef.element;
        image.onload = () => resolve(url);
        image.onerror = () => reject();
        this.imgRef.element.src = url;
      });
    }
    _dealImageList(urlList) {
      let success = false;
      return new Promise((resolve, reject) => {
        const queueNext = (url) => {
          return this._loadImageAsync(url).then(() => {
            success = true;
            resolve(url);
          });
        };
        const firstPromise = queueNext(urlList.shift() || ""); // promise[]promisecatchpromise
        // promise
        urlList
          .reduce((p, url) => {
            return p.catch(() => {
              if (!success) return queueNext(url);
            });
          }, firstPromise) //  reject
          .catch(reject);
      });
    }
    _rendered() {
      let urlList = [];
      if (!Array.isArray(this.props.src)) {
        urlList = [this.props.src];
      } else {
        urlList = this.props.src;
      }
      if (!this.props.src || !this.props.src.length) {
        this.pendingRef.update({ classes: { "nom-image-pending-done": true } });
        return;
      }
      this._dealImageList(urlList)
        .then(() => {
          this.pendingRef.remove();
          this.imgRef.show();
        })
        .catch(() => {
          this.pendingRef.update({
            classes: { "nom-image-fail": true },
            type: "image-fail",
          });
          this.imgRef.remove();
        });
    }
  }
  Image.defaults = {
    src: null,
    alt: null,
    width: null,
    height: null,
    iconWidth: 200,
    iconHeight: 100,
  };
  Component.register(Image);
  class ListSetter extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(ListSetter.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const {
        itemForm,
        actions,
        value,
        labelField,
        keyField = "id",
        sortable,
        minItems,
        minItemsMessage,
        itemRender,
        formPopupAlign,
        itemRemovable,
      } = this.props;
      let sortableProps = sortable;
      if (sortable) {
        sortableProps = Component.extendProps(
          {
            onEnd: () => {
              this._onValueChange();
            },
          },
          sortable
        );
      }
      const dataList = {
        component: DataList,
        ref: (c) => {
          this.listRef = c;
        },
        gap: "small",
        vertical: true,
        data: value,
        dataKey: keyField,
        sortable: sortableProps,
        itemRender: ({ itemData }) => {
          return {
            component: "Flex",
            items: [
              {
                component: "Icon",
                type: "drag",
                classes: { "nom-list-setter-item-drag": true },
              },
              {
                classes: { "nom-list-setter-item-label": true },
                children: itemRender
                  ? itemRender({ itemData })
                  : itemData[labelField],
              },
              {
                component: "Icon",
                classes: { "nom-list-setter-item-delete": true },
                type: "delete",
                renderIf: itemRemovable ? itemRemovable({ itemData }) : true,
                onClick: ({ sender, event }) => {
                  const currentValue = this.getValue();
                  if (minItems && currentValue.length === minItems) {
                    new nomui.Message({
                      content: minItemsMessage.replace("{minItems}", minItems),
                      type: "warning",
                      align: "top right",
                      alignTo: sender,
                      alignOuter: true,
                    });
                    event.stopPropagation();
                  } else {
                    that.removeItem(itemData[keyField]);
                  }
                },
              },
            ],
            onClick: ({ sender }) => {
              if (itemForm === false) return;
              const myFormProps = isFunction(itemForm)
                ? itemForm({ itemData })
                : itemForm;
              if (myFormProps === false) return;
              const itemFormProps = Component.extendProps(myFormProps, {
                component: Form,
                fieldDefaults: { labelAlign: "left" },
                value: itemData,
                onValueChange: ({ newValue }) => {
                  newValue = Component.extendProps(itemData, newValue);
                  this.listRef.updateItem(itemData[keyField], newValue);
                  this._onValueChange();
                },
              });
              new nomui.Layer({
                classes: { "nom-list-setter-layer": true, "nom-popup": true },
                closeOnClickOutside: true,
                closeToRemove: true,
                children: itemFormProps,
                align: formPopupAlign,
                alignTo: sender.element,
                alignOuter: true,
              });
            },
          };
        },
      };
      let actionsProps = actions;
      if (isFunction(actions)) {
        actionsProps = actions({ listSetter: that });
      }
      this.setProps({
        labelAlign: "top",
        labelActions: actionsProps,
        control: { children: dataList },
      });
      super._config();
    }
    getValue() {
      return this.listRef.getItemDatas();
    }
    setValue(value, options) {
      if (Array.isArray(value)) {
        for (let i = 0; i < this.fields.length; i++) {
          const field = this.fields[i];
          if (field.setValue) {
            field.setValue(value[i], options);
          }
        }
      }
    }
    appendItem(itemData) {
      this.listRef.appendItem(itemData);
      this._onValueChange();
    }
    removeItem(key, triggerEvent) {
      this.listRef.removeItem(key);
      this._onValueChange();
      if (triggerEvent !== false) {
        this._onItemRemoved(key);
      }
    }
    _onItemRemoved(key) {
      this._callHandler(this.props.onItemRemoved, { key });
    }
  }
  ListSetter.defaults = {
    labelField: "title",
    keyField: "id",
    sortable: { handle: ".p-type-drag" },
    actions: null,
    minItems: null,
    minItemsMessage: " {minItems} ",
    itemRender: null,
    formPopupAlign: "left top",
  };
  Component.register(ListSetter);
  class MaskInfo extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(MaskInfo.defaults, props), ...mixins);
    }
    _created() {
      this.originText = this.props.text;
      this.showText = "";
    }
    _config() {
      const { text, type, icon } = this.props;
      const that = this;
      if (this.props.mask === true) {
        this.showText = MaskInfo.format({ value: text, type: type });
      } else {
        this.showText = this.props.text;
      }
      let textNode = null;
      if (icon) {
        textNode = { tag: "span", children: this.showText };
      } else if (!this.props.mask) {
        textNode = { tag: "span", children: this.showText };
        if (that.tooltip) {
          that.tooltip.remove();
          delete that.tooltip;
        }
      } else {
        textNode = {
          tag: "span",
          children: this.showText,
          onClick: () => {
            that.handleClick();
          },
        };
      }
      const children = [
        this.props.mask &&
          !!icon &&
          this.props.text &&
          this.props.toggle &&
          Component.normalizeIconProps({
            type: "eye",
            onClick: function () {
              that.handleClick();
            },
          }),
        textNode,
      ];
      this.setProps({
        children: this.props.text ? children : this.props.empty,
      });
    }
    _rendered() {
      if (this.props.mask && !this.props.icon && this.props.toggle) {
        this.tooltip = new nomui.Tooltip({
          trigger: this,
          children: this.props.showText,
        });
      }
    }
    handleClick() {
      // this.props.mask = false
      this.update({ mask: false, attrs: { title: this.props.text } });
    }
    static format(data) {
      const { value, type } = data;
      if (!value) {
        return "";
      }
      if (value === "NA" || value === "") {
        return value;
      }
      let newText = ""; // 
      if (type === "mobile") {
        newText = value.replace(/(\d{1,3})(\d{4})(\d+)/g, "$1****$3");
      } // 
      else if (type === "phone") {
        newText = value.replace(/(\d+)(\d{4})/g, "$1*****");
      } // 
      else if (type === "fax") {
        newText = value.replace(/(\d+)(\d{4})/g, "$1*****");
      } // 
      else if (type === "mail" || type === "email") {
        let strend;
        if (value.indexOf("@") < 5) {
          strend = value.substring(1, value.lastIndexOf("@") - 1);
        } else {
          strend = value.substring(2, value.lastIndexOf("@") - 2);
        }
        newText = value.replace(strend, "***");
      } // 
      else if (type === "card") {
        const strend = value.substring(0, value.length - 4);
        newText = value.replace(strend, "************");
      } // 
      else if (type === "identity") {
        newText = value.replace(/(\d{4}).*(\w{3})/gi, "$1***********$2");
      } // 
      else if (type === "name") {
        const strend = value.substring(0, value.length - 1);
        let star = "";
        for (let i = 0; i < strend.length; i++) {
          star += "*";
        }
        newText = value.replace(strend, star);
      } // 
      else if (type === "middle") {
        if (value.length <= 4) {
          newText = "****";
        } else if (value.length > 4 && value.length <= 8) {
          const strend = value.substring(value.length - 4, value.length);
          newText = `****${strend}`;
        } else {
          const strend = value.substring(0, value.length - 8);
          const strend2 = value.substring(value.length - 4, value.length);
          newText = `${strend}****${strend2}`;
        }
      } // 
      else if (!type || type === "other") {
        if (value.length > 4) {
          const strend = value.substring(0, value.length - 4);
          newText = `${strend}****`;
        } else {
          newText = "";
          for (let i = 0; i < value.length; i++) {
            newText += "*";
          }
        }
      }
      return newText;
    }
  }
  MaskInfo.defaults = {
    tag: "span",
    type: null,
    text: null,
    mask: true,
    icon: true,
    empty: null,
    showTitle: true,
    toggle: true,
    showText: "",
  };
  Component.register(MaskInfo);
  class MaskInfoField extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(MaskInfoField.defaults, props), ...mixins);
    }
    _config() {
      const {
        tag,
        type,
        text,
        mask,
        icon,
        empty,
        showTitle,
        toggle,
      } = this.props;
      this.setProps({
        control: {
          children: {
            component: "MaskInfo",
            tag,
            type,
            text: this.props.value || text,
            mask,
            icon,
            empty,
            showTitle,
            toggle,
          },
        },
      });
      super._config();
    }
    _setValue(value) {
      this.update({ value });
    }
    _getValue() {
      return this.props.value;
    }
  }
  MaskInfoField.defaults = { value: null, toggle: true };
  Component.register(MaskInfoField);
  class MenuItem extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "a",
        url: null,
        icon: null,
        text: null,
        subtext: null,
        indicator: {
          component: "Icon",
          expandable: {
            expandedProps: { type: props.indicatorIcon.up },
            collapsedProps: { type: props.indicatorIcon.down },
          },
          type: props.indicatorIcon.down,
        },
        tools: null,
        key: function () {
          return this.props[this.props.keyField];
        },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.wrapper = this.parent;
      this.wrapper.item = this;
      this.menu = this.wrapper.menu;
      this.level = this.wrapper.level;
      this.isLeaf = this.wrapper.isLeaf;
      this.menu.itemRefs[this.key] = this;
      this.parentItem = null;
      if (this.wrapper.parentWrapper) {
        this.parentItem = this.wrapper.parentWrapper.item;
      }
      this.handleSelect = this.handleSelect.bind(this);
    }
    _config() {
      this._propStyleClasses = [
        "ghost",
        "size",
        "shape",
        "danger",
        "block",
        "borderless",
      ];
      const { menu } = this;
      const { onSelect, onUnselect } = this.props;
      const menuProps = menu.props;
      let tools = null;
      if (this.wrapper.props.item.toolsRender) {
        tools = this.wrapper.props.item.toolsRender(this, menu);
        tools.onClick = (args) => {
          args.event.stopPropagation();
        };
      }
      if (this.props.tools) {
        if (isFunction(this.props.tools)) {
          tools = this.props.tools(this, menu);
        } else if (isPlainObject(this.props.tools)) {
          tools = this.props.tools;
        }
      }
      let indicatorIconType =
        menuProps.compact || menuProps.dropdown
          ? this.props.indicatorIcon.right
          : this.props.indicatorIcon.down;
      if (menuProps.direction === "horizontal" && this.level > 0) {
        indicatorIconType = this.props.indicatorIcon.right;
      }
      if (
        menuProps.direction === "horizontal" ||
        menuProps.dropdown ||
        menuProps.compact
      ) {
        this.setProps({ indicator: { expandable: false } });
      }
      const groupOffset = this.wrapper.props.isGroupItem ? 0.5 : 0;
      this.setProps({
        indicator: {
          type: indicatorIconType,
          classes: { "nom-menu-toggler": true },
          attrs: { style: { "padding-left": ".5rem" } },
          _created() {
            this.parent.indicator = this;
          },
        },
        selectable: { byClick: menuProps.itemSelectable.byClick },
        expandable: {
          byClick: !menuProps.compact && !menuProps.dropdown,
          target: function () {
            return this.wrapper.submenu;
          },
        },
        attrs: {
          href: this.getItemUrl(this.props.url),
          target: this.props.target,
          style: {
            paddingLeft:
              menuProps.direction === "vertical" &&
              !menuProps.compact &&
              !menuProps.dropdown
                ? `${(this.level + 1 - groupOffset) * menuProps.indent}rem`
                : null,
          },
        },
        onSelect: () => {
          this._callHandler(onSelect);
          menu._onItemSelected({ item: this, key: this.key });
        },
        onUnselect: () => {
          this._callHandler(onUnselect);
        },
      });
      if (menuProps.itemSelectable.onlyleaf === true && this.isLeaf === false) {
        this.setProps({ selectable: false });
      }
      if (this.props.type === "group") {
        this.setProps({
          indicator: false,
          selectable: false,
          expandable: false,
          tag: "span",
          classes: { text: true, "nom-menu-group-title": true },
          children: this.props.text,
        });
      } else {
        this.setProps({
          children: [
            this.props.icon && {
              component: "Icon",
              type: this.props.icon,
              classes: { "nom-menu-item-icon": true },
            },
            {
              tag: menuProps.compact ? "div" : "span",
              classes: { text: true, "nom-menu-item-title": true },
              attrs: {
                style: { "flex-grow": this.props.subtext ? null : "2" },
                title: isString(this.props.text) ? this.props.text : null,
              },
              children: this.props.text,
            },
            this.props.subtext && {
              tag: "span",
              classes: { subtext: true },
              attrs: { style: { "flex-grow": "2" } },
              children: this.props.subtext,
            },
            tools && tools,
            this.props.indicator && !this.isLeaf && this.props.indicator,
          ],
        });
      }
    }
    _rendered() {
      if (this.props.selected) {
        this.list.selectedItem = this;
      }
    }
    handleSelect() {}
    _collapse() {
      this.indicator && this.indicator.collapse();
      this.wrapper && this.wrapper.collapse();
      if (this.menu.props.itemExpandable.expandSingle === true) {
        this.wrapper.parent.expandedChildItem = null;
      }
    }
    partSelect() {
      const siblings = this.menu.element.querySelectorAll(
        ".nom-menu-item-submenu-selected"
      );
      if (siblings.length) {
        siblings.forEach((n) => {
          n.classList.remove("nom-menu-item-submenu-selected");
        });
      }
      this.element.classList.add("nom-menu-item-submenu-selected");
    }
    _select() {
      const { menu } = this;
      const menuProps = menu.props;
      if (menu.selectedItem !== null) menu.selectedItem.unselect();
      menu.selectedItem = this;
      menu.expandedRoot = this.wrapper.rootWrapper;
      menu.selectedItemKey = this.key;
      menuProps.compact && this.wrapper.rootWrapper.item.partSelect();
    }
    _unselect() {
      const { menu } = this;
      if (menu.selectedItem === this) menu.selectedItem = null;
    }
    _expand() {
      this.indicator && this.indicator.expand();
      this.wrapper && this.wrapper.expand();
      if (this.menu.props.itemExpandable.expandSingle === true) {
        if (this.wrapper.parent.expandedChildItem) {
          this.wrapper.parent.expandedChildItem.collapse();
        }
        this.wrapper.parent.expandedChildItem = this;
      }
    }
    getItemUrl(url) {
      if (url) {
        return url;
      }
      return "javascript:void(0);";
    }
  }
  Component.register(MenuItem);
  class MenuSub extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "ul", itemDefaults: { component: "menu-item" } };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.wrapper = this.props.wrapper || this.parent;
      this.wrapper.submenu = this;
      this.menu = this.wrapper.menu;
      this.props.itemDefaults = this.menu.props.itemDefaults;
      if (this.props.isPopup) {
        this.parent.popMenu = this;
      }
    }
    _config() {
      const that = this;
      const children =
        Array.isArray(this.props.items) &&
        this.props.items.map(function (item) {
          if (!item) {
            return;
          }
          if (
            (item.type && item.type.toLowerCase() === "divider") ||
            (item.component && item.component === "Divider")
          ) {
            return {
              tag: "li",
              classes: {
                "nom-menu-divider": true,
                "nom-menu-divider-dashed": item.dashed === true,
              },
            };
          }
          return {
            component: "MenuItemWrapper",
            animate: that.menu.props.animate,
            item: Component.extendProps({}, that.props.itemDefaults, item),
            isGroupItem:
              that.wrapper &&
              that.wrapper.item &&
              that.wrapper.item.props &&
              that.wrapper.item.props.type === "group",
            items: item.items,
          };
        });
      const typeClass = `nom-menu-${this.menu.props.type}`;
      const classes = {};
      classes[typeClass] = true;
      this.setProps({ classes: classes, children: children });
    }
  }
  Component.register(MenuSub);
  class MenuItemWrapper extends Component {
    constructor(props, ...mixins) {
      const defaults = { tag: "li", item: { component: MenuItem } };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.isLeaf = false;
      this.level = 0;
      this.parentWrapper = null;
      if (this.parent instanceof Component.components.Menu) {
        this.menu = this.parent;
        this.rootWrapper = this;
      } else if (this.parent instanceof Component.components.MenuSub) {
        this.menu = this.parent.menu;
        this.parentWrapper = this.parent.wrapper;
        this.rootWrapper = this.parentWrapper.rootWrapper;
      }
      if (this.parentWrapper) {
        this.level = this.parentWrapper.level + 1;
      }
      this.isLeaf =
        !Array.isArray(this.props.item.items) ||
        this.props.item.items.length < 1;
    }
    _config() {
      const that = this;
      const { menu } = this;
      const menuProps = menu.props;
      const expanded =
        this.props.item.type === "group" ||
        menuProps.direction === "horizontal" ||
        menuProps.compact ||
        menuProps.dropdown ||
        menuProps.itemExpandable.initExpandLevel === -1 ||
        menuProps.itemExpandable.initExpandLevel > this.level;
      this.setProps({ submenu: menuProps.submenu });
      this.setProps({
        submenu: {
          component: MenuSub,
          name: "submenu",
          attrs: menuProps.compact
            ? {
                style: {
                  maxHeight: "calc( 100vh - 5px )",
                  "overflow-y": "auto",
                },
              }
            : {},
          items: this.props.item.items,
          hidden: !expanded,
        },
      });
      if (
        (menuProps.direction === "horizontal" ||
          menuProps.compact ||
          menuProps.dropdown) &&
        !this.isLeaf
      ) {
        let reference = document.body;
        if (this.level > 0) {
          reference = this;
        }
        let align = "bottom left";
        if (menuProps.compact) {
          align = "right top";
        }
        if (this.level > 0) {
          align = "right top";
        }
        if (menuProps.dropdown) {
          align = menuProps.dropdown.align || "right top";
        }
        this.setProps({ submenu: { wrapper: that } });
        let width = null;
        if (menuProps.popupWidth) {
          width = nomui.utils.isString(menuProps.popupWidth)
            ? menuProps.popupWidth
            : `${menuProps.popupWidth}px`;
        }
        this.setProps({
          item: {
            popup: {
              animate: this.props.animate,
              triggerAction: "hover",
              align: align,
              offest: menuProps.popupOffset,
              reference: reference,
              children: Object.assign({}, this.props.submenu, {
                isPopup: true,
                classes: { "nom-menu-popup-sub": true },
                attrs: { style: { width } },
              }),
              onShow: () => {
                this.onPopupMenuShow();
              },
            },
          },
        });
      }
      this.props.item.keyField = this.menu.props.keyField;
      this.setProps({
        classes: {
          "nom-menu-group-container": this.props.item.type === "group",
        },
        children: [
          this.props.item,
          !this.isLeaf &&
            menuProps.direction === "vertical" &&
            !menuProps.compact &&
            !menuProps.dropdown &&
            this.props.submenu,
        ],
      });
    }
    onPopupMenuShow() {
      if (
        this.menu.selectedItemKey &&
        this.menu.expandedRoot === this.rootWrapper
      ) {
        this.submenu &&
          this.menu.getItem(this.menu.selectedItemKey) &&
          this.menu.getItem(this.menu.selectedItemKey).select();
        if (this.menu.getItem(this.menu.selectedItemKey) === null) {
          console.warn(`Could not find the item with specific key.`);
        }
      }
    }
  }
  Component.register(MenuItemWrapper);
  class Menu extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Menu.defaults, props), ...mixins);
    }
    _created() {
      this.itemRefs = [];
      this.selectedItem = null;
      this.selectedItemKey = null;
      this.expandedRoot = null;
      this.newOrderItems = [];
    }
    _config() {
      this._addPropStyle("direction");
      this._addPropStyle("fit");
      this.setProps({
        itemDefaults: {
          component: MenuItem,
          indicatorIcon: this.props.indicatorIcon,
        },
      });
      if (this.props.direction !== "vertical") {
        this.setProps({ compact: false });
      }
      const that = this;
      const children = this.props.items.map(function (item) {
        if (!item) {
          return;
        }
        if (
          (item.type && item.type.toLowerCase() === "divider") ||
          (item.component && item.component === "Divider")
        ) {
          return {
            tag: "li",
            classes: {
              "nom-menu-divider": true,
              "nom-menu-divider-dashed": item.dashed === true,
            },
          };
        }
        return {
          component: MenuItemWrapper,
          animate: that.props.animate,
          item: Component.extendProps({}, that.props.itemDefaults, item),
        };
      });
      this.setProps({
        classes: {
          "nom-menu-compact": this.props.compact,
          "nom-menu-force-inline": !!this.props.onResize,
        },
        children: children,
      });
    }
    getInvisibleItems() {
      const el = this.element;
      const arr = [];
      const ulRect = el.getBoundingClientRect();
      const liElements = el.children;
      const tolerance = 6; // 
      for (const li of liElements) {
        const liRect = li.getBoundingClientRect();
        const isVisible =
          liRect.left >= ulRect.left - tolerance &&
          liRect.right <= ulRect.right + tolerance;
        if (!isVisible) {
          const k = li.component.props.item[this.props.keyField];
          arr.push(this.props.items.find((x) => x[this.props.keyField] === k));
        }
      }
      return arr;
    }
    getItem(param) {
      let retItem = null;
      if (param instanceof Component) {
        return param;
      }
      if (isFunction(param)) {
        for (const key in this.itemRefs) {
          if (this.itemRefs.hasOwnProperty(key)) {
            if (param.call(this.itemRefs[key]) === true) {
              retItem = this.itemRefs[key];
              break;
            }
          }
        }
      } else {
        return this.itemRefs[param] || null;
      }
      return retItem;
    }
    selectItem(param, selectOption) {
      const item = this.getItem(param);
      if (item === null || item === undefined) {
        return false;
      }
      item.select(selectOption);
      selectOption && selectOption.scrollIntoView && this.scrollTo(item);
      return item;
    }
    selectToItem(param) {
      if (this.props.compact) {
        const target = this.getRootItem(param);
        if (target === null) {
          console.warn(`Could not find the item with specific key.`);
          return;
        }
        this.getItem(target).partSelect();
        this.scrollTo(target);
        this.expandedRoot = this.getItem(target).wrapper;
        this.selectedItemKey = param;
      } else {
        this.expandToItem(param);
        this.selectItem(param);
        this.scrollTo(param);
      }
      if (
        this.props.direction !== "vertical" &&
        isFunction(this.props.onResize)
      ) {
        // 
        setTimeout(() => {
          this.props &&
            this._callHandler(this.props.onResize, {
              items: this.getInvisibleItems(),
            });
        }, 500);
      }
    }
    getRootItem(param) {
      const arr = this.props.items.filter((n) => {
        return JSON.stringify(n).includes(`"${param}"`);
      });
      if (arr.length) {
        const rootItem = arr[0][this.props.keyField];
        return this.itemRefs[rootItem];
      }
      return null;
    }
    unselectItem(param, unselectOption) {
      unselectOption = extend(
        { triggerUnselect: true, triggerSelectionChange: true },
        unselectOption
      );
      const item = this.getItem(param);
      if (item === null) {
        return false;
      }
      return item.unselect(unselectOption);
    }
    clearSelection() {
      const item = this.getSelectedItem();
      if (item) {
        this.unselectItem(item);
      }
    }
    getSelectedItem() {
      return this.selectedItem;
    }
    expandToItem(param) {
      const item = this.getItem(param);
      if (item !== null) {
        let p = item.parentItem;
        while (p) {
          p.expand();
          p = p.parentItem;
        }
      }
    }
    scrollTo(
      param,
      scrollToOptions = { behavior: "smooth", scrollMode: "if-needed" }
    ) {
      const item = this.getItem(param);
      if (item && item.wrapper) {
        scrollIntoView(item.wrapper.element, scrollToOptions);
      }
    }
    scrollToSelected() {
      if (this.selectedItem) {
        this.scrollTo(this.selectedItem);
      }
    }
    getRootItemKeys() {
      const items = this.newOrderItems.length
        ? this.newOrderItems
        : this.props.items;
      return items.map((n) => {
        return n[this.props.keyField];
      });
    }
    _rendered() {
      const me = this;
      const { sortable, direction, onResize } = this.props;
      if (direction !== "vertical" && isFunction(onResize)) {
        this._callHandler(this.props.onResize, {
          items: this.getInvisibleItems(),
        });
        this.resizeObserver = new ResizeObserver(() => {
          this.props &&
            this._callHandler(this.props.onResize, {
              items: this.getInvisibleItems(),
            });
        });
        this.resizeObserver.observe(this.element);
      }
      this.scrollToSelected();
      if (sortable) {
        defaultSortableOndrop();
        const nestedSortables = [].slice.call(
          this.element.querySelectorAll(".nom-menu-sub")
        );
        nestedSortables.unshift(this.element);
        for (let i = 0; i < nestedSortables.length; i++) {
          new nomui.utils.Sortable(nestedSortables[i], {
            group: {
              name: this.key, // 
              pull: "clone", //  false 
              put: false, // 
            },
            animation: 150,
            fallbackOnBody: true,
            swapThreshold: 0.65,
            handle: ".nom-menu-item",
            onEnd: function (evt) {
              if (evt.from !== evt.to) return; // DOM
              if (me.props.direction === "vertical") {
                me._syncItemsFromDOM();
              } else {
                const data = { oldIndex: evt.oldIndex, newIndex: evt.newIndex };
                me._processNewOrder(data);
              }
              const itemData = evt.item.component.props.item;
              delete itemData.component;
              delete itemData.keyField;
              if (me.props.sortable.onEnd) {
                me._callHandler(me.props.sortable.onEnd, {
                  rootItemKeys: me.getRootItemKeys(),
                  items: me.props.items,
                  currentItemData: itemData,
                });
              }
            },
          });
        }
      }
    }
    _syncItemsFromDOM() {
      // 1. 
      const rootElement = this.element;
      const newItems = this._buildItemsFromDOM(rootElement); // 2. props
      this.props.items = newItems;
    }
    /**
     * 
     */ _buildItemsFromDOM(parentElement) {
      const items = []; // 
      const childElements = parentElement.children;
      for (const element of childElements) {
        // 
        if (element.classList.contains("nom-menu-divider")) {
          items.push({ type: "divider" });
          continue;
        } // 
        if (element.classList.contains("nom-menu-item-wrapper")) {
          // 
          const itemWrapper = element.component;
          const itemData = itemWrapper
            ? Object.assign({}, itemWrapper.props.item)
            : {}; // 
          delete itemData.component;
          delete itemData.keyField; // 
          const subMenu = element.querySelector(":scope > ul.nom-menu-sub");
          if (subMenu) {
            // (items)
            itemData.items = this._buildItemsFromDOM(subMenu);
          }
          items.push(itemData);
        }
      }
      return items;
    }
    _processNewOrder(params) {
      const { items } = this.props;
      this.newOrderItems = this._rearrangeArray(items, params);
    }
    _rearrangeArray(arr, { oldIndex, newIndex }) {
      const [movedItem] = arr.splice(oldIndex, 1);
      arr.splice(newIndex, 0, movedItem);
      return arr;
    }
    _remove() {
      this.resizeObserver && this.resizeObserver.unobserve(this.element);
    }
    _onItemSelected(args) {
      this._callHandler(this.props.onItemSelected, args);
      if (
        this.props &&
        !!this.props.onResize &&
        this.props.direction !== "vertical"
      ) {
        this.scrollToSelected();
      }
    }
  }
  Menu.defaults = {
    tag: "ul",
    items: [],
    indicatorIcon: { right: "right", down: "down", up: "up" },
    itemSelectable: { onlyleaf: false, byClick: false },
    itemExpandable: { expandSingle: true, initExpandLevel: 0 },
    compact: false,
    indent: 1.5,
    direction: "vertical",
    keyField: "key",
    sortable: false,
    onResize: false,
    popupWidth: 160,
  };
  Component.register(Menu);
  class Message extends Layer {
    constructor(props, ...mixins) {
      super(Component.extendProps(Message.defaults, props), ...mixins);
    }
    _config() {
      this._addPropStyle("type");
      const iconMap = {
        info: "info-circle-fill",
        success: "check-circle-fill",
        error: "close-circle-fill",
        warning: "warning-circle-fill",
      };
      const icon = this.props.icon || iconMap[this.props.type];
      let iconProps = Component.normalizeIconProps(icon);
      if (iconProps) {
        iconProps = Component.extendProps(iconProps, {
          classes: { "nom-message-icon": true },
        });
      }
      this.props.content = Component.normalizeTemplateProps(this.props.content);
      this.setProps({
        classes: { "nom-message-popup": !!this.props.position },
        content: { classes: { "nom-message-content": true } },
      });
      this.setProps({ children: [iconProps, this.props.content] });
      super._config();
    }
    close() {
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.remove();
    }
    animateHide() {
      if (!this.element) return false;
      this.addClass("nom-layer-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.remove();
      }, 90);
    }
    _rendered() {
      const that = this;
      const { props } = this;
      if (props.duration) {
        setTimeout(function () {
          that.close();
        }, 1000 * props.duration);
      }
    }
  }
  Message.defaults = {
    type: null,
    icon: null,
    content: null,
    duration: 2,
    closeToRemove: true,
    position: { my: "center center", at: "center center", of: window },
  };
  Component.register(Message); // Thanks to https://github.com/andreypopp/react-textarea-autosize/
  /**
   * calculateNodeHeight(uiTextNode)
   */ const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`;
  const SIZING_STYLE = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "font-variant",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
  ];
  let hiddenTextarea;
  function calculateNodeStyling(node) {
    const style = window.getComputedStyle(node);
    const boxSizing =
      style.getPropertyValue("box-sizing") ||
      style.getPropertyValue("-moz-box-sizing") ||
      style.getPropertyValue("-webkit-box-sizing");
    const paddingSize =
      parseFloat(style.getPropertyValue("padding-bottom")) +
      parseFloat(style.getPropertyValue("padding-top"));
    const borderSize =
      parseFloat(style.getPropertyValue("border-bottom-width")) +
      parseFloat(style.getPropertyValue("border-top-width"));
    const sizingStyle = SIZING_STYLE.map(
      (name) => `${name}:${style.getPropertyValue(name)}`
    ).join(";");
    const nodeInfo = { sizingStyle, paddingSize, borderSize, boxSizing };
    return nodeInfo;
  }
  function calculateNodeHeight(uiTextNode, minRows = null, maxRows = null) {
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      document.body.appendChild(hiddenTextarea);
    } // Fix wrap="off" issue
    // https://github.com/ant-design/ant-design/issues/6577
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", `${uiTextNode.getAttribute("wrap")}`);
    } else {
      hiddenTextarea.removeAttribute("wrap");
    } // Copy all CSS properties that have an impact on the height of the content in
    // the textbox
    const {
      paddingSize,
      borderSize,
      boxSizing,
      sizingStyle,
    } = calculateNodeStyling(uiTextNode); // Need to have the overflow attribute to hide the scrollbar otherwise
    // text-lines will not calculated properly as the shadow will technically be
    // narrower for content
    hiddenTextarea.setAttribute(
      "style",
      `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`
    );
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    let minHeight = Number.MIN_SAFE_INTEGER;
    let maxHeight = Number.MAX_SAFE_INTEGER;
    let height = hiddenTextarea.scrollHeight;
    let overflowY;
    if (boxSizing === "border-box") {
      // border-box: add border, since height = content + padding + border
      height += borderSize;
    } else if (boxSizing === "content-box") {
      // remove padding, since height = content
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      // measure height of a textarea with a single row
      hiddenTextarea.value = " ";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    return {
      height: `${height}px`,
      minHeight: `${minHeight}px`,
      maxHeight: `${maxHeight}px`,
      overflowY: overflowY ? `${overflowY}px` : undefined,
      resize: "none",
    };
  }
  class Textarea extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "textarea",
        attrs: { autocomplete: "off" },
        autoSize: false, // boolean|{minRows:number,maxRows:number}
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.multilineTextbox = this.parent;
      this.multilineTextbox.textarea = this;
      this.capsLock = false;
    }
    _config() {
      this.setProps({
        attrs: {
          oninput: () => {
            if (!this.capsLock) {
              this.multilineTextbox._onValueChange();
            }
            this.resizeTextarea();
          },
          onblur: () => {
            this.multilineTextbox.onblur();
          },
          oncompositionstart: () => {
            this.capsLock = true;
          },
          oncompositionend: () => {
            this.capsLock = false;
            this.element.dispatchEvent(new Event("input"));
          },
        },
      });
      if (this.props.readonly) {
        this.setProps({ attrs: { readonly: true } });
      }
    }
    _rendered() {
      if (this.multilineTextbox.props.autofocus === true) {
        this.focus();
      }
      this.resizeTextarea();
    }
    _remove() {
      cancelAnimationFrame && cancelAnimationFrame(this.resizeFrameId);
    }
    resizeTextarea() {
      const { autoSize } = this.props;
      if (!autoSize && this.element) {
        return;
      }
      cancelAnimationFrame && cancelAnimationFrame(this.resizeFrameId);
      this.resizeFrameId = requestAnimationFrame(() => {
        // TODO   updateStyles
        this._setStyle({ overflow: "hidden" });
        const { minRows, maxRows } = autoSize;
        const textareaStyles = calculateNodeHeight(
          this.element,
          minRows,
          maxRows
        ); // TODO   updateStyles
        this._setStyle(Object.assign({ overflow: "inherit" }, textareaStyles));
        this.fixFirefoxAutoScroll();
      });
    } // https://github.com/ant-design/ant-design/issues/21870
    fixFirefoxAutoScroll() {
      try {
        if (document.activeElement === this.element) {
          const currentStart = this.element.selectionStart;
          const currentEnd = this.element.selectionEnd;
          this.element.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e) {
        // Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    }
    getText() {
      return this.element.value;
    }
    setText(text) {
      this.element.value = text;
    }
    focus() {
      this.element.focus();
    }
    blur() {
      this.element.blur();
    }
    disable() {
      this.element.setAttribute("disabled", "disabled");
    }
    enable() {
      this.element.removeAttribute("disabled", "disabled");
    }
  }
  Component.register(Textarea);
  class MultilineTextbox extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(MultilineTextbox.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const {
        autoSize,
        value,
        placeholder,
        autofocus,
        readonly,
        rows,
      } = this.props;
      const maxlength = this.props.maxlength || this.props.maxLength;
      this.setProps({
        control: {
          children: {
            component: Textarea,
            autoSize: readonly || autoSize,
            readonly,
            attrs: { value, placeholder, autofocus, rows, maxlength },
            _created: function () {
              this.multilineTextbox = that;
              this.multilineTextbox.textarea = this;
            },
          },
        },
      });
      super._config();
    }
    _rendered() {
      const that = this;
      if (this.props.onEnter) {
        this.textarea._on("keydown", function (event) {
          if (event.keyCode && event.keyCode === 13) {
            that._callHandler(that.props.onEnter, {
              value: that.getValue(),
              event,
            });
          }
        });
      }
    }
    getText() {
      return this.textarea.getText();
    }
    _getValue() {
      const inputText = this.getText();
      if (inputText === "") {
        return null;
      }
      return inputText;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      this.textarea.setText(value);
      const newValue = this.getValue();
      if (options.triggerChange) {
        if (newValue !== this.oldValue) {
          super._onValueChange();
        }
      }
      this.oldValue = this.currentValue;
      this.currentValue = newValue;
    }
    onblur() {
      this._callHandler(this.props.onBlur, { value: this.getValue() });
    }
    focus() {
      this.textarea.focus();
    }
    blur() {
      this.textarea.blur();
    }
    _disable() {
      this.textarea.disable();
    }
    _enable() {
      this.textarea.enable();
    }
  }
  MultilineTextbox.defaults = {
    autofocus: false,
    autoSize: false, // boolean|{minRows:number,maxRows:number}
    placeholder: null,
    value: null,
    maxlength: null,
    rows: null,
    readonly: false,
    onEnter: null,
  };
  Component.register(MultilineTextbox);
  class NavbarCaption extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(NavbarCaption);
  class NavbarCaptionAfter extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(NavbarCaptionAfter);
  class NavbarCaptionBefore extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(NavbarCaptionBefore);
  class NavbarNav extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(NavbarNav);
  class NavbarTools extends Component {
    // constructor(props, ...mixins) {
    //     super(props, ...mixins)
    // }
  }
  Component.register(NavbarTools);
  class Navbar extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Navbar.defaults, props), ...mixins);
    }
    config() {
      this._addPropStyle("fit");
      const { caption, nav, tools, captionBefore, captionAfter } = this.props;
      let toolsProps, captionBeforeProps, captionAfterProps;
      const captionProps = caption
        ? Component.extendProps({ component: Caption, titleLevel: 3 }, caption)
        : null;
      const navProps = nav
        ? Component.extendProps({ component: Cols }, nav)
        : null;
      if (Array.isArray(tools)) {
        toolsProps = { component: Cols, items: tools };
      } else if (isPlainObject(tools)) {
        toolsProps = Component.extendProps({ component: Cols }, tools);
      }
      if (Array.isArray(captionBefore)) {
        captionBeforeProps = { component: Cols, items: captionBefore };
      } else if (isPlainObject(captionBefore)) {
        captionBeforeProps = Component.extendProps(
          { component: Cols },
          captionBefore
        );
      }
      if (Array.isArray(captionAfter)) {
        captionAfterProps = { component: Cols, items: captionAfter };
      } else if (isPlainObject(captionAfter)) {
        captionAfterProps = Component.extendProps(
          { component: Cols },
          captionAfter
        );
      }
      this.setProps({
        children: [
          captionBeforeProps && {
            component: NavbarCaptionBefore,
            children: captionBeforeProps,
          },
          captionProps && { component: NavbarCaption, children: captionProps },
          captionAfterProps && {
            component: NavbarCaptionAfter,
            children: captionAfterProps,
          },
          navProps && { component: NavbarNav, children: navProps },
          toolsProps && { component: NavbarTools, children: toolsProps },
        ],
      });
    }
  }
  Navbar.defaults = { caption: null, nav: null, tools: null };
  Component.register(Navbar);
  class NotificationContent extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        title: null,
        description: null, // type:null,
        // icon:'',
        // closeIcon: 'close',
        btn: false,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const {
        title,
        description,
        type,
        btn,
        closeIcon,
        onClose,
        okText,
      } = this.props;
      let { icon } = this.props;
      const iconMap = {
        info: "info-circle-fill",
        success: "check-circle-fill",
        error: "close-circle-fill",
        warning: "warning-circle-fill",
      };
      icon = icon || iconMap[type];
      const iconProps = icon
        ? Component.extendProps(Component.normalizeIconProps(icon), {
            classes: { "nom-notification-icon": true },
          })
        : null;
      const titleProps = title
        ? Component.extendProps(Component.normalizeTemplateProps(title), {
            classes: { "nom-notification-title": true },
          })
        : null;
      const closeIconProps = Component.extendProps(
        Component.normalizeTemplateProps({
          component: "Button",
          icon: closeIcon,
          styles: { border: "none" },
          onClick: function () {
            onClose();
          },
        }),
        { classes: { "nom-notification-close": true } }
      );
      const headerProps = {
        component: "Cols",
        justify: "between",
        items: [titleProps, closeIconProps],
      };
      const descriptionProps = description
        ? Component.extendProps(Component.normalizeTemplateProps(description), {
            classes: { "nom-notification-description": true },
          })
        : null;
      let actionProps;
      if (btn) {
        const okButtonProps = {
          component: Button,
          styles: { color: "primary" },
          size: "small",
          text: btn.text || okText,
          onClick: () => {
            onClose();
          },
        };
        actionProps = {
          component: Cols,
          justify: "end",
          items: [okButtonProps],
        };
      }
      this.setProps({
        children: [
          {
            classes: { "nom-notification-body": true },
            children: [
              icon
                ? {
                    classes: { "nom-notification-body-icon": true },
                    children: iconProps,
                  }
                : undefined,
              {
                classes: { "nom-notification-body-content": true },
                children: [headerProps, descriptionProps],
              },
            ],
          },
          actionProps
            ? {
                classes: { "nom-notification-actions": true },
                children: actionProps,
              }
            : undefined,
        ],
      });
    }
  }
  class Notification extends Layer {
    // Notification,key
    // /**
    //  * 
    //  * @param {*} props
    //  */
    // static configDefault(props) {
    //   Notification.NOMUI_NOTIFICATION_DEFAULTS = {
    //     ...Notification.NOMUI_NOTIFICATION_DEFAULTS,
    //     ...props,
    //   }
    // }
    constructor(props, ...mixins) {
      super(Component.extendProps(Notification.defaults, props), ...mixins);
    }
    static open(config) {
      let align = "topRight";
      if (config.align) {
        const alignInfo = config.align.toLowerCase();
        if (alignInfo.includes("top")) {
          if (alignInfo.includes("left")) {
            align = "topLeft";
          } else {
            align = "topRight";
          }
        } else if (alignInfo.includes("bottom")) {
          if (alignInfo.includes("left")) {
            align = "bottomLeft";
          } else {
            align = "bottomRight";
          }
        }
      }
      if (!Notification.NOMUI_NOTIFICATION_CONTAINER) {
        Notification.NOMUI_NOTIFICATION_CONTAINER = {
          topLeft: new nomui.Component({
            classes: {
              "nom-notification-container": true,
              "nom-notification-align-topleft": true,
            },
          }),
          topRight: new nomui.Component({
            classes: {
              "nom-notification-container": true,
              "nom-notification-align-topright": true,
            },
          }),
          bottomLeft: new nomui.Component({
            classes: {
              "nom-notification-container": true,
              "nom-notification-align-bottomleft": true,
            },
          }),
          bottomRight: new nomui.Component({
            classes: {
              "nom-notification-container": true,
              "nom-notification-align-bottomright": true,
            },
          }),
        };
      }
      const curInsance = Notification.NOMUI_NOTIFICATION_INSTANCES[config.key];
      if (!curInsance) {
        return new nomui.Notification(
          Object.assign({}, config, {
            reference: Notification.NOMUI_NOTIFICATION_CONTAINER[align],
          })
        );
      }
      curInsance.update(Object.assign({}, config));
      return curInsance;
    }
    static success(config) {
      Notification.open(Object.assign({}, config, { type: "success" }));
    }
    static error(config) {
      Notification.open(Object.assign({}, config, { type: "error" }));
    }
    static info(config) {
      Notification.open(Object.assign({}, config, { type: "info" }));
    }
    static warning(config) {
      Notification.open(Object.assign({}, config, { type: "warning" }));
    }
    static close(key) {
      if (Notification.NOMUI_NOTIFICATION_INSTANCES[key]) {
        Notification.NOMUI_NOTIFICATION_INSTANCES[key].close();
      }
    }
    _created() {
      super._created();
      this.timer = null;
      const { key } = this.props;
      Notification.NOMUI_NOTIFICATION_INSTANCES[key] = this;
    }
    _registerAutoClose(duration) {
      this.timer && clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.close();
      }, duration);
    }
    _rendered() {
      const { duration } = this.props;
      const that = this;
      if (duration !== null) {
        that._registerAutoClose(duration);
        this.element.addEventListener(
          "mouseenter",
          function () {
            that.timer && clearTimeout(that.timer);
          },
          false
        );
        this.element.addEventListener(
          "mouseleave",
          function () {
            that._registerAutoClose(duration);
          },
          false
        );
      }
    }
    _registerDuritionClose() {}
    close() {
      this.timer && clearTimeout(this.timer);
      const { key } = this.props;
      delete Notification.NOMUI_NOTIFICATION_INSTANCES[key];
      this.props.onClose && this.props.onClose();
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.remove();
    }
    _config() {
      const that = this;
      this._propStyleClasses = ["type"];
      const {
        styles,
        attrs = {},
        icon,
        type,
        closeIcon,
        title,
        btn,
        description,
        align,
        animate,
        okText,
      } = this.props;
      const classes = {};
      let alignInfo = "topright";
      if (align) {
        alignInfo = align.toLowerCase();
        if (alignInfo.includes("left")) {
          classes["nom-notification-animate-left-show"] = animate;
        } else if (alignInfo.includes("right")) {
          classes["nom-notification-animate-right-show"] = animate;
        }
      } else {
        classes["nom-notification-animate-right-show"] = animate;
      }
      this.setProps({
        closeToRemove: true,
        styles,
        alignInfo,
        align: null,
        alignTo: null,
        classes,
        attrs: Object.assign({}, attrs, { style: attrs.style }),
        children: {
          component: NotificationContent,
          type,
          icon,
          closeIcon,
          title,
          btn,
          description,
          okText,
          onClose: () => {
            that.close();
          },
        },
      });
      super._config();
    }
    animateHide() {
      if (!this.element) return false;
      if (this.props.alignInfo.includes("left")) {
        this.addClass("nom-notification-animate-left-hide");
      } else if (this.props.alignInfo.includes("right")) {
        this.addClass("nom-notification-animate-right-hide");
      }
      setTimeout(() => {
        if (!this.element) return false;
        this.remove();
      }, 240);
    }
  }
  _defineProperty2(Notification, "NOMUI_NOTIFICATION_DEFAULTS", {
    align: "topRight",
    duration: 4500,
  });
  _defineProperty2(Notification, "NOMUI_NOTIFICATION_CONTAINER", null);
  _defineProperty2(Notification, "NOMUI_NOTIFICATION_INSTANCES", {});
  Notification.defaults = Object.assign(
    {},
    Notification.NOMUI_NOTIFICATION_DEFAULTS,
    {
      // type:'',
      closeIcon: "close", // alignTo: document.body,
      title: "",
      description: "", // btn:boolean||{text:''},
      // closeIcon:{},
      key: newGuid(), // onClose:()=>{},
      okText: "",
    }
  );
  Component.register(Notification);
  class Numberbox extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(Numberbox.defaults, props), ...mixins);
    }
    _config() {
      let { precision, maxPrecision } = this.props;
      const { limitInput } = this.props;
      if (limitInput) {
        maxPrecision = null;
      }
      if (maxPrecision) {
        precision = -1;
        const str = this.props.maxPrecisionText.replace(
          "{{maxPrecision}}",
          maxPrecision
        );
        this.rules.push({
          type: "regex",
          value: { pattern: `^\\d+(\\.\\d{1,${maxPrecision}})?$` },
          message: str,
        });
      }
      if (precision === -1) {
        this.rules.push({ type: "number" });
      } //  , 
      if (precision === 0) {
        this.rules.push({
          type: "regex",
          value: { pattern: /^-?(\d+|\d{1,3}(,\d{3})+)$/ },
          message: this.props.integerText,
        });
      }
      if (precision > 0) {
        const str = this.props.precisionText.replace(
          "{{precision}}",
          precision
        );
        this.rules.push({
          type: "regex",
          value: {
            // 
            pattern: `^\\-?(\\d+|\\d{1,3}(,\\d{3})+)(\\.\\d{${precision}})$`,
          },
          message: str,
        });
      }
      if (this.props.min) {
        this.rules.push({ type: "min", value: this.props.min });
      }
      if (this.props.max) {
        this.rules.push({ type: "max", value: this.props.max });
      }
      super._config();
    }
    _onBlur() {
      if (!this.props.limitInput || this.props.precision < 0) {
        return;
      }
      this._toFixedValue();
    }
    _toFixedValue() {
      const { precision } = this.props;
      let r = "";
      const c = this.input.getText().replace(/[^0-9,.]/gi, "");
      const i = c.indexOf(".");
      r = i > -1 ? c.substring(0, i) : c;
      if (precision > 0) {
        let dec = i > -1 ? parseFloat(c.substring(i)) : parseFloat(0);
        if (!isNumeric(dec)) {
          return;
        }
        dec = dec.toFixed(precision);
        r += dec.substring(1);
      }
      this.input.setText(r);
    }
    _getValue() {
      const { precision = -1 } = this.props;
      let numberValue = null;
      const textValue = this.input.getText().replace(/,/g, "");
      if (precision) {
        const dotCount = this._dotCount(textValue);
        if (precision >= 0 && dotCount > precision) {
          numberValue = this._toDecimal(textValue, precision);
        } else {
          numberValue = parseFloat(textValue);
        }
      } else {
        numberValue = parseFloat(textValue);
      }
      if (Number.isNaN(numberValue)) {
        numberValue = null;
      }
      return numberValue;
    }
    _setValue(value, options) {
      const { precision = -1 } = this.props;
      this.currentValue = this.getValue();
      if (precision !== null && precision !== undefined) {
        if (precision >= 0) {
          const dotCount = this._dotCount(value);
          if (dotCount > precision) {
            value = this._toDecimal(value, precision);
          }
        }
      }
      if (Number.isNaN(value)) {
        value = "";
      }
      super._setValue(value, options);
    }
    _toDecimal(val, precision, notRound) {
      if (isNullish(val)) return null;
      if (notRound === undefined) {
        notRound = false;
      }
      let f = parseFloat(val);
      if (Number.isNaN(f)) {
        return;
      }
      if (notRound === true) {
        f = Math.floor(val * Math.pow(10, 2)) / Math.pow(10, 2);
      } else {
        f = Math.round(val * Math.pow(10, 2)) / Math.pow(10, 2);
      }
      return f;
    }
    _dotCount(val) {
      val = String(val);
      const dotPos = val.indexOf(".");
      const len = val.substr(dotPos + 1).length;
      return len;
    }
    _getRawValue() {
      return this.input.getText();
    }
  }
  Numberbox.defaults = {
    min: null,
    max: null,
    precision: -1,
    maxPrecision: null,
    limitInput: false,
    allowClear: false,
    maxPrecisionText: "{{maxPrecision}}",
    integerText: "",
    precisionText: "{{precision}}",
  };
  Component.register(Numberbox);
  class NumberInput extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(NumberInput.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      const { maxPrecision } = this.props;
      if (maxPrecision) {
        this.props.precision = -1;
        const str = this.props.maxPrecisionText.replace(
          "{{maxPrecision}}",
          maxPrecision
        );
        this.rules.push({
          type: "regex",
          value: { pattern: `^\\d+(\\.\\d{1,${maxPrecision}})?$` },
          message: str,
        });
      }
      this._setFormatter();
      this.setProps({ button: this._getControls() });
      super._config();
    }
    _setFormatter() {
      const { formatter, parser } = this.props;
      if (!formatter) {
        this.formatterFunc = (value) => {
          return value;
        };
      } else {
        this.formatterFunc = formatter;
      }
      if (!parser) {
        this.parserFunc = (value) => {
          return value;
        };
      } else {
        this.parserFunc = parser;
      }
    }
    _onBlur() {
      this._checkValue();
      this._setPrecision(true);
      this._onValueChange(true);
    }
    _onValueChange(isBlur) {
      if (Number.isNaN(this.getValue())) {
        return;
      }
      if (this.props.ignoreInputChange && !isBlur) {
        return;
      }
      this._setInputText();
      super._onValueChange();
    }
    _setInputText() {
      const text = this.parserFunc(this.getText());
      const newText = `${this.formatterFunc(text)}`;
      this.input.setText(newText);
    }
    _getControls() {
      if (!this.props.showSpinner) {
        return false;
      }
      return {
        component: "Component",
        classes: { "nom-number-input-controler": true },
        disabled: this.props.disabled,
        children: {
          component: "Flex",
          direction: "column",
          fit: true,
          items: [
            {
              classes: { "nom-number-input-controler-button": true },
              children: { component: "Icon", type: "up" },
              onClick: ({ event }) => {
                event.stopPropagation();
                this._onPlus();
              },
            },
            { classes: { divider: true }, children: "" },
            {
              classes: { "nom-number-input-controler-button": true },
              children: { component: "Icon", type: "down" },
              onClick: ({ event }) => {
                event.stopPropagation();
                this._onMinus();
              },
            },
          ],
        },
      };
    }
    _isEmptyOrInvalid(v) {
      return isNullish(v) || Number.isNaN(v) || v === "NaN" || v === "";
    }
    _setPrecision(isBlur) {
      const { precision } = this.props;
      let v = this.getValue();
      if (!precision || precision === -1 || (isNullish(v) && isBlur)) {
        return;
      }
      if (this._isEmptyOrInvalid(v)) {
        v = 0;
      }
      if (precision && precision > 0) {
        const n = parseFloat(v);
        v = n.toFixed(precision);
        this.setValue(v, { triggerChange: false });
      }
    }
    _checkValue() {
      const { min, max } = this.props;
      let v = this.getValue();
      if (Number.isNaN(Number(v))) {
        this.setValue(this.oldValue, { triggerChange: false });
      } else {
        let shouldChange = false;
        if ((min || min === 0) && v < min) {
          v = min;
          shouldChange = true;
        }
        if ((max || max === 0) && v > max) {
          v = max;
          shouldChange = true;
        }
        if (shouldChange) {
          this.setValue(v, { triggerChange: false });
        }
      }
    }
    _onPlus() {
      const { step, max } = this.props;
      let v = parseFloat(this.getValue({ asNumber: true }));
      if (this._isEmptyOrInvalid(v)) {
        v = 0;
      } // 
      const stepDecimal = (step.toString().split(".")[1] || "").length;
      const valueDecimal = (v.toString().split(".")[1] || "").length;
      const decimalPlaces = Math.max(stepDecimal, valueDecimal);
      v = parseFloat((v + step).toFixed(decimalPlaces));
      this.setValue((max || max === 0) && v > max ? max : v);
      this._setPrecision();
    }
    _onMinus() {
      const { step, min } = this.props;
      let v = parseFloat(this.getValue({ asNumber: true }));
      if (this._isEmptyOrInvalid(v)) {
        v = 0;
      } // 
      const stepDecimal = (step.toString().split(".")[1] || "").length;
      const valueDecimal = (v.toString().split(".")[1] || "").length;
      const decimalPlaces = Math.max(stepDecimal, valueDecimal);
      v = parseFloat((v - step).toFixed(decimalPlaces));
      this.setValue((min || min === 0) && v < min ? min : v);
      this._setPrecision();
    }
    _getValue(options) {
      if (!options) {
        options = {};
      }
      const text = this.input.getText();
      if (!text || !text.length) {
        return null;
      }
      const value = this.parserFunc(text);
      if (
        (this.props.stringMode ||
          (this.props.precision && this.props.precision > 0) ||
          this.props.formatter) &&
        !options.asNumber
      ) {
        return value;
      }
      return Number(value);
    }
    _setValue(value, options) {
      if (this.props.stringMode || this.props.formatter) {
        value = value || value === 0 ? `${value}` : "";
      }
      const { precision } = this.props;
      if (!Number.isNaN(this.getValue())) {
        this.currentValue = this.getValue();
      }
      value = this.formatterFunc(value);
      if (Number.isNaN(value) || value === "NaN") {
        value = "";
      }
      if (precision && precision > 0 && value !== "") {
        const n = parseFloat(value);
        value = n.toFixed(precision);
      }
      super._setValue(value, options);
    }
    _toDecimal(val, precision, notRound) {
      if (isNullish(val)) return null;
      if (notRound === undefined) {
        notRound = false;
      }
      let f = parseFloat(val);
      if (Number.isNaN(f)) {
        return;
      }
      if (notRound === true) {
        f = Math.floor(val * Math.pow(10, 2)) / Math.pow(10, 2);
      } else {
        f = Math.round(val * Math.pow(10, 2)) / Math.pow(10, 2);
      }
      return f;
    }
    _dotCount(val) {
      val = String(val);
      const dotPos = val.indexOf(".");
      const len = val.substr(dotPos + 1).length;
      return len;
    }
    _getRawValue() {
      return this.input.getText();
    }
  }
  NumberInput.defaults = {
    step: 1,
    min: Number.MIN_SAFE_INTEGER,
    max: Number.MAX_SAFE_INTEGER,
    showSpinner: true,
    stringMode: false,
    precision: -1,
    integerText: "",
    precisionText: "{{precision}}",
    allowClear: false,
    formatter: null,
    parser: null,
    ignoreInputChange: true,
    maxPrecision: null,
    maxPrecisionText: "{{maxPrecision}}",
  };
  Component.register(NumberInput);
  const SPINNER_POSITION = {
    left: "left",
    right: "right",
    horizontal: "horizontal",
  };
  const STYLE = {
    DECIMAL: "decimal",
    CURRENCY: "currency",
    PERCENT: "percent",
  };
  function isNil(value) {
    return value == null;
  }
  const COMMA_REG = /,/g;
  const CURRENCY_TO_VALUE_REG = /([^\d+-]*)([-]?)([\d,.]*)([^\d]*)/;
  function currencyReplacer(_match, _p1, p2, p3) {
    /*
     * US$-1,000.00
     * p1  US$
     * p2   -
     * p3  1,000.00
     * p4  
     *
     */ const val = `${p2}${p3}`.replace(/,/, "");
    return isNumeric(val) ? Number(val) : null;
  } // 
  function currencyToValue(curr) {
    return curr.replace(CURRENCY_TO_VALUE_REG, currencyReplacer);
  }
  function precentToValue(precent) {
    const parseStr = precent.replace(/%$/, "").replace(/,/g, "");
    return isNumeric(parseStr) ? Number(parseStr) : null;
  }
  class NumberSpinner extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(NumberSpinner.defaults, props), ...mixins);
      this._handleSpinnerIcon = this._handleSpinnerIcon.bind(this);
    }
    _config() {
      const numberSpinner = this;
      const rules = this._handleRules();
      this.setProps({ rules });
      const _this$props = this.props,
        { placeholder, align, showSpinner, value, formatter } = _this$props,
        otherProps = _objectWithoutPropertiesLoose2(_this$props, [
          "placeholder",
          "precision",
          "min",
          "max",
          "align",
          "showSpinner",
          "component",
          "reference",
          "tag",
          "ref",
          "style",
          "value",
          "formatter",
          "parser",
        ]);
      numberSpinner._initNumberFormat();
      const { left, right, horizontal } = SPINNER_POSITION;
      const inputProps = Object.assign(
        { component: Input, name: "input" },
        otherProps,
        {
          // value: isFunction(formatter) ? formatter(value) : numberSpinner._formatter.format(value),
          value: value === null ? null : numberSpinner._format(value),
          _created() {
            this.textbox = numberSpinner;
            this.textbox.input = this;
          },
          classes: {
            "spinner-input-with-left-icon":
              align === left && showSpinner === true,
            "spinner-input-with-right-icon":
              align === right && showSpinner === true,
            "spinner-input-with-double-icon":
              align === horizontal && showSpinner === true,
          },
          attrs: {
            placeholder,
            onkeydown(key) {
              if (key.keyCode === 38) {
                key.preventDefault();
                numberSpinner._handlePlus();
              } else if (key.keyCode === 40) {
                key.preventDefault();
                numberSpinner._handleMinus();
              }
            },
            onfocus() {
              const txt = this.value;
              if (txt) {
                this.selectionStart = this.value.length;
                this.selectionEnd = this.value.length;
              }
            },
            onchange() {
              const v = this.value.replace(COMMA_REG, ""); // 
              if (!isNumeric(v)) return;
              const formatterStr = isFunction(formatter)
                ? formatter(v)
                : numberSpinner._format(v);
              numberSpinner.isChange = true;
              numberSpinner.setValue(formatterStr);
            },
          },
        }
      );
      const spinner = numberSpinner._handleSpinnerIcon();
      this.setProps({
        control: {
          children: [...this._getLeftSpinner(), inputProps, ...spinner],
        },
      });
      super._config();
    }
    _getFormatValue() {
      const text = this.getText();
      if (text === "") return null;
      const { min, max } = this._getLimit();
      const { precision, parser } = this.props;
      if (isFunction(parser)) return parser(text);
      let parseString = text.toString();
      if (this.props.style === STYLE.PERCENT)
        parseString = parseString.replace(/%$/, "");
      if (this.props.style === STYLE.CURRENCY)
        parseString = parseString.replace(/^\D*/, "");
      parseString = parseString.replace(COMMA_REG, "");
      if (!isNumeric(parseString)) return null;
      const value = Number(parseString).toFixed(precision);
      if (value > max) return max;
      if (value < min) return min;
      return value;
    }
    _getValue() {
      const t = this.getText();
      if (t === "") {
        return null;
      }
      return t;
    }
    _setValue(value) {
      if (this.isChange) {
        this.input && this.input.setText(value);
        this.isChange = false;
        return;
      }
      const { max, min } = this._getLimit();
      if (value > max) {
        value = max;
      } else if (value < min) {
        value = min;
      }
      const formatValue = value === null ? value : this._format(value);
      this.input && this.input.setText(formatValue);
    }
    getText() {
      return this.input.getText();
    }
    getValueText() {
      return this.input.getText();
    }
    focus() {
      this.input.focus();
    }
    blur() {
      this.input.blur();
    }
    _disable() {
      this.input.disable();
    }
    _enable() {
      this.input.enable();
    }
    _onBlur() {
      this._callHandler(this.props.onBlur);
    }
    _handleRules() {
      const { precision } = this.props;
      const rules = [];
      if (precision === -1) rules.push({ type: "number" });
      if (precision === 0) {
        rules.push({
          type: "regex",
          value: { pattern: "^(\\-|\\+)?(0|[1-9][0-9]*)$" },
          message: this.props.integerText,
        });
      }
      if (this.props.precision > 0) {
        const str = this.props.precisionText.replace(
          "{{precision}}",
          this.props.precision
        );
        rules.push({
          type: "regex",
          value: {
            pattern: `^(\\-|\\+)?(0|[1-9][0-9]*)(\\.\\d{${this.props.precision}})$`,
          },
          message: str,
        });
      }
      if (this.props.min) {
        rules.push({ type: "min", value: this.props.min });
      }
      if (this.props.max) {
        rules.push({ type: "max", value: this.props.max });
      }
      return rules;
    }
    _getLeftSpinner() {
      const { align, showSpinner, simple } = this.props;
      if (showSpinner === false) return [];
      const numberSpinner = this;
      if (align === "left") {
        return [
          {
            // tag: 'span',
            _created(c) {
              numberSpinner.iconContainer = c;
            },
            classes: {
              [`nom-textbox-${align}-icon-container`]: true,
              "nom-number-spinner-vertical-trigger": true,
            },
            children: [
              {
                component: "Icon",
                type: simple ? "up" : "minus",
                styles: { flex: "grow" },
                onClick(args) {
                  numberSpinner._handlePlus(args);
                },
              },
              {
                component: "Icon",
                type: simple ? "down" : "plus",
                styles: { flex: "grow" },
                onClick(args) {
                  numberSpinner._handleMinus(args);
                },
              },
            ],
          },
        ];
      }
      if (align === "horizontal") {
        return [
          {
            component: "Icon",
            type: simple ? "down" : "minus",
            classes: {
              "nom-textbox-left-icon-container": true,
              "nom-textbox-right-icon-container-large": !simple,
            },
            onClick(args) {
              numberSpinner._handleMinus(args);
            },
          },
        ];
      }
      return [];
    }
    _handleSpinnerIcon() {
      const { align, showSpinner, simple } = this.props;
      if (showSpinner === false) return [];
      const numberSpinner = this;
      if (align === "right") {
        return [
          {
            // tag: 'span',
            _created(c) {
              numberSpinner.iconContainer = c;
            },
            classes: {
              [`nom-textbox-${align}-icon-container`]: true,
              "nom-number-spinner-vertical-trigger": true,
            },
            children: [
              {
                component: "Icon",
                type: simple ? "up" : "minus",
                styles: { flex: "grow" },
                onClick(args) {
                  numberSpinner._handlePlus(args);
                },
              },
              {
                component: "Icon",
                type: simple ? "down" : "plus",
                styles: { flex: "grow" },
                onClick(args) {
                  numberSpinner._handleMinus(args);
                },
              },
            ],
          },
        ];
      }
      if (align === "horizontal") {
        return [
          {
            component: "Icon",
            type: simple ? "up" : "plus",
            classes: {
              "nom-textbox-right-icon-container": true,
              "nom-textbox-right-icon-container-large": !simple,
            },
            onClick(args) {
              numberSpinner._handlePlus(args);
            },
          },
        ];
      }
      return [];
    }
    _isFocus() {
      if (!this.input) return false;
      return document.activeElement === this.input.element;
    }
    _handlePlus(args) {
      if (this.props.disabled) return;
      if (args) {
        const { event } = args;
        if (event) {
          event.preventDefault && event.preventDefault();
          event.stopPropagation && event.stopPropagation();
        }
      }
      let { step } = this.props;
      const { style, parser } = this.props;
      const { max } = this._getLimit();
      if (!isNumeric(step)) {
        step = 1;
      } else {
        step = Number(step);
      }
      let value = this._getFormatValue();
      if (isNil(value)) {
        value = 0;
      }
      value = Number(value);
      if (!this._formatter) this._initNumberFormat();
      const result = value + step;
      const displayValue = this._format(result);
      let newValue = "";
      if (isFunction(parser)) {
        newValue = parser(displayValue);
      } else if (style === STYLE.CURRENCY) {
        newValue = currencyToValue(displayValue);
      } else if (style === STYLE.PERCENT) {
        // newValue = Number(displayValue.replace(COMMA_REG, ''))
        newValue = precentToValue(displayValue);
      } else {
        newValue = Number(displayValue.replace(COMMA_REG, ""));
      }
      if (newValue > max) {
        this.setValue(max);
      } else {
        this.setValue(newValue);
        if (isFunction(this.props.onStep))
          this.props.onStep(this.getValue(), { offset: step, type: "plus" });
      }
      !this._isFocus() && this.focus();
    }
    _handleMinus(args) {
      if (this.props.disabled) return;
      if (args) {
        const { event } = args;
        if (event) {
          event.preventDefault && event.preventDefault();
          event.stopPropagation && event.stopPropagation();
        }
      }
      let { step } = this.props;
      const { style, parser } = this.props;
      const { min } = this._getLimit();
      if (!isNumeric(step)) {
        step = 1;
      } else {
        step = Number(step);
      }
      let value = this._getFormatValue();
      if (isNil(value)) {
        value = 0;
      }
      value = Number(value);
      if (!this._formatter) this._initNumberFormat(); // currency 
      let result = value - step;
      if (result < 0 && style !== "decimal") {
        result = 0;
      }
      const displayValue = this._format(result);
      let newValue = "";
      if (isFunction(parser)) {
        newValue = parser(displayValue);
      } else if (style === STYLE.CURRENCY) {
        newValue = currencyToValue(displayValue);
      } else if (style === STYLE.PERCENT) {
        newValue = precentToValue(displayValue);
      } else {
        newValue = Number(displayValue.replace(COMMA_REG, ""));
      }
      if (newValue < min) {
        this.setValue(min);
      } else {
        this.setValue(newValue);
        if (isFunction(this.props.onStep))
          this.props.onStep(this.getValue(), { offset: step, type: "minus" });
      }
      !this._isFocus() && this.focus();
    }
    _getLimit() {
      let { max, min } = this.props;
      const { style } = this.props;
      if (isNil(max) || !isNumeric(max)) {
        max = style === STYLE.PERCENT ? 100 : Number.MAX_SAFE_INTEGER;
      }
      if (isNil(min) || !isNumeric(min)) {
        min = style === STYLE.PERCENT ? 0 : Number.MIN_SAFE_INTEGER;
      }
      return { max, min };
    }
    _initNumberFormat() {
      const { formatter, precision, style, currency } = this.props; // formatterformatter
      if (isFunction(formatter)) {
        this._format = formatter;
        return;
      }
      if (style !== STYLE.CURRENCY) {
        this._formatter = new Intl.NumberFormat(undefined, {
          minimumFractionDigits: precision,
        });
        if (style === STYLE.DECIMAL) {
          this._format = this._formatter.format;
        } else if (style === STYLE.PERCENT) {
          this._format = function (value) {
            return `${this._formatter.format(value)}%`;
          };
        }
      } else {
        this._formatter = new Intl.NumberFormat(undefined, {
          style: STYLE.CURRENCY,
          currency,
          minimumFractionDigits: precision,
        });
        this._format = this._formatter.format;
      }
    }
  }
  NumberSpinner.defaults = {
    // min: Number.MIN_SAFE_INTEGER,
    // max: Number.MAX_SAFE_INTEGER,
    min: null,
    max: null,
    precision: 0,
    formatter: null,
    parser: null,
    step: 1,
    showSpinner: true,
    align: "right",
    simple: true, // decimal,currency,percent
    style: STYLE.DECIMAL,
    currency: "CNY",
    integerText: "",
    precisionText: "{{precision}}",
  };
  Component.register(NumberSpinner);
  class Pager extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Pager.defaults, props), ...mixins);
    }
    _config() {
      const pager = this;
      this._parseCacheable();
      this.setProps({
        classes: {
          "nom-pager-compact": this.props.compact,
          "nom-pager-simple": this.props.simple,
        },
        children: {
          component: "Cols",
          justify: pager.props.justify,
          items: pager._getItems(pager),
        },
      });
    }
    _getItems(pager) {
      const { itemsSort } = pager.props;
      return itemsSort.map((item) => {
        return pager[`_render${item}`](pager);
      });
    }
    _rendercount() {
      const str = this.props.texts.totalText.replace(
        "{{totalCount}}",
        this.props.totalCount
      );
      return { children: str };
    }
    _renderpages(pager) {
      const me = this;
      return {
        component: List,
        gutter: this.props.compact ? "sm" : "sm",
        items: pager.getPageItems(),
        itemDefaults: {
          tag: "a",
          key() {
            return this.props.pageNumber;
          },
          _config: function () {
            this.setProps({
              children: this.props.text,
              popup:
                !this.props.isArrow && me.props.simple
                  ? {
                      styles: { padding: "d5" },
                      children: me._rendersizes(pager, true),
                    }
                  : undefined,
            });
          },
        },
        itemSelectable: { byClick: true },
        selectedItems: pager.props.pageIndex,
        onItemSelectionChange: function (e) {
          const n = e.sender.selectedItem.props.pageNumber;
          if (n < 1) {
            pager.props.pageIndex = 1;
          } else if (n > pager._getPageCount()) {
            pager.props.pageIndex = pager._getPageCount();
          } else {
            pager.props.pageIndex = n;
          }
          pager._onPageChange();
        },
      };
    }
    _rendersizes(pager, force) {
      return (
        (force || !pager.props.simple) && {
          component: "Select",
          showSearch: false,
          compact: true,
          classes: { "nom-pager-select": true },
          value: pager.props.pageSize || this.props.pageSizeOptions[0].value,
          onValueChange: (data) => {
            pager._handleCache({ pageSize: data.newValue });
            pager.props.pageSize = data.newValue;
            pager.props.pageIndex = 1;
            pager._onPageChange(true);
          },
          allowClear: false,
          options: this.props.pageSizeOptions,
        }
      );
    } // 
    _parseCacheable() {
      const _isAutoKey = this.key.startWith("__key");
      if (this.props.cacheable && this.firstRender) {
        if (_isAutoKey) {
          return console.warn(
            "Please set a unique value key of string type first"
          );
        }
        let cacheInfo = localStorage.getItem(
          `${STORAGE_KEY_PAGER_CACHEABLE}_${this.key}`
        );
        if (cacheInfo) {
          cacheInfo = JSON.parse(cacheInfo);
          this.setProps({ pageSize: cacheInfo.pageSize });
        }
      }
    }
    _handleCache(params) {
      const _isAutoKey = this.key.startWith("__key");
      if (!this.props.cacheable || _isAutoKey) return;
      localStorage.setItem(
        `${STORAGE_KEY_PAGER_CACHEABLE}_${this.key}`,
        JSON.stringify(params)
      );
    }
    _onPageChange(pageSizeChanged) {
      const params = this.getPageParams();
      if (pageSizeChanged) {
        params.pageIndex = 1;
      }
      this._callHandler(this.props.onPageChange, params);
    }
    /**
     * pageIndex  displayItemCount.
     * @ {(Array)}
     */ _getInterval() {
      const { props } = this;
      const { pageIndex } = props;
      const displayItemHalf = Math.floor(props.displayItemCount / 2);
      const pageCount = this._getPageCount();
      const upperLimit = pageCount - props.displayItemCount;
      const start =
        pageIndex > displayItemHalf
          ? Math.max(Math.min(pageIndex - displayItemHalf, upperLimit), 1)
          : 1;
      const end =
        pageIndex > displayItemHalf
          ? Math.min(pageIndex + displayItemHalf, pageCount)
          : Math.min(props.displayItemCount, pageCount);
      return [start, end];
    }
    _getPageCount() {
      return Math.ceil(this.props.totalCount / this.props.pageSize);
    }
    getPageParams() {
      return this.props.getPageParams.call(this);
    }
    getPageItems() {
      const items = [];
      const { props } = this;
      if (props.totalCount === 0) {
        return items;
      }
      const { pageIndex } = props;
      const pageCount = this._getPageCount(); // "Previous"-
      if (props.texts.prev && (pageIndex > 1 || props.prevShowAlways)) {
        items.push({
          pageNumber: pageIndex - 1,
          text: props.texts.prev,
          disabled: pageIndex <= 1,
          classes: { prev: true },
          isArrow: true,
        });
      }
      this._getMiddleItems(items, pageCount); //  "Next"-
      if (props.texts.next && (pageIndex < pageCount || props.nextShowAlways)) {
        items.push({
          pageNumber: pageIndex + 1,
          text: props.texts.next,
          disabled: pageIndex >= pageCount,
          classes: { next: true },
          isArrow: true,
        });
      }
      return items;
    } // 
    _getMiddleItems(items, pageCount) {
      const { props } = this;
      const interval = this._getInterval(); // 
      if (!props.simple) {
        // 
        if (interval[0] > 1 && props.edgeItemCount > 0) {
          const end = Math.min(props.edgeItemCount, interval[0] - 1);
          for (let i = 1; i <= end; i++) {
            items.push({ pageNumber: i, text: i, classes: "" });
          }
          if (props.edgeItemCount < interval[0] - 1 && props.texts.ellipse) {
            items.push({
              pageNumber: interval[0] - 1,
              text: props.texts.ellipse,
              classes: { space: true },
              space: true,
            });
          }
        } // 
        for (let i = interval[0]; i <= interval[1]; i++) {
          items.push({ pageNumber: i, text: i, classes: "" });
        } // 
        if (interval[1] < pageCount && props.edgeItemCount > 0) {
          if (
            pageCount - props.edgeItemCount > interval[1] &&
            props.texts.ellipse
          ) {
            items.push({
              pageNumber: interval[1] + 1,
              text: props.texts.ellipse,
              classes: { space: true },
              space: true,
            });
          }
          const begin = Math.max(
            pageCount - props.edgeItemCount + 1,
            interval[1]
          );
          for (let i = begin; i <= pageCount; i++) {
            items.push({ pageNumber: i, text: i, classes: "" });
          }
        }
      } else {
        items.push({
          pageNumber: props.pageIndex,
          text: `${props.pageIndex}/${pageCount}`,
          classes: "",
        });
      }
    }
  }
  Pager.defaults = {
    pageIndex: 1,
    pageSize: 10,
    totalCount: 0,
    displayItemCount: 5,
    edgeItemCount: 1,
    compact: false,
    simple: false, // 
    prevShowAlways: true,
    nextShowAlways: true,
    paramsType: "default",
    justify: "end",
    itemsSort: ["count", "pages", "sizes"], //  1.count xx 2.List 3.Select
    pageSizeOptions: [
      { text: "10/", value: 10 },
      { text: "20/", value: 20 },
      { text: "30/", value: 30 },
      { text: "40/", value: 40 },
      { text: "50/", value: 50 },
    ],
    texts: {
      // prev: '',
      // next: '',
      prev: { component: "Icon", type: "prev" },
      next: { component: "Icon", type: "next" },
      ellipse: "...",
      totalText: "{{totalCount}}",
    },
    getPageParams: function () {
      const { pageIndex, pageSize } = this.props;
      let params = {};
      if (this.props.paramsType === "skiptake") {
        params = {
          skipCount: (pageIndex - 1) * pageSize,
          maxResultCount: pageSize,
        };
      } else {
        params = { pageIndex: pageIndex, pageSize: pageSize };
      }
      return params;
    },
  };
  Component.register(Pager);
  class PartialDatePicker extends Textbox {
    constructor(props, ...mixins) {
      super(
        Component.extendProps(PartialDatePicker.defaults, props),
        ...mixins
      );
    }
    _created() {
      super._created();
      this.year = null;
      this.quarter = null;
      this.month = null;
      this.week = null;
      this.hasRange = false;
      this.minSub = "00";
      this.maxSub = "60";
    }
    _config() {
      const {
        disabled,
        placeholder,
        animate,
        extraTools,
        mode,
        formatMap,
      } = this.props;
      if (!this.props.format) {
        this.props.format = formatMap[mode];
      }
      this._fixValue();
      if (this.props.value) {
        this.year =
          this.props.mode === "year"
            ? this.props.value
            : this.props.value.substring(0, 4);
      }
      let extra = [];
      if (isFunction(extraTools)) {
        extra = Array.isArray(extraTools(this))
          ? extraTools(this)
          : [extraTools(this)];
      } else if (Array.isArray(extraTools)) {
        extra = extraTools;
      }
      const that = this;
      this.setProps({
        leftIcon: "calendar",
        clearProps: {
          component: "Icon",
          type: "times",
          classes: { "nom-field-clear-handler": true },
          hidden: !this.props.allowClear || this.props.disabled,
          onClick: (args) => {
            this.clearTime();
            args.event && args.event.stopPropagation();
          },
        },
        control: {
          disabled: disabled,
          placeholder: placeholder,
          popup: {
            _created: function () {
              that.popup = this;
            },
            animate,
            classes: {
              "nom-partial-date-picker-popup": true,
              "nom-partial-date-picker-popup-hasfooter": extraTools !== null,
            },
            attrs: { style: { width: "auto", minHeight: "240px" } },
            triggerAction: "click",
            onShow: () => {
              if (!that.getValue()) {
                setTimeout(() => {
                  that.yearPicker.scrollTo(new Date().format("yyyy"));
                }, 200);
              } else {
                that.activeItem();
              }
              this.hasRange && this.updateList();
            },
            onHide: () => {
              that.getValue() &&
                that.props.onChange &&
                that._callHandler(that.props.onChange, that.getValue());
            },
            children: {
              component: "Flex",
              rows: [
                {
                  component: "Cols",
                  gutter: null,
                  fills: true,
                  align: "stretch",
                  children: [
                    {
                      children: {
                        component: "List",
                        items: that._getYear(),
                        itemSelectable: {
                          multiple: false,
                          byClick: true,
                          scrollIntoView: true,
                        },
                        gutter: "xs",
                        cols: 1,
                        ref: (c) => {
                          that.yearPicker = c;
                        },
                        onItemSelectionChange: (args) => {
                          const key = args.sender.props.selectedItems;
                          that.handleYearChange(key);
                        },
                        itemDefaults: {
                          _config: function () {
                            const key = this.props.key;
                            if (key < that.minYear || key > that.maxYear) {
                              this.setProps({ disabled: true });
                            }
                          },
                        },
                      },
                    },
                    that.props.mode === "quarter" && {
                      classes: { "nom-quarter-list": true },
                      children: {
                        component: "List",
                        items: that._getQuarter(),
                        itemSelectable: {
                          multiple: false,
                          byClick: true,
                          scrollIntoView: true,
                        },
                        gutter: "xs",
                        cols: 1,
                        ref: (c) => {
                          that.quarterPicker = c;
                          if (that.props.mode === "quarter") {
                            that.subPicker = c;
                          }
                        },
                        onItemSelectionChange: (args) => {
                          const key = args.sender.props.selectedItems;
                          that.handleQuarterChange(key);
                        },
                        itemDefaults: {
                          _config: function () {
                            const key = this.props.key;
                            if (
                              parseInt(key, 10) < parseInt(that.minSub, 10) ||
                              parseInt(key, 10) > parseInt(that.maxSub, 10)
                            ) {
                              this.setProps({ disabled: true });
                            }
                          },
                        },
                      },
                    },
                    that.props.mode === "month" && {
                      children: {
                        component: "List",
                        items: that._getMonth(),
                        itemSelectable: {
                          multiple: false,
                          byClick: true,
                          scrollIntoView: true,
                        },
                        gutter: "xs",
                        cols: 1,
                        ref: (c) => {
                          that.monthPicker = c;
                          if (that.props.mode === "month") {
                            that.subPicker = c;
                          }
                        },
                        onItemSelectionChange: (args) => {
                          const key = args.sender.props.selectedItems;
                          that.handleMonthChange(key);
                        },
                        itemDefaults: {
                          _config: function () {
                            const key = this.props.key;
                            if (
                              parseInt(key, 10) < parseInt(that.minSub, 10) ||
                              parseInt(key, 10) > parseInt(that.maxSub, 10)
                            ) {
                              this.setProps({ disabled: true });
                            }
                          },
                        },
                      },
                    },
                    that.props.mode === "week" && {
                      classes: { "nom-week-list": true },
                      children: {
                        component: "List",
                        items: that.year
                          ? that._getWeek(that.year)
                          : [
                              {
                                component: "StaticText",
                                value: that.props.selectYearText,
                                disabled: true,
                              },
                            ],
                        itemSelectable: {
                          multiple: false,
                          byClick: true,
                          scrollIntoView: true,
                        },
                        gutter: "xs",
                        cols: 1,
                        ref: (c) => {
                          that.weekPicker = c;
                          if (that.props.mode === "week") {
                            that.subPicker = c;
                          }
                        },
                        onItemSelectionChange: (args) => {
                          const key = args.sender.props.selectedItems;
                          that.handleWeekChange(key);
                        },
                        itemDefaults: {
                          _config: function () {
                            const key = this.props.key;
                            if (
                              parseInt(key, 10) < parseInt(that.minSub, 10) ||
                              parseInt(key, 10) > parseInt(that.maxSub, 10)
                            ) {
                              this.setProps({ disabled: true });
                            }
                          },
                        },
                      },
                    },
                  ],
                },
                extra.length && {
                  component: "Flex",
                  classes: { "nom-partial-date-picker-footer": true },
                  gutter: "small",
                  cols: extra,
                },
              ],
            },
          },
        },
      });
      super._config();
    }
    _rendered() {
      if (this.props.value) {
        this.resolveValue();
      }
      if (this.props.minDate || this.props.maxDate) {
        this.resolveRange();
      }
    }
    _getYear() {
      const years = [];
      const thisYear = new Date().getFullYear();
      for (
        let i = thisYear + this.props.yearRange[1];
        i > thisYear - this.props.yearRange[0];
        i--
      ) {
        const str = this.props.yearText.replace("{{year}}", i);
        years.push({ key: `${i}`, children: str });
      }
      return years;
    }
    _getMonth() {
      const month = [];
      const that = this;
      for (let i = 1; i < 13; i++) {
        // const str = this.props.monthText.replace('{{month}}', i)
        month.push({
          key: that._getDoubleDigit(i),
          children: this.props.monthMap[i],
        });
      }
      return month;
    }
    _getQuarter() {
      const quarter = [];
      for (let i = 1; i < 5; i++) {
        const str = this.props.quarterText.replace("{{quarter}}", i);
        quarter.push({ key: `${i}`, children: str });
      }
      return quarter;
    }
    _mapWeekData(param) {
      if (!param) return;
      const that = this; //       
      function yearDay(long) {
        const time = new Date(long * 1000);
        const year = `${time.getFullYear()}`;
        const month = that._getDoubleDigit(time.getMonth() + 1);
        const day = that._getDoubleDigit(time.getDate());
        const yearday = { year, month, day };
        return yearday;
      } // *1112XX1231
      // 
      // 
      //    
      //  52
      //   
      function whichWeek(year) {
        const d = new Date(parseInt(year, 10), 0, 1);
        while (d.getDay() !== 1) {
          d.setDate(d.getDate() + 1);
        }
        const arr = [];
        const longnum = d.setDate(d.getDate());
        if (longnum > +new Date(parseInt(year, 10), 0, 1)) {
          const obj = yearDay(longnum / 1000 - 86400 * 7);
          obj.last = yearDay(longnum / 1000 - 86400);
          arr.push(obj);
        }
        const oneitem = yearDay(longnum / 1000);
        oneitem.last = yearDay(longnum / 1000 + 86400 * 6);
        arr.push(oneitem);
        let lastStr;
        for (let i = 0; i < 51; i++) {
          const long = d.setDate(d.getDate() + 7);
          const obj = yearDay(long / 1000);
          obj.last = yearDay(long / 1000 + 86400 * 6);
          lastStr = long + 86400000 * 6;
          arr.push(obj);
        }
        if (lastStr < +new Date(parseInt(year, 10) + 1, 0, 1));
        else {
          arr.pop(); // arr[arr.length - 1].last = yearDay(+new Date(parseInt(year, 10) + 1, 0, 1) / 1000 - 86400)
        }
        return arr;
      }
      return whichWeek(param);
    }
    _getWeek(param) {
      const that = this;
      const week = this._mapWeekData(param).map(function (item, index) {
        const str = that.props.weekText.replace("{{week}}", index + 1);
        return {
          key: `${index + 1}`,
          firstDay: `${item.year}-${item.month}-${item.day}`,
          children: {
            component: "List",
            items: [
              { children: str },
              {
                classes: { "nom-week-subtitle": true },
                children: `(${item.year}/${item.month}/${item.day} - ${item.last.year}/${item.last.month}/${item.last.day})`,
              },
            ],
          },
        };
      });
      return week;
    }
    _getDoubleDigit(num) {
      if (num < 10) {
        return `0${num}`;
      }
      return `${num}`;
    }
    showPopup() {
      this.popup.show();
    }
    _getValueText() {
      const val = this.getValue();
      if (!val) return "NA";
      return val;
    }
    clearTime() {
      this.year = null;
      this.quarter = null;
      this.month = null;
      this.week = null;
      this._resetLists();
      this.setValue(null);
    }
    _resetLists() {
      this.yearPicker && this.yearPicker.unselectAllItems();
      this.monthPicker && this.monthPicker.unselectAllItems();
      this.quarterPicker && this.quarterPicker.unselectAllItems();
      this.weekPicker && this.weekPicker.unselectAllItems();
    }
    handleYearChange(key) {
      this.year = key;
      let noUpdate = false;
      if (this.hasRange && this.subPicker) {
        if (this.year <= this.minYear) {
          this.minSub = this.minAfter;
          this.setValue(null);
          this.subPicker.unselectAllItems();
          noUpdate = true;
        } else {
          this.minSub = "00";
        }
        if (this.year >= this.maxYear) {
          this.maxSub = this.maxAfter;
          this.setValue(null);
          this.subPicker.unselectAllItems();
          noUpdate = true;
        } else {
          this.maxSub = "60";
        }
        this.updateList(true);
      }
      if (this.props.mode === "week") {
        this.setValue(null, { triggerChange: false });
        this.weekPicker.parent.props.hidden &&
          this.weekPicker.parent.update({ hidden: false });
        this.weekPicker.update({ items: this._getWeek(this.year) });
        this.weekPicker.unselectAllItems();
        noUpdate = true;
      }
      !noUpdate && this.updateValue();
    }
    handleQuarterChange(key) {
      this.quarter = key;
      this.updateValue();
    }
    handleMonthChange(key) {
      this.month = key;
      this.updateValue();
    }
    handleWeekChange(key) {
      this.week = key;
      this.updateValue();
    }
    updateValue() {
      const old_val = this.getValue();
      let new_val;
      switch (this.props.mode) {
        case "year": {
          new_val = this.year;
          this.year && old_val !== new_val && this.setValue(new_val);
          break;
        }
        case "quarter": {
          new_val = this.props.format
            .replace("$year", this.year)
            .replace("$quarter", this.quarter);
          this.year &&
            this.quarter &&
            old_val !== new_val &&
            this.setValue(new_val);
          break;
        }
        case "month": {
          new_val = new Date(
            `${this.year}-${
              nomui.utils.isNumeric(this.month) ? this.month : "01"
            }`
          ).format(this.props.format);
          this.year &&
            this.month &&
            old_val !== new_val &&
            this.setValue(new_val);
          break;
        }
        case "week": {
          new_val = this.props.format
            .replace("$year", this.year)
            .replace("$week", this.week);
          this.year &&
            this.week &&
            old_val !== new_val &&
            this.setValue(new_val);
          break;
        }
      }
    }
    _fixValue() {
      let { value } = this.props;
      if (
        value instanceof Date ||
        (typeof value === "string" && !Number.isNaN(Date.parse(value)))
      ) {
        const date = new Date(value);
        if (this.props.mode === "year") {
          value = date.getFullYear().toString();
        } else if (this.props.mode === "month") {
          value = date.format("yyyy-MM");
        }
      }
      this.props.value = value;
    }
    resolveValue(value) {
      const v = value || this.getValue() || this.year;
      const strArr = v.match(/\d+/g);
      if (!strArr) {
        return;
      }
      const year = this.props.mode === "year" ? v : strArr[0];
      const after = this.props.mode === "year" ? null : Math.abs(strArr[1]);
      this.year = year;
      switch (this.props.mode) {
        case "year":
          break;
        case "quarter":
          this.quarter = `${after}`;
          break;
        case "month":
          this.month = `${after}`;
          break;
        case "week":
          this.week = `${after}`;
          break;
      }
    }
    close() {
      this.popup.hide();
    }
    resolveRange() {
      const min = this.props.minDate;
      const max = this.props.maxDate;
      if (min) {
        this.minYear = this.props.mode === "year" ? min : min.substring(0, 4);
        this.minAfter =
          this.props.mode === "year"
            ? null
            : Math.abs(parseInt(min.substring(4), 10));
        this.hasRange = true;
      }
      if (max) {
        this.maxYear = this.props.mode === "year" ? max : max.substring(0, 4);
        this.maxAfter =
          this.props.mode === "year"
            ? null
            : Math.abs(parseInt(max.substring(4), 10));
        this.hasRange = true;
      }
    }
    activeItem() {
      this.yearPicker.selectItem(this.year);
      switch (this.props.mode) {
        case "year":
          break;
        case "quarter":
          this.subPicker.selectItem(this.quarter);
          break;
        case "month":
          this.subPicker.selectItem(this.month);
          break;
        case "week":
          this.subPicker.selectItem(this.week);
          break;
      }
    }
    _setValue(value) {
      value && this.resolveValue(value);
      super._setValue(value);
    }
    updateList(noyear) {
      if (!noyear) {
        this.yearPicker.update();
      }
      this.props.mode !== "year" && this.subPicker.update();
    }
    getDateString(format) {
      if (!this.getValue()) {
        return null;
      }
      let date = null;
      switch (this.props.mode) {
        case "year":
          date = new Date(this.year);
          break;
        case "quarter":
          switch (this.quarter) {
            case "1":
              date = new Date(`${this.year}-01-01`);
              break;
            case "2":
              date = new Date(`${this.year}-04-01`);
              break;
            case "3":
              date = new Date(`${this.year}-07-01`);
              break;
            case "4":
              date = new Date(`${this.year}-10-01`);
              break;
          }
          break;
        case "month":
          date = new Date(this.getValue());
          break;
        case "week": {
          const time = this._mapWeekData(this.year)[
            parseInt(this.week, 10) - 1
          ];
          date = new Date(time.year, time.month - 1, time.day);
          break;
        }
      }
      return date.format(format || "yyyy-MM-dd");
    }
  }
  PartialDatePicker.defaults = {
    yearRange: [50, 20],
    mode: "year",
    allowClear: true,
    onChange: null,
    placeholder: "",
    value: null,
    minDate: null,
    maxDate: null,
    readonly: false,
    restrictInput: true,
    extraTools: null,
    selectYearText: "",
    formatMap: {
      quarter: "$year $quarter",
      month: "yyyy-MM",
      week: "$year $week",
    },
    yearText: "{{year}}",
    monthText: "{{month}}",
    quarterText: "{{quarter}}",
    weekText: "{{week}}",
    monthMap: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
    },
  };
  Component.register(PartialDatePicker);
  class PartialDateRangePicker extends Group {
    constructor(props, ...mixins) {
      super(
        Component.extendProps(PartialDateRangePicker.defaults, props),
        ...mixins
      );
    }
    _created() {
      super._created();
    }
    _config() {
      const that = this;
      const {
        allowClear,
        minDate,
        maxDate,
        yearRange,
        mode,
        required,
        requiredMessage,
        rules,
        startPickerProps,
        endPickerProps,
        disabled,
        animate,
      } = this.props;
      this.setProps({
        inline: true,
        fields: [
          Object.assign(
            {
              component: "PartialDatePicker",
              name: that.props.fieldName.start,
              ref: (c) => {
                that.startPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              animate,
              allowClear,
              minDate,
              maxDate,
              yearRange,
              mode,
              required,
              requiredMessage,
              rules,
              disabled,
            },
            startPickerProps
          ),
          { component: "StaticText", value: "-" },
          Object.assign(
            {
              component: "PartialDatePicker",
              name: that.props.fieldName.end,
              ref: (c) => {
                that.endPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              animate,
              allowClear,
              minDate,
              maxDate,
              yearRange,
              mode,
              required,
              requiredMessage,
              rules,
              disabled,
            },
            endPickerProps
          ),
        ],
      });
      super._config();
    }
    handleChange() {
      this.props.onChange && this._callHandler(this.props.onChange);
    }
    triggerEdit() {
      this.startPicker.triggerEdit();
    }
    _getValueText() {
      const val = this.getValue();
      const valText = {
        start:
          val[this.props.fieldName.start] === null
            ? "NA"
            : val[this.props.fieldName.start],
        end:
          val[this.props.fieldName.end] === null
            ? "NA"
            : val[this.props.fieldName.end],
      };
      return `${valText.start} - ${valText.end}`;
    }
    checkRange(type) {
      const that = this;
      const active =
        type === this.props.fieldName.start ? this.startPicker : this.endPicker;
      const opposite =
        type === this.props.fieldName.start ? this.endPicker : this.startPicker;
      if (active.getValue()) {
        if (active.name === that.props.fieldName.start) {
          opposite.update({ minDate: active.getValue() });
          if (opposite.getValue() && opposite.getValue() < active.getValue()) {
            opposite.clearTime();
            opposite.focus();
            opposite.showPopup();
          } else if (!opposite.getValue()) {
            opposite.focus();
            that.props.autoPopupEnd && opposite.showPopup();
          }
        } else if (
          opposite.getValue() &&
          opposite.getValue() > active.getValue()
        ) {
          opposite.clearTime();
        }
      }
      if (active.getValue() && opposite.getValue()) {
        that.handleChange();
      }
    }
  }
  PartialDateRangePicker.defaults = {
    mode: "year",
    minDate: null,
    maxDate: null,
    yearRange: [50, 20],
    allowClear: true,
    onChange: null,
    fieldName: { start: "start", end: "end" },
    autoPopupEnd: true,
    flatValue: true,
    startPickerProps: { placeholder: "" },
    endPickerProps: { placeholder: "" },
  };
  Component.register(PartialDateRangePicker);
  class PasswordPopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = {
        trigger: null,
        triggerAction: "click",
        align: "bottom left",
        alignOuter: true,
        closeOnClickOutside: true,
        placement: "append",
        autoRender: false,
        uistyle: "default",
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      this.setProps({
        children: [
          this.props.capslockText,
          {
            ref: (c) => {
              this.arrow = c;
            },
            classes: { "nom-password-arrow": true },
            children: `#<svg aria-hidden="true" width="24" height="6" viewBox="0 0 24 7" fill="currentColor" xmlns="http://www.w3.org/2000/svg" ><path d="M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z"></path></svg>`,
          },
        ],
      });
      super._config();
    }
    _onOpenerClickHandler() {
      if (
        this.opener.props.disabled !== true &&
        !this.props.PasswordPopupHidden
      ) {
        this.props.PasswordPopupHidden !== true ? this.show() : this.hide();
      }
    }
  }
  Component.register(PasswordPopup);
  class Password extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(Password.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.realValue = "";
      this.hasDefaultValue = false;
      this.capsLock = false;
      this.firstWrite = false;
      this.props.rightIconType = this.props.icons[0];
      if (this.props.value) {
        this.realValue = this.props.value;
        this.hasDefaultValue = true;
      }
    }
    _config() {
      const that = this;
      const { onValueChange } = this.props;
      if (that.tooltip) {
        that.tooltip.remove();
        delete that.tooltip;
      }
      this.setProps({
        type: "password",
        rightIcon: {
          type: this.props.rightIconType,
          hidden:
            !this.props.value ||
            this.props.disabled ||
            !this.props.visibilityToggle,
          ref: (c) => {
            this.rightIconRef = c;
          },
          onClick: function () {
            if (!that.props.value) {
              return;
            }
            that.update({
              rightIconType:
                that.props.rightIconType === that.props.icons[0]
                  ? that.props.icons[1]
                  : that.props.icons[0],
            });
            that.setValue(that.props.value);
          },
        },
        onValueChange: () => {
          const pass = that.getText();
          const start = that.input.element.selectionStart; // 
          const fake = pass ? pass.split("") : [];
          let real = that.realValue ? that.realValue.split("") : [];
          const clen = fake.length - real.length; // Value
          if (!pass) {
            that.realValue = null;
          } else {
            if (clen > 0) {
              // const middle = fake.join('').replace(/\*/g, '').split('')
              const middle = fake.slice(start - clen, start);
              const right =
                fake.length - start > 0
                  ? real.slice(-(fake.length - start))
                  : [];
              real = [].concat(
                real.slice(0, start - middle.length),
                middle,
                right
              );
            }
            if (clen < 0) {
              real.splice(start, Math.abs(clen));
            }
            fake.forEach(function (value, index) {
              if (value !== "*") {
                real[index] = value;
              }
            });
            that.realValue = real.join("");
          }
          that.setValue(that.realValue); // 
          if (pass && start < pass.length) {
            that.input.element.selectionStart = start;
            that.input.element.selectionEnd = start;
          }
          if (that.props.visibilityToggle) {
            pass ? that.rightIconRef.show() : that.rightIconRef.hide();
          }
          that._callHandler(onValueChange);
        },
      });
      super._config();
    }
    _rendered() {
      const that = this;
      const { capslockText } = this.props;
      if (this.hasDefaultValue && this.firstRender) {
        this.setValue(this.realValue);
      }
      this.popup = new PasswordPopup({
        capslockText,
        trigger: this.control,
        animate: false,
        triggerAction: "click",
        PasswordPopupHidden: true,
      });
      this.input.element.addEventListener("keyup", (event) => {
        // caps Lock
        if (event.keyCode === 20) {
          that.capsLock = !that.capsLock;
          this.firstWrite && this.popupSetProps();
          return;
        } // caps Lock
        const e = event || window.event;
        const keyvalue = e.keyCode ? e.keyCode : e.which;
        const shifKey = that.shifKey;
        if (typeof that.realValue === "undefined") return;
        const userPassword = that.realValue || "";
        const strStart = that.input.element.selectionStart; // 
        if (strStart) {
          const uniCode = userPassword.charCodeAt(strStart - 1); // 6590
          if (keyvalue >= 65 && keyvalue <= 90) {
            this.firstWrite = true; // shift
            if (
              (uniCode >= 65 && uniCode <= 90 && !shifKey) ||
              (uniCode >= 97 && uniCode <= 122 && shifKey)
            ) {
              that.capsLock = true;
            } else {
              that.capsLock = false;
            }
          }
        }
        this.popupSetProps();
      });
      this.input.element.addEventListener("keydown", (event) => {
        const e = event || window.event;
        const keyvalue = e.keyCode ? e.keyCode : e.which;
        const shifKey = e.shiftKey ? e.shiftKey : keyvalue === 16;
        this.shifKey = shifKey;
      });
    }
    popupSetProps() {
      this.capsLock ? this.popup.show() : this.popup.hide();
      this.popup.setProps({ PasswordPopupHidden: !this.capsLock });
    }
    _getValue() {
      return this.realValue ? this.realValue.trim(" ") : null;
    }
    _setValue(value) {
      const { rightIconType, value: oldValue, icons } = this.props;
      const pass = value
        ? rightIconType === icons[0]
          ? value.replace(/./g, "*")
          : value
        : null;
      this.input.setText(pass);
      if (oldValue !== value) {
        this.setProps({ value });
        this.realValue = value;
      }
    }
  }
  Password.defaults = {
    allowClear: false,
    visibilityToggle: true,
    capslockText: "",
    icons: ["eye", "eye-invisible"],
  };
  Component.register(Password);
  class Popconfirm extends Popup {
    constructor(props, ...mixins) {
      super(Component.extendProps(Popconfirm.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const { content, okText, cancelText, icon } = this.props;
      this.setProps({
        children: {
          attrs: { style: { "max-width": "350px", padding: "15px" } },
          children: {
            component: "Rows",
            items: [
              {
                component: "Cols",
                items: [
                  {
                    component: "Icon",
                    type: icon,
                    classes: { "nom-popconfirm-icon": true },
                  },
                  { children: isString(content) ? content : content() },
                ],
              },
              {
                component: "Cols",
                justify: "end",
                gutter: "sm",
                items: [
                  {
                    component: "Button",
                    type: "primary",
                    text: okText,
                    onClick: () => {
                      that._handleOk();
                    },
                  },
                  {
                    component: "Button",
                    text: cancelText,
                    onClick: () => {
                      that._handleCancel();
                    },
                  },
                ],
              },
            ],
          },
        },
      });
      super._config();
    }
    _handleOk() {
      this._callHandler(this.props.onConfirm);
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.hide();
    }
    _handleCancel() {
      this.props && this.props.animate && this.animateHide();
      this.props && !this.props.animate && this.hide();
    }
    animateHide() {
      if (!this.element) return false;
      this.addClass("nom-layer-animate-hide");
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
      }, 90);
    }
  }
  Popconfirm.defaults = {
    triggerAction: "click",
    closeOnClickOutside: false,
    content: null,
    onConfirm: null,
    okText: "",
    cancelText: "",
    icon: "info-circle-fill",
    align: "top left",
  };
  Component.mixin({
    _rendered: function () {
      if (this.props.popconfirm) {
        if (isString(this.props.popconfirm)) {
          this.popconfirm = new Popconfirm({
            trigger: this,
            children: this.props.popconfirm,
          });
        } else {
          this.popconfirm = new Popconfirm(
            Component.extendProps({}, this.props.popconfirm, { trigger: this })
          );
        }
      }
    },
  });
  Component.register(Popconfirm);
  let gradientSeed = 0;
  function stripPercentToNumber(percent) {
    return +percent.replace("%", "");
  }
  function toArray(symArray) {
    return Array.isArray(symArray) ? symArray : [symArray];
  }
  function getPathStyles(
    offset,
    percent,
    strokeColor,
    strokeWidth,
    gapDegree = 0,
    gapPosition
  ) {
    const radius = 50 - strokeWidth / 2;
    let beginPositionX = 0;
    let beginPositionY = -radius;
    let endPositionX = 0;
    let endPositionY = -2 * radius;
    switch (gapPosition) {
      case "left":
        beginPositionX = -radius;
        beginPositionY = 0;
        endPositionX = 2 * radius;
        endPositionY = 0;
        break;
      case "right":
        beginPositionX = radius;
        beginPositionY = 0;
        endPositionX = -2 * radius;
        endPositionY = 0;
        break;
      case "bottom":
        beginPositionY = radius;
        endPositionY = 2 * radius;
        break;
    }
    const pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
   a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
   a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
    const len = Math.PI * 2 * radius;
    const pathStyle = {
      stroke: strokeColor,
      "stroke-dasharray": `${(percent / 100) * (len - gapDegree)}px ${len}px`,
      "stroke-dashoffset": `-${
        gapDegree / 2 + (offset / 100) * (len - gapDegree)
      }px`,
      transition:
        "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s", // eslint-disable-line
    };
    return { pathString, pathStyle };
  }
  class CirclePath extends Component {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      const {
        prefixCls,
        strokeWidth,
        trailWidth,
        gapDegree,
        gapPosition,
        trailColor,
        strokeLinecap,
        style,
        strokeColor,
        percent,
      } = this.props;
      gradientSeed += 1;
      const gradientId = gradientSeed;
      const { pathString, pathStyle } = getPathStyles(
        0,
        100,
        trailColor,
        strokeWidth,
        gapDegree,
        gapPosition
      );
      const percentList = toArray(percent);
      const strokeColorList = toArray(strokeColor);
      const gradient = strokeColorList.find(
        (color) => Object.prototype.toString.call(color) === "[object Object]"
      );
      const getStokeList = () => {
        let stackPtg = 0;
        return percentList
          .map((ptg, index) => {
            const color =
              strokeColorList[index] ||
              strokeColorList[strokeColorList.length - 1];
            const stroke =
              Object.prototype.toString.call(color) === "[object Object]"
                ? `url(#${prefixCls}-gradient-${gradientId})`
                : "";
            const pathStyles = getPathStyles(
              stackPtg,
              ptg,
              color,
              strokeWidth,
              gapDegree,
              gapPosition
            );
            stackPtg += ptg;
            return {
              tag: "path",
              classes: { [`${prefixCls}-circle-path`]: true },
              attrs: {
                d: pathStyles.pathString,
                stroke: stroke,
                "stroke-linecap": strokeLinecap,
                "stroke-width": strokeWidth,
                opacity: ptg === 0 ? 0 : 1,
                "fill-opacity": "0",
                style: Object.assign({}, pathStyles.pathStyle),
              },
            };
          })
          .reverse();
      };
      this.setProps({
        tag: "svg",
        classes: { [`${prefixCls}-circle`]: true },
        attrs: Object.assign(
          {
            viewBox: "0 0 100 100",
            xmlns: "http://www.w3.org/2000/svg", // 'xmlns:xlink': 'http://www.w3.org/1999/xlink',
            "xml:space": "preserve",
          },
          style
        ),
        children: [
          gradient
            ? {
                tag: "defs",
                children: {
                  tag: "linearGradient",
                  attrs: {
                    id: `${prefixCls}-gradient-${gradientId}`,
                    x1: "100%",
                    y1: "0%",
                    x2: "0%",
                    y2: "0%",
                  },
                  children: Object.keys(gradient)
                    .sort(
                      (a, b) =>
                        stripPercentToNumber(a) - stripPercentToNumber(b)
                    )
                    .map((key) => {
                      return {
                        tag: "stop",
                        attrs: {
                          offset: key,
                          "stop-color": gradient[key],
                          "transition-duration": ".3s, .3s, .3s, .06s",
                        },
                      };
                    }),
                },
              }
            : undefined,
          {
            tag: "path",
            classes: { [`${prefixCls}-circle-trail`]: true },
            attrs: {
              d: pathString,
              stroke: trailColor,
              "stroke-linecap": strokeLinecap,
              "stroke-width": trailWidth || strokeWidth,
              "fill-opacity": "0",
              style: Object.assign({}, pathStyle),
            },
          },
          ...getStokeList(),
        ],
        _rendered() {
          this.element.outerHTML = `${this.element.outerHTML}`;
        },
      });
    }
  }
  function validProgress(progress) {
    if (!progress || progress < 0) {
      return 0;
    }
    if (progress > 100) {
      return 100;
    }
    return progress;
  }
  /**
   * @example
   *   {
   *     "0%": "#afc163",
   *     "75%": "#009900",
   *     "50%": "green", // ====> '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'
   *     "25%": "#66FF00",
   *     "100%": "#ffffff"
   *   }
   */ function sortGradient(gradients) {
    let tempArr = [];
    Object.keys(gradients).forEach((key) => {
      const formattedKey = parseFloat(key.replace(/%/g, ""));
      if (!Number.isNaN(formattedKey)) {
        tempArr.push({ key: formattedKey, value: gradients[key] });
      }
    });
    tempArr = tempArr.sort((a, b) => a.key - b.key);
    return tempArr.map(({ key, value }) => `${value} ${key}%`).join(", ");
  }
  /**
   * Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and
   * butter, there is the bug. And... Besides women, there is the code.
   *
   * @example
   *   {
   *     "0%": "#afc163",
   *     "25%": "#66FF00",
   *     "50%": "#00CC00", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
   *     "75%": "#009900", //        #00CC00 50%, #009900 75%, #ffffff 100%)
   *     "100%": "#ffffff"
   *   }
   */ const handleGradient = (strokeColor) => {
    const { from = "blue", to = "blue", direction = "to right" } = strokeColor,
      rest = _objectWithoutPropertiesLoose2(strokeColor, [
        "from",
        "to",
        "direction",
      ]);
    if (Object.keys(rest).length !== 0) {
      const sortedGradients = sortGradient(rest);
      return {
        backgroundImage: `linear-gradient(${direction}, ${sortedGradients})`,
      };
    }
    return { backgroundImage: `linear-gradient(${direction}, ${from}, ${to})` };
  };
  class ProgressCircle extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ProgressCircle.defaults, props), ...mixins);
    }
    _getGapDegree() {
      const { gapDegree, type } = this.props; // Support gapDeg = 0 when type = 'dashboard'
      if (gapDegree || gapDegree === 0) {
        return gapDegree;
      }
      if (type === "dashboard") {
        return 75;
      }
      return undefined;
    }
    _getPercentage({ percent, success }) {
      const ptg = validProgress(percent);
      const realSuccessPercent = success.percent;
      if (!realSuccessPercent) {
        return ptg;
      }
      return [
        validProgress(realSuccessPercent),
        validProgress(ptg - validProgress(realSuccessPercent)),
      ];
    }
    _getStrokeColor() {
      const { success = {}, strokeColor } = this.props;
      const color = strokeColor || null;
      const realSuccessPercent = success.percent;
      if (!realSuccessPercent) {
        return color;
      }
      return ["#52c41a", color];
    }
    _config() {
      const {
        width,
        strokeLinecap,
        percent,
        strokeWidth,
        gapPosition,
        trailColor,
        type,
        success = {},
        children,
      } = this.props;
      const circleWidth = strokeWidth || 6;
      const gapPos = gapPosition || (type === "dashboard" && "bottom") || "top"; // using className to style stroke color
      const strokeColor = this._getStrokeColor();
      const isGradient =
        Object.prototype.toString.call(strokeColor) === "[object Object]";
      const successPercent = this._getPercentage({ percent, success });
      const gapDegree = this._getGapDegree();
      this.setProps({
        classes: {
          [`${ProgressCircle._prefixClass}-inner`]: true,
          [`${ProgressCircle._prefixClass}-circle-gradient`]: isGradient,
        },
        attrs: {
          style: {
            width: `${width}px`,
            height: `${width}px`,
            fontSize: width * 0.15 + 6,
          },
        },
        children: [
          {
            component: CirclePath,
            percent: successPercent,
            strokeWidth: circleWidth,
            trailWidth: circleWidth,
            strokeColor: strokeColor,
            strokeLinecap: strokeLinecap,
            trailColor: trailColor,
            prefixCls: ProgressCircle._prefixClass,
            gapDegree: gapDegree,
            gapPosition: gapPos,
          },
          children,
        ],
      });
    }
  }
  _defineProperty2(ProgressCircle, "_prefixClass", "nom-progress");
  ProgressCircle.defaults = {
    width: 120, // strokeWidth:6
  };
  class ProgressLine extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ProgressLine.defaults, props), ...mixins);
    }
    _config() {
      const {
        size,
        strokeLinecap,
        strokeColor,
        percent,
        strokeWidth,
        trailColor,
        success = {},
        children,
      } = this.props;
      const successPercent = success.percent;
      const successSegment =
        successPercent !== undefined
          ? {
              classes: { [`${ProgressLine._prefixClass}-success-bg`]: true },
              attrs: {
                style: {
                  width: `${validProgress(successPercent)}%`,
                  height:
                    `${strokeWidth}px` || (size === "small" ? "6px" : "8px"),
                  borderRadius: strokeLinecap === "square" ? 0 : "",
                  backgroundColor: success.strokeColor,
                },
              },
            }
          : null;
      const trailStyle = trailColor
        ? { backgroundColor: trailColor }
        : undefined;
      const backgroundProps =
        strokeColor && typeof strokeColor !== "string"
          ? handleGradient(strokeColor)
          : { background: strokeColor };
      const percentStyle = Object.assign(
        {
          width: `${validProgress(percent)}%`,
          height: `${strokeWidth || (size === "small" ? 6 : 8)}px`,
          borderRadius: strokeLinecap === "square" ? 0 : "",
        },
        backgroundProps
      );
      this.setProps({
        children: [
          {
            classes: { [`${ProgressLine._prefixClass}-outer`]: true },
            children: {
              classes: { [`${ProgressLine._prefixClass}-inner`]: true },
              attrs: { style: trailStyle },
              children: [
                {
                  classes: { [`${ProgressLine._prefixClass}-bg`]: true },
                  attrs: { style: percentStyle },
                },
                successSegment,
              ],
            },
          },
          children,
        ],
      });
    }
  }
  _defineProperty2(ProgressLine, "_prefixClass", "nom-progress");
  ProgressLine.defaults = {
    // steps:100,
    // strokeColor:'',
    strokeWidth: 10,
  };
  class ProgressSteps extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(ProgressSteps.defaults, props), ...mixins);
    }
    _config() {
      const {
        size,
        strokeColor,
        percent,
        strokeWidth,
        trailColor,
        steps,
        children,
      } = this.props;
      const current = Math.round(steps * (percent / 100));
      const stepWidth = size === "small" ? 2 : 14;
      const styledSteps = [];
      for (let i = 0; i < steps; i += 1) {
        styledSteps.push({
          classes: {
            [`${ProgressSteps._prefixClass}-steps-item`]: true,
            [`${ProgressSteps._prefixClass}-steps-item-active`]:
              i <= current - 1,
          },
          attrs: {
            style: {
              backgroundColor: i <= current - 1 ? strokeColor : trailColor,
              width: `${stepWidth}px`,
              height: `${strokeWidth}px`,
            },
          },
        });
      }
      this.setProps({
        classes: { [`${ProgressSteps._prefixClass}-steps-outer`]: true },
        children: [...styledSteps, children],
      });
    }
  }
  _defineProperty2(ProgressSteps, "_prefixClass", "nom-progress");
  ProgressSteps.defaults = { strokeWidth: 8, percent: 0 };
  class Progress extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Progress.defaults, props), ...mixins);
    }
    getPercentNumber() {
      const { percent, success } = this.props;
      const { percent: successPercent } = success;
      return parseInt(
        successPercent !== undefined
          ? successPercent.toString()
          : percent.toString(),
        10
      );
    }
    getProgressStatus() {
      const { status } = this.props;
      const successPercent = this.getPercentNumber();
      if (status === "exception") {
        return "exception";
      }
      if (
        (status === undefined ||
          Progress._progressStatuses.indexOf(status) !== 0) &&
        successPercent >= 100
      ) {
        return "success";
      }
      return status || "normal";
    }
    renderProcessInfo(progressStatus) {
      const { showInfo, format, type, percent, infoWidth } = this.props;
      const successPercent = this.getPercentNumber();
      if (!showInfo) return null;
      let text;
      const textFormatter = format || ((percentNumber) => `${percentNumber}%`);
      const isLineType = type === "line";
      if (
        format ||
        (progressStatus !== "exception" && progressStatus !== "success")
      ) {
        text = textFormatter(
          validProgress(percent),
          validProgress(successPercent)
        );
      } else if (progressStatus === "exception") {
        text = isLineType
          ? { component: Icon, type: "close-circle" }
          : { component: Icon, type: "close" };
      } else if (progressStatus === "success") {
        text = isLineType
          ? { component: Icon, type: "check-circle" }
          : { component: Icon, type: "check" };
      }
      return {
        tag: "span",
        classes: { [`${Progress._prefixClass}-text`]: true },
        attrs: {
          title: typeof text === "string" ? text : undefined,
          style: {
            width: infoWidth ? `${infoWidth}px` : "",
            flex: infoWidth ? `0 0 ${infoWidth}px` : "",
          },
        },
        children: text,
      };
    }
    _config() {
      const {
        size,
        type,
        steps,
        showInfo,
        success,
        strokeColor,
        strokeLinecap,
        percent,
        strokeWidth,
        trailColor,
        gapDegree,
        width,
      } = this.props;
      const progressStatus = this.getProgressStatus();
      const progressInfo = this.renderProcessInfo(progressStatus);
      let children = {
        children: progressInfo,
        strokeColor: strokeColor,
        size,
        percent,
        strokeWidth,
        strokeLinecap,
        trailColor,
        success,
      };
      if (type === "line") {
        if (steps) {
          children = Object.assign({}, children, {
            strokeColor:
              typeof strokeColor === "string" ? strokeColor : undefined,
            component: ProgressSteps,
            steps,
          });
        } else {
          children = Object.assign({}, children, { component: ProgressLine });
        }
      } else if (type === "circle" || type === "dashboard") {
        children = Object.assign({}, children, {
          component: ProgressCircle,
          type,
          width,
          strokeLinecap,
          progressStatus: progressStatus,
          children: progressInfo,
          gapDegree,
        });
      } else {
        throw new Error(`${type} is not supported`);
      }
      this.setProps({
        classes: {
          [`${Progress._prefixClass}-status-normal`]: false,
          [`${Progress._prefixClass}-status-success`]: false,
          [`${Progress._prefixClass}-status-exception`]: false,
          [`${Progress._prefixClass}-status-active`]: false,
        },
      });
      this.setProps({
        classes: {
          [`${Progress._prefixClass}-${
            (type === "dashboard" && "circle") || (steps && "steps") || type
          }`]: true,
          [`${Progress._prefixClass}-status-${progressStatus}`]: true,
          [`${Progress._prefixClass}-show-info`]: showInfo,
          [`${Progress._prefixClass}-${size}`]: size,
        },
        children,
      });
    }
  }
  _defineProperty2(Progress, "_prefixClass", "nom-progress");
  _defineProperty2(Progress, "_progressStatuses", [
    "normal",
    "exception",
    "active",
    "success",
  ]);
  Progress.defaults = {
    type: "line", // 'line', 'circle', 'dashboard' //  line circle dashboard
    percent: 0, // 
    infoWidth: null, // format?:undefined, // (percentNumber,successPercent) => `${percentNumber}%` 
    // status:undefined, // 'normal', 'exception', 'active', 'success' // success exception normal active( line)
    showInfo: true, // 
    // null for different theme definition
    trailColor: null,
    size: "default", // 'default' ,'small' // strokeWidth:10,
    /**
     * type="line"
     *  10px
     * type="circle"
     *    6
     */ strokeLinecap: "round", //  'butt' | 'square' | 'round', //  // width: number,
    // strokeColor: string |  { from: string; to: string; direction: string }, //  object 
    // trailColor: string, // 
    /**
     * type="circle"  px  132px
     * type="dashboard"  px  132px
     */ success: {}, //  { percent: number, strokeColor: string }, // 
    // gapDegree: number,type="dashboard"  0 ~ 29575
    // gapPosition: 'top' | 'bottom' | 'left' | 'right', //   bottom
    // steps: number, // type="line"
  };
  Component.register(Progress);
  class RadioOptionList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        itemDefaults: {
          tag: "label",
          _config: function () {
            this.setProps({
              children: [
                { tag: "span", classes: { radio: true } }, // { tag: 'i' },
                {
                  tag: "span",
                  classes: { text: true },
                  children: this.list.controlRef.props.itemRender
                    ? this.list.controlRef.props.itemRender({
                        itemData: this.props,
                      })
                    : this.props[props.fieldName.text],
                },
              ],
            });
          },
        },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.radioList = this.parent.parent;
      this.radioList.optionList = this;
    }
    _config() {
      const listProps = this.radioList.props;
      if (listProps.type === "radio") {
        this.setProps({ gutter: "x-md" });
      }
      this.setProps({
        attrs: { style: { overflow: isChrome49() ? "visible" : "" } },
        disabled: listProps.disabled,
        items: listProps.options,
        itemDefaults: listProps.optionDefaults,
        itemSelectable: { byClick: true, canRevert: listProps.canRevert },
        selectedItems: listProps.value,
        onItemSelectionChange: () => {
          this.radioList._onValueChange();
        },
      });
      super._config();
    }
  }
  class RadioList extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(RadioList.defaults, props), ...mixins);
    }
    _config() {
      const { fieldName } = this.props;
      this.setProps({
        optionDefaults: {
          key() {
            return this.props[fieldName.value];
          },
        },
      });
      this.setProps({
        optionList: {
          component: RadioOptionList,
          onCreated: ({ inst }) => {
            inst.controlRef = this;
          },
          cols: this.props.cols,
          fieldName,
        },
      });
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: this.props.optionList,
      });
      super._config();
    }
    getSelectedOption() {
      return this.optionList.getSelectedItem();
    }
    _getValueText(options, value) {
      const { valueOptions, fieldName } = this.props;
      options = extend({ asArray: false }, valueOptions, options);
      const selected =
        value !== undefined
          ? this._getOptionByValue(value)
          : this.getSelectedOption();
      if (selected !== null) {
        if (options.asArray === true) {
          return selected.props
            ? [selected.props[fieldName.text]]
            : [selected[fieldName.text]];
        }
        return selected.props
          ? selected.props[fieldName.text]
          : selected[fieldName.text];
      }
      return null;
    }
    _getValue(options) {
      const { valueOptions, fieldName } = this.props;
      options = extend({ asArray: false }, valueOptions, options);
      const selected = this.getSelectedOption();
      if (selected !== null) {
        if (options.asArray === true) {
          return [selected.props[fieldName.value]];
        }
        return selected.props[fieldName.value];
      }
      return null;
    }
    _setValue(value, options) {
      const { fieldName } = this.props;
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      if (value === null) {
        this.optionList.unselectAllItems({
          triggerSelectionChange: options.triggerChange,
        });
      } else {
        if (Array.isArray(value)) {
          value = value[0];
        }
        this.optionList.selectItem(function () {
          return this.props[fieldName.value] === value;
        });
      }
    }
    _disable() {
      if (this.firstRender === false) {
        this.optionList.disable();
      }
    }
    _enable() {
      if (this.firstRender === false) {
        this.optionList.enable();
      }
    }
    _getOptionByValue(value) {
      const { fieldName } = this.props;
      let option = null;
      const { options } = this.props;
      if (Array.isArray(value)) {
        value = value[0];
      }
      for (let i = 0; i < options.length; i++) {
        if (options[i][fieldName.value] === value) {
          option = options[i];
          break;
        }
      }
      return option;
    }
  }
  RadioList.defaults = {
    options: [],
    uistyle: "radio",
    fieldName: { text: "text", value: "value" },
    canRevert: true,
  };
  Component.register(RadioList);
  function getValidMax(value) {
    if (!isNumeric(value)) return 100;
    if (value <= 0) return 100;
    return value;
  }
  function getValidValue(val, max = 100) {
    if (!val || !isNumeric(val) || val < 0) return 0;
    if (val > max) return max;
    return val;
  }
  function getOffset(container, offset, max = 100) {
    let _container = container;
    if (!_container) {
      return null;
    }
    if (_container instanceof Component) {
      _container = container.element;
    }
    if (!(_container instanceof HTMLElement)) {
      return null;
    }
    const { left, width } = _container.getBoundingClientRect();
    let result = ((offset - left) * max) / width;
    result = Math.min(max, result);
    result = Math.max(0, result);
    return result;
  }
  class RateStarChild extends Component {
    constructor(props, ...mixins) {
      const defaults = { rateIcon: "" };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.rate = this.parent.rate;
    }
  }
  Component.register(RateStarChild);
  class RateStar extends Component {
    constructor(props, ...mixins) {
      const defaults = { character: "", index: 0 };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.rate = this.parent.parent.field;
    }
    _config() {
      const { disabled } = this.rate.props;
      const { value, index, character } = this.props;
      const isFull = value >= index + 1;
      const isZero = value <= index;
      const rateIconProps = Component.normalizeIconProps("star");
      this.setProps({
        tag: "li",
        classes: {
          "nom-rate-star-full": isFull,
          "nom-rate-star-half": !isFull && !isZero,
          "nom-rate-star-zero": isZero,
        },
        children: [
          {
            component: RateStarChild,
            classes: { "nom-rate-star-first": true },
            children: character || rateIconProps,
            onClick: disabled ? null : this.handleClickRateStarFirst.bind(this),
          },
          {
            component: RateStarChild,
            classes: { "nom-rate-star-second": true },
            children: character || rateIconProps,
            onClick: disabled
              ? null
              : this.handleClickRateStarSecond.bind(this),
          },
        ],
      });
      super._config();
    } // 
    handleClickRateStarFirst() {
      const { allowHalf } = this.rate.props;
      const _newValue = this.props.index + (allowHalf ? 0.5 : 1);
      this._updateValue(_newValue);
    } // 
    handleClickRateStarSecond() {
      const _newValue = this.props.index + 1;
      this._updateValue(_newValue);
    }
    _updateValue(newValue = 0) {
      const { allowClear } = this.rate.props;
      const { value } = this.props; //  &&  -> 
      if (!allowClear && newValue === value) return; //  &&  -> newValue = 0
      if (allowClear && newValue === value) {
        newValue = 0;
      }
      this.rate.handleValueChange(newValue);
    }
  }
  Component.register(RateStar);
  class Rate extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Rate.defaults, props), ...mixins);
    }
    _config() {
      this.rate = this;
      const rateRef = this;
      this._initValue();
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: {
          children: {
            tag: "ul",
            classes: { "nom-rate-content": true },
            _created() {
              rateRef._content = this;
            },
            _config() {
              const children = rateRef._getRateChildren();
              this.setProps({ children: children });
            }, // children: children,
          },
        },
      });
      super._config();
    }
    _initValue() {
      const { value, count, allowHalf } = this.props; // value [0, count]
      this.initValue = getValidValue(value, count); // 
      if (!allowHalf) {
        this.initValue = Math.floor(this.initValue);
      }
      this.currentValue = this.initValue;
    }
    _getRateChildren() {
      const { count, character, tooltips } = this.props;
      return Array(count)
        .fill()
        .map((item, index) => {
          let char = character;
          if (isFunction(character)) {
            char = character({ index });
          }
          return {
            component: RateStar,
            character: char,
            value: this.currentValue,
            index,
            tooltip: tooltips && tooltips.length && tooltips[index],
          };
        });
    }
    triggerEdit() {
      return false;
    }
    handleValueChange(value) {
      this._setValue(value);
    }
    _getValue() {
      return this.tempValue;
    }
    _setValue(value) {
      const _value = value === null ? 0 : value;
      if (!isNumeric(_value) || _value < 0 || _value > this.props.count) return;
      this.tempValue = _value;
      if (_value !== this.oldValue) {
        super._onValueChange();
        this.oldValue = this.currentValue;
        this.currentValue = _value;
        this._content.update();
      }
    }
  }
  Rate.defaults = {
    allowClear: true,
    allowHalf: false,
    disable: false,
    rateIcon: "",
    value: null,
    disabled: false,
    count: 5,
    character: null,
    tooltips: null,
  };
  Component.register(Rate);
  const UnAuthorized = `#<svg width="251" height="294">
<g fill="none" fillRule="evenodd">
  <path
    d="M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023"
    fill="#E4EBF7"
  />
  <path
    d="M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65"
    fill="#FFF"
  />
  <path
    d="M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    d="M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126"
    fill="#FFF"
  />
  <path
    d="M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873"
    fill="#FFF"
  />
  <path
    d="M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    d="M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375"
    fill="#FFF"
  />
  <path
    d="M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    stroke="#FFF"
    strokeWidth="2"
    d="M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  />
  <path
    d="M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321"
    fill="#A26EF4"
  />
  <path
    d="M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734"
    fill="#FFF"
  />
  <path
    d="M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717"
    fill="#FFF"
  />
  <path
    d="M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61"
    fill="#5BA02E"
  />
  <path
    d="M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611"
    fill="#92C110"
  />
  <path
    d="M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17"
    fill="#F2D7AD"
  />
  <path
    d="M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085"
    fill="#FFF"
  />
  <path
    d="M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233"
    fill="#FFC6A0"
  />
  <path
    d="M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367"
    fill="#FFB594"
  />
  <path
    d="M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95"
    fill="#FFC6A0"
  />
  <path
    d="M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929"
    fill="#FFF"
  />
  <path
    d="M78.18 94.656s.911 7.41-4.914 13.078"
    stroke="#E4EBF7"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437"
    stroke="#E4EBF7"
    strokeWidth=".932"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z"
    fill="#FFC6A0"
  />
  <path
    d="M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91"
    fill="#FFB594"
  />
  <path
    d="M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103"
    fill="#5C2552"
  />
  <path
    d="M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145"
    fill="#FFC6A0"
  />
  <path
    stroke="#DB836E"
    strokeWidth="1.145"
    strokeLinecap="round"
    strokeLinejoin="round"
    d="M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  />
  <path
    d="M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32"
    fill="#552950"
  />
  <path
    d="M91.132 86.786s5.269 4.957 12.679 2.327"
    stroke="#DB836E"
    strokeWidth="1.145"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25"
    fill="#DB836E"
  />
  <path
    d="M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073"
    stroke="#5C2552"
    strokeWidth="1.526"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254"
    stroke="#DB836E"
    strokeWidth="1.145"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008"
    stroke="#E4EBF7"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M66.508 86.763s-1.598 8.83-6.697 14.078"
    stroke="#E4EBF7"
    strokeWidth="1.114"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M128.31 87.934s3.013 4.121 4.06 11.785"
    stroke="#E4EBF7"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M64.09 84.816s-6.03 9.912-13.607 9.903"
    stroke="#DB836E"
    strokeWidth=".795"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73"
    fill="#FFC6A0"
  />
  <path
    d="M130.532 85.488s4.588 5.757 11.619 6.214"
    stroke="#DB836E"
    strokeWidth=".75"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M121.708 105.73s-.393 8.564-1.34 13.612"
    stroke="#E4EBF7"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M115.784 161.512s-3.57-1.488-2.678-7.14"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68"
    fill="#CBD1D1"
  />
  <path
    d="M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z"
    fill="#2B0849"
  />
  <path
    d="M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62"
    fill="#A4AABA"
  />
  <path
    d="M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z"
    fill="#CBD1D1"
  />
  <path
    d="M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078"
    fill="#2B0849"
  />
  <path
    d="M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15"
    fill="#A4AABA"
  />
  <path
    d="M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954"
    fill="#7BB2F9"
  />
  <path
    d="M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M108.459 220.905s2.759-1.104 6.07-3.863"
    stroke="#648BD8"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017"
    fill="#192064"
  />
  <path
    d="M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806"
    fill="#FFF"
  />
  <path
    d="M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64"
    fill="#192064"
  />
  <path
    d="M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
</g>
</svg>
`;
  const ServerError = `#<svg width="254" height="294">
<defs>
  <path d="M0 .335h253.49v253.49H0z" />
  <path d="M0 293.665h253.49V.401H0z" />
</defs>
<g fill="none" fillRule="evenodd">
  <g transform="translate(0 .067)">
    <mask fill="#fff" />
    <path
      d="M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134"
      fill="#E4EBF7"
      mask="url(#b)"
    />
  </g>
  <path
    d="M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671"
    fill="#FFF"
  />
  <path
    d="M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    d="M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238"
    fill="#FFF"
  />
  <path
    d="M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775"
    fill="#FFF"
  />
  <path
    d="M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68"
    fill="#FF603B"
  />
  <path
    d="M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733"
    fill="#FFF"
  />
  <path
    d="M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487"
    fill="#FFB594"
  />
  <path
    d="M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235"
    fill="#FFF"
  />
  <path
    d="M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246"
    fill="#FFB594"
  />
  <path
    d="M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508"
    fill="#FFC6A0"
  />
  <path
    d="M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z"
    fill="#520038"
  />
  <path
    d="M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26"
    fill="#552950"
  />
  <path
    stroke="#DB836E"
    strokeWidth="1.063"
    strokeLinecap="round"
    strokeLinejoin="round"
    d="M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  />
  <path
    d="M99.926 73.284s1.8-.72 2.52.54"
    stroke="#5C2552"
    strokeWidth="1.117"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68"
    stroke="#DB836E"
    strokeWidth="1.117"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M92.326 71.724s1.84 1.12 4.16.96"
    stroke="#5C2552"
    strokeWidth="1.117"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954"
    stroke="#DB836E"
    strokeWidth="1.063"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044"
    stroke="#E4EBF7"
    strokeWidth="1.136"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583"
    fill="#FFF"
  />
  <path
    d="M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75"
    fill="#FFC6A0"
  />
  <path
    d="M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713"
    fill="#FFC6A0"
  />
  <path
    d="M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51"
    stroke="#E4EBF7"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16"
    fill="#FFC6A0"
  />
  <path
    d="M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575"
    fill="#FFF"
  />
  <path
    d="M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47"
    fill="#CBD1D1"
  />
  <path
    d="M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z"
    fill="#2B0849"
  />
  <path
    d="M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671"
    fill="#A4AABA"
  />
  <path
    d="M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z"
    fill="#CBD1D1"
  />
  <path
    d="M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162"
    fill="#2B0849"
  />
  <path
    d="M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156"
    fill="#A4AABA"
  />
  <path
    d="M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69"
    fill="#7BB2F9"
  />
  <path
    d="M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034"
    stroke="#648BD8"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M96.973 219.373s2.882-1.153 6.34-4.034"
    stroke="#648BD8"
    strokeWidth="1.032"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07"
    stroke="#648BD8"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62"
    fill="#192064"
  />
  <path
    d="M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843"
    fill="#FFF"
  />
  <path
    d="M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668"
    fill="#192064"
  />
  <path
    d="M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513"
    stroke="#648BD8"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72"
    stroke="#E4EBF7"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69"
    fill="#FFC6A0"
  />
  <path
    d="M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593"
    stroke="#DB836E"
    strokeWidth=".774"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762"
    stroke="#E59788"
    strokeWidth=".774"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594"
    fill="#FFC6A0"
  />
  <path
    d="M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12"
    stroke="#E59788"
    strokeWidth=".774"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M109.278 112.533s3.38-3.613 7.575-4.662"
    stroke="#E4EBF7"
    strokeWidth="1.085"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M107.375 123.006s9.697-2.745 11.445-.88"
    stroke="#E59788"
    strokeWidth=".774"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955"
    stroke="#BFCDDD"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01"
    fill="#A3B4C6"
  />
  <path
    d="M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813"
    fill="#A3B4C6"
  />
  <mask fill="#fff" />
  <path fill="#A3B4C6" mask="url(#d)" d="M154.098 190.096h70.513v-84.617h-70.513z" />
  <path
    d="M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208"
    fill="#BFCDDD"
    mask="url(#d)"
  />
  <path
    d="M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802"
    fill="#FFF"
    mask="url(#d)"
  />
  <path
    d="M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209"
    fill="#BFCDDD"
    mask="url(#d)"
  />
  <path
    d="M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751"
    stroke="#7C90A5"
    strokeWidth="1.124"
    strokeLinecap="round"
    strokeLinejoin="round"
    mask="url(#d)"
  />
  <path
    d="M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802"
    fill="#FFF"
    mask="url(#d)"
  />
  <path
    d="M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407"
    fill="#BFCDDD"
    mask="url(#d)"
  />
  <path
    d="M177.259 207.217v11.52M201.05 207.217v11.52"
    stroke="#A3B4C6"
    strokeWidth="1.124"
    strokeLinecap="round"
    strokeLinejoin="round"
    mask="url(#d)"
  />
  <path
    d="M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422"
    fill="#5BA02E"
    mask="url(#d)"
  />
  <path
    d="M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423"
    fill="#92C110"
    mask="url(#d)"
  />
  <path
    d="M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209"
    fill="#F2D7AD"
    mask="url(#d)"
  />
</g>
</svg>
`;
  const NotFound = `#<svg width="252" height="294">
<defs>
  <path d="M0 .387h251.772v251.772H0z" />
</defs>
<g fill="none" fillRule="evenodd">
  <g transform="translate(0 .012)">
    <mask fill="#fff" />
    <path
      d="M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321"
      fill="#E4EBF7"
      mask="url(#b)"
    />
  </g>
  <path
    d="M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66"
    fill="#FFF"
  />
  <path
    d="M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    d="M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175"
    fill="#FFF"
  />
  <path
    d="M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932"
    fill="#FFF"
  />
  <path
    d="M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    d="M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382"
    fill="#FFF"
  />
  <path
    d="M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z"
    stroke="#FFF"
    strokeWidth="2"
  />
  <path
    stroke="#FFF"
    strokeWidth="2"
    d="M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  />
  <path
    d="M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742"
    fill="#FFF"
  />
  <path
    d="M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48"
    fill="#1890FF"
  />
  <path
    d="M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894"
    fill="#FFF"
  />
  <path
    d="M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88"
    fill="#FFB594"
  />
  <path
    d="M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624"
    fill="#FFC6A0"
  />
  <path
    d="M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682"
    fill="#FFF"
  />
  <path
    d="M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573"
    fill="#CBD1D1"
  />
  <path
    d="M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z"
    fill="#2B0849"
  />
  <path
    d="M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558"
    fill="#A4AABA"
  />
  <path
    d="M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z"
    fill="#CBD1D1"
  />
  <path
    d="M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062"
    fill="#2B0849"
  />
  <path
    d="M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15"
    fill="#A4AABA"
  />
  <path
    d="M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165"
    fill="#7BB2F9"
  />
  <path
    d="M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M107.275 222.1s2.773-1.11 6.102-3.884"
    stroke="#648BD8"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038"
    fill="#192064"
  />
  <path
    d="M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81"
    fill="#FFF"
  />
  <path
    d="M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642"
    fill="#192064"
  />
  <path
    d="M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146"
    stroke="#648BD8"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268"
    fill="#FFC6A0"
  />
  <path
    d="M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456"
    fill="#FFC6A0"
  />
  <path
    d="M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z"
    fill="#520038"
  />
  <path
    d="M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254"
    fill="#552950"
  />
  <path
    stroke="#DB836E"
    strokeWidth="1.118"
    strokeLinecap="round"
    strokeLinejoin="round"
    d="M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  />
  <path
    d="M110.846 74.481s1.79-.716 2.506.537"
    stroke="#5C2552"
    strokeWidth="1.118"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67"
    stroke="#DB836E"
    strokeWidth="1.118"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M103.287 72.93s1.83 1.113 4.137.954"
    stroke="#5C2552"
    strokeWidth="1.118"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639"
    stroke="#DB836E"
    strokeWidth="1.118"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206"
    stroke="#E4EBF7"
    strokeWidth="1.101"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M129.405 122.865s-5.272 7.403-9.422 10.768"
    stroke="#E4EBF7"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M119.306 107.329s.452 4.366-2.127 32.062"
    stroke="#E4EBF7"
    strokeWidth="1.101"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01"
    fill="#F2D7AD"
  />
  <path d="M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92" fill="#F4D19D" />
  <path
    d="M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z"
    fill="#F2D7AD"
  />
  <path fill="#CC9B6E" d="M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z" />
  <path
    d="M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83"
    fill="#F4D19D"
  />
  <path
    fill="#CC9B6E"
    d="M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  />
  <path
    fill="#CC9B6E"
    d="M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  />
  <path
    d="M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238"
    fill="#FFC6A0"
  />
  <path
    d="M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044"
    stroke="#DB836E"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617"
    stroke="#DB836E"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754"
    stroke="#DB836E"
    strokeWidth="1.051"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
  <path
    d="M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647"
    fill="#5BA02E"
  />
  <path
    d="M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647"
    fill="#92C110"
  />
  <path
    d="M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187"
    fill="#F2D7AD"
  />
  <path
    d="M88.979 89.48s7.776 5.384 16.6 2.842"
    stroke="#E4EBF7"
    strokeWidth="1.101"
    strokeLinecap="round"
    strokeLinejoin="round"
  />
</g>
</svg>`;
  class Result extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Result.defaults, props), ...mixins);
    }
    renderIcon({ status, icon }) {
      const exceptionStatus = Object.keys(Result.ExceptionMap);
      if (exceptionStatus.includes(`${status}`)) {
        const svgComponent = Result.ExceptionMap[status];
        return {
          classes: { "nom-result-icon": true, "nom-result-image": true },
          children: svgComponent,
        };
      }
      let iconContent = Result.IconMap[status];
      if (icon) {
        if (isString(icon)) {
          iconContent = { component: "Icon", type: icon };
        } else {
          iconContent = icon;
        }
      }
      return {
        classes: { "nom-result-icon": true },
        children: Object.assign({ classes: { anticon: true } }, iconContent),
      };
    }
    _config() {
      const { status, title, subTitle, extra, icon, children } = this.props;
      this.setProps({
        classes: { [`nom-result-${status}`]: true },
        children: [
          this.renderIcon({ status, icon }),
          { classes: { "nom-result-title": true }, children: title },
          subTitle
            ? { classes: { "nom-result-subtitle": true }, children: subTitle }
            : null,
          extra
            ? { classes: { "nom-result-extra": true }, children: extra }
            : null,
          children
            ? { classes: { "nom-result-content": true }, children }
            : null,
        ],
      });
    }
  }
  Result.IconMap = {
    success: { component: "Icon", type: "check-circle" },
    error: { component: "Icon", type: "close-circle" },
    info: { component: "Icon", type: "info-circle" },
    warning: { component: "Icon", type: "exclamation-circle" },
  };
  Result.ExceptionMap = { 404: NotFound, 500: ServerError, 403: UnAuthorized };
  Result.defaults = {
    // icon: 'info',
    status: "info", //  '403' | '404' | '500'|'success'|'error'|'info'|'warning',
    // title: '',
    // subTitle:'',
    // extra:null,
    // children:null
  };
  Component.register(Result);
  class Row extends Component {
    // constructor(props, ...mixins) {
    //   super(props, ...mixins)
    // }
  }
  Component.register(Row);
  class Rows extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        wrap: false,
        items: [],
        itemDefaults: null,
        gutter: "md",
        childDefaults: { component: Row },
        showEmpty: false,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = ["gutter", "align", "justify"];
      const { items } = this.props;
      const children = [];
      if (Array.isArray(items) && items.length > 0) {
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          item = Component.extendProps({}, this.props.itemDefaults, item);
          children.push({ component: Row, children: item });
        }
        this.setProps({ children: children });
      } else if (this.props.showEmpty) {
        if (isPlainObject(this.props.showEmpty)) {
          this.setProps({
            children: Object.assign(
              { component: "Empty" },
              this.props.showEmpty
            ),
          });
        } else {
          this.setProps({ children: { component: "Empty" } });
        }
      }
    }
  }
  Component.register(Rows);
  var SelectListItemMixin = {
    _config: function () {
      const { onSelect, onUnselect } = this.props;
      this.setProps({
        selectable: {
          byClick: true,
          canRevert: this.list.selectControl.props.multiple === true,
        },
        hidden: !!this.props.isExtra,
        onSelect: () => {
          const { selectControl } = this.list;
          const selectProps = selectControl.props;
          const selectedOption = { option: this.props };
          Object.keys(this.wrapper.props.children).forEach((item) => {
            selectedOption[item] = this.props[item];
          });
          selectControl.placeholder && selectControl.placeholder.hide();
          if (selectProps.multiple === false) {
            selectControl.selectedSingle.update(selectedOption);
            selectControl.props.animate && selectControl.popup.animateHide();
            !selectControl.props.animate && selectControl.popup.hide();
          } else {
            selectControl.selectedMultiple.update({
              items: [
                ...selectControl.selectedMultiple.props.items,
                {
                  [selectControl.props.optionFields.text]: selectedOption.text,
                  [selectControl.props.optionFields.value]:
                    selectedOption.value,
                },
              ],
            });
          }
          if (selectProps.virtual === true) {
            this.list.virtual.selectedItems.push(selectedOption);
          }
          this._callHandler(onSelect);
        },
        onUnselect: () => {
          const { selectControl } = this.list;
          const selectProps = selectControl.props;
          if (selectProps.multiple === true) {
            selectControl.selectedMultiple.update({
              items: selectControl.selectedMultiple.props.items.filter((n) => {
                return n[selectControl.props.optionFields.value] !== this.key;
              }),
            });
          }
          if (selectProps.virtual === true) {
            const { selectedItems } = this.list.virtual;
            selectedItems.splice(
              selectedItems.findIndex(
                (item) =>
                  item[selectControl.props.optionFields.value] ===
                  this.props[selectControl.props.optionFields.value]
              ),
              1
            );
          }
          this._callHandler(onUnselect);
        },
      });
    },
  };
  class SelectList extends List {
    constructor(props, ...mixins) {
      const defaults = { gutter: "x-md", cols: 1, vertical: true };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.selectControl = this.parent.parent.parent.selectControl;
      this.selectControl.optionList = this;
    }
    _config() {
      const {
        showSearch,
        optionDefaults,
        value,
        multiple,
        filterOption,
        optionFields,
        options,
      } = this.selectControl.props;
      const { text } = this.props;
      const { checked, checkedOption } = this.selectControl;
      let filterStr = checked ? checkedOption && checkedOption.text : text; // nullundefined
      filterStr = filterStr || "";
      this.selectControl._normalizeInternalOptions(options);
      const filterOptions =
        showSearch &&
        filterOption(filterStr, this.selectControl.internalOptions);
      const items = showSearch
        ? filterOptions
        : this.selectControl.internalOptions; // value
      this._wranOptionsValue(items, optionFields.value);
      this.setProps({
        items,
        itemDefaults: n$1(null, optionDefaults, null, [SelectListItemMixin]),
        itemSelectable: {
          multiple: multiple,
          byClick: true,
          scrollIntoView: true,
        },
        selectedItems: showSearch
          ? checkedOption && checkedOption.value
          : value,
        onItemSelectionChange: () => {
          if (
            !this.selectControl.props.multiple ||
            !this.selectControl.props.changeOnClose
          ) {
            this.selectControl._onValueChange();
          }
        },
      });
      super._config();
    }
    _wranOptionsValue(options, value) {
      const map = new Map();
      for (let index = 0; index < options.length; index++) {
        const opt = options[index];
        if (map.get(opt[value])) {
          console.warn(
            `Warning: Encountered two children with the same key, \`${opt[value]}\`.`
          );
          return false;
        }
        map.set(opt[value], true);
      }
    }
  }
  class SelectPopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.selectControl = this.opener.field;
    }
    _config() {
      const {
        searchable,
        options: originOptions,
        popupWidth,
        extraTools,
      } = this.selectControl.props;
      let { maxPopupWidth } = this.selectControl.props;
      if (isNumeric(maxPopupWidth)) {
        maxPopupWidth = `${maxPopupWidth}px`;
      }
      let w = `${this.selectControl.control.offsetWidth()}px`;
      if (isNumeric(popupWidth)) {
        w = `${popupWidth}px`;
      } else if (popupWidth === "auto") {
        w = "auto";
      }
      this.setProps({
        attrs: {
          style: {
            width: w,
            maxWidth:
              maxPopupWidth || `${this.selectControl.control.offsetWidth()}px`,
          },
        },
        children: {
          component: Layout,
          header: searchable
            ? {
                children: {
                  component: Textbox,
                  placeholder: searchable.placeholder,
                  _created: (inst) => {
                    this.selectControl.searchBox = inst;
                  },
                  onValueChange: ({ newValue }) => {
                    this.timer && clearTimeout(this.timer);
                    this.timer = setTimeout(() => {
                      const loading = new nomui.Loading({
                        container: this.selectControl.optionList.parent,
                      });
                      const result = searchable.filter({
                        inputValue: newValue,
                        options: originOptions,
                        sender: this.selectControl,
                      });
                      if (result && result.then) {
                        return result
                          .then((value) => {
                            this.selectControl.props.options = value;
                            this.selectControl.optionList.update();
                            loading && loading.remove();
                          })
                          .catch(() => {
                            loading && loading.remove();
                          });
                      }
                      loading && loading.remove();
                      this.selectControl.props.options = result;
                      result && this.selectControl.optionList.update();
                    }, 300);
                  },
                },
              }
            : null,
          body: {
            children: [
              {
                component: SelectList,
                virtual: this.props.virtual,
                onRendered: ({ inst }) => {
                  if (!this.emptyTipRef) return;
                  if (inst.props.items && inst.props.items.length) {
                    this.emptyTipRef.hide();
                  } else {
                    this.emptyTipRef.show();
                  }
                },
              },
              searchable &&
                searchable.emptyTip && {
                  ref: (c) => {
                    this.emptyTipRef = c;
                  },
                  hidden: true,
                  classes: { "nom-select-popup-empty-tip": true },
                  children: searchable.emptyTip,
                },
            ],
          },
          footer:
            extraTools ||
            (this.selectControl.props.multiple &&
              this.selectControl.props.showSelectAll)
              ? {
                  classes: { "nom-select-popup-extra-tools": true },
                  children: [
                    this.selectControl.props.multiple &&
                      this.selectControl.props.showSelectAll && {
                        component: "Button",
                        classes: { "nom-select-selectall": true },
                        text: this.selectControl.props.selectAllText, // type: 'text',
                        size: "small",
                        onClick: ({ sender }) => {
                          if (
                            sender.props.text ===
                            this.selectControl.props.selectAllText
                          ) {
                            this.selectControl.selectAll();
                            sender.update({
                              text: this.selectControl.props.clearText,
                            });
                          } else {
                            this.selectControl.clear({
                              triggerChange: !this.selectControl.props
                                .changeOnClose,
                            });
                            sender.update({
                              text: this.selectControl.props.selectAllText,
                            });
                          }
                        },
                      },
                    isFunction(extraTools)
                      ? extraTools({ popup: this, inst: this.selectControl })
                      : extraTools,
                  ],
                }
              : null,
        },
      });
      super._config();
    }
    _rendered() {
      this.removeClass("nom-layer-animate-show");
      this.selectControl.props.animate && this.animateInit();
    }
    animateInit() {
      if (!this.element) return false;
      if (this.element.getAttribute("offset-y") !== "0") {
        this.addClass("nom-select-animate-bottom-show");
      } else {
        this.addClass("nom-select-animate-top-show");
      }
    }
    _show() {
      super._show();
      this.removeClass("nom-layer-animate-show");
      const { searchBox, props } = this.selectControl;
      if (searchBox) {
        searchBox.focus(); // 
        if (!props.options || !props.options.length) {
          searchBox.clear();
        }
      }
    }
    animateHide() {
      if (!this.element) return false;
      let animateName;
      if (this.element.getAttribute("offset-y") !== "0") {
        animateName = "nom-select-animate-bottom-hide";
      } else {
        animateName = "nom-select-animate-top-hide";
      }
      this.addClass(animateName);
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
        this.removeClass(animateName);
      }, 160);
    }
  }
  Component.register(SelectPopup);
  class Select extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Select.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.internalOptions = [];
      this.multipleItems = [];
      if (this.props.extraOptions) {
        const extraOptions = this.props.extraOptions.map((n) => {
          return Object.assign({}, n, { isExtra: true });
        });
        this.props.options = [...this.props.options, ...extraOptions];
      }
    }
    _config() {
      const that = this;
      const {
        multiple,
        showArrow,
        disabled,
        showSearch,
        allowClear,
        options,
      } = this.props;
      const children = [];
      const placeholder = this.props.placeholder; // if (!placeholder && (!Array.isArray(options) || !options.length)) {
      //   this.props.value = ''
      //   placeholder = ''
      // }
      this._normalizeInternalOptions(options);
      this._normalizeSearchable();
      this.setProps({
        selectedSingle: {
          _created() {
            that.selectedSingle = this;
          },
        },
        selectedMultiple: {
          itemDefaults: {
            key() {
              return this.props[that.props.optionFields.value];
            },
            _config: function () {
              this.setProps({
                tag: "span",
                onClick: (args) => {
                  args.event.stopPropagation();
                },
                hidden: this.props.isOverTag,
                classes: {
                  "nom-select-overtag-trigger": !!this.props.overList,
                },
                attrs: { title: this.props[that.props.optionFields.text] },
                popup: this.props.overList
                  ? {
                      triggerAction: "hover",
                      align: "top center",
                      classes: { "nom-select-extra-tags": true },
                      children: {
                        component: "List",
                        gutter: "sm",
                        itemDefaults: {
                          key() {
                            return this.props[that.props.optionFields.value];
                          },
                          _config: function () {
                            this.setProps({
                              tag: "span",
                              onClick: (args) => {
                                args.event.stopPropagation();
                              },
                              attrs: {
                                title: this.props[that.props.optionFields.text],
                              },
                              children: [
                                {
                                  tag: "span",
                                  classes: { "nom-select-item-content": true },
                                  attrs: {
                                    style: {
                                      maxWidth: `${that.props.maxTagWidth}px`,
                                    },
                                  },
                                  children: this.props[
                                    that.props.optionFields.text
                                  ],
                                },
                              ],
                            });
                          },
                        },
                        items: this.props.overList,
                      },
                    }
                  : null,
                children: [
                  {
                    tag: "span",
                    classes: { "nom-select-item-content": true },
                    attrs: {
                      style: { maxWidth: `${that.props.maxTagWidth}px` },
                    },
                    children: this.props.overList
                      ? `+${this.props.overNum}`
                      : this.props[that.props.optionFields.text],
                  },
                  !this.props.overList && {
                    component: Icon,
                    type: "times",
                    classes: { "nom-select-item-remove": true },
                    attrs: { style: { cursor: "pointer" } },
                    onClick: (args) => {
                      const key = args.sender.parent.key;
                      that.selectedMultiple.removeItem(key);
                      const oldValue = that.getValue();
                      oldValue &&
                        oldValue.length &&
                        that.setValue(
                          oldValue.filter((n) => {
                            return n !== key;
                          })
                        );
                      that.optionList && that.optionList.unselectItem(key);
                      args.event && args.event.stopPropagation();
                    },
                  },
                ],
              });
            },
            _rendered: function () {
              if (this.props.isOverTag) {
                this.element
                  .closest(".nom-list-item-wrapper")
                  .classList.add("s-hidden");
              } else {
                this.element
                  .closest(".nom-list-item-wrapper")
                  .classList.remove("s-hidden");
              }
            },
          },
          _config() {
            this.setProps({
              items: this.props.items.map((n) => {
                n.overList = null;
                n.overNum = null;
                return n;
              }),
            });
            if (
              that.props.maxTagCount > 0 &&
              this.props.items.length > that.props.maxTagCount
            ) {
              const before = this.props.items.slice(
                0,
                that.props.maxTagCount + 1
              );
              const after = this.props.items.slice(
                that.props.maxTagCount + 1,
                this.props.items.length
              );
              const overTags = this.props.items.slice(
                that.props.maxTagCount,
                this.props.items.length
              );
              const num = this.props.items.length - that.props.maxTagCount;
              const newItems = [
                ...before.map((n, i) => {
                  n.isOverTag = false;
                  if (i === before.length - 1) {
                    n.overList = overTags;
                    n.overNum = num;
                  } else {
                    n.overList = null;
                    n.overNum = null;
                  }
                  return n;
                }),
                ...after.map((n) => {
                  n.isOverTag = true;
                  return n;
                }),
              ];
              this.setProps({ items: newItems });
            }
          },
          _created() {
            that.selectedMultiple = this;
          },
        },
      });
      if (multiple) {
        children.push(this.props.selectedMultiple);
      } else if (showSearch) {
        const { onSearch } = this.props;
        that.checked = true;
        that.checkedOption = that._getOption(this.props.value);
        const searchInput = {
          tag: "input",
          classes: { "nom-select-search-input": true },
          _created() {
            that.selectedSingle = this;
          },
          _rendered() {
            this.element.value = this.props.text || "";
          },
          attrs: {
            autocomplete: "false",
            oninput() {
              that.checked = false;
              that.updateSearchPopup(this.value);
              isFunction(onSearch) && onSearch(this.value);
            },
            onchange() {
              if (that.checked) return;
              this.value = that.checkedOption ? that.checkedOption.text : null;
              that.updateSearchPopup(this.value);
            },
          },
        };
        children.push(searchInput);
      } else {
        children.push(this.props.selectedSingle);
      }
      if (isString(placeholder)) {
        children.push({
          _created() {
            that.placeholder = this;
          },
          classes: { "nom-select-placeholder": true },
          children: placeholder,
        });
      }
      if (showArrow) {
        children.push({
          component: Icon,
          type: "down",
          classes: { "nom-select-arrow": true },
        });
      }
      if (allowClear) {
        children.push({
          component: Icon,
          type: "times",
          classes: {
            "nom-select-clear": true,
            "nom-field-clear-handler": true,
          },
          hidden: true,
          ref: (c) => {
            this.clearIcon = c;
          },
          onClick: (args) => {
            this.setValue(null);
            this.props.allowClear && this.clearIcon.hide();
            this.placeholder && this.placeholder.show();
            this.props.onClear && this._callHandler(this.props.onClear);
            args.event && args.event.stopPropagation();
          },
        });
      }
      this.setProps({
        control: { disabled: disabled, children: children },
        onClick: () => {
          showSearch && this.selectedSingle.element.focus();
        },
      });
      super._config();
    }
    _rendered() {
      const { value, virtual, popupContainer } = this.props;
      let container;
      if (popupContainer === "self") {
        this.element.style.position = "relative";
        container = this.element;
      } else if (
        Object.prototype.toString.call(popupContainer) === "[object Function]"
      ) {
        const ref = popupContainer();
        ref.element.style.position = "relative";
        container = ref.element;
      }
      this.popup = new SelectPopup({
        reference: container,
        trigger: this.control,
        virtual,
        onShow: () => {
          this.optionList.update({ selectedItems: this.getValue() });
          if (this.props.multiple) {
            this._lastShowValue = this.getValue();
          }
          this.optionList.scrollToSelected();
        },
        onHide: () => {
          if (this.props.multiple && this.props.changeOnClose) {
            const _currentValue = this.getValue();
            if (!deepEqual(_currentValue, this._lastShowValue)) {
              this._onValueChange();
            }
          }
        },
      });
      this._directSetValue(value);
      this._valueChange({ newValue: this.currentValue });
    }
    _directSetValue(value, options) {
      const { valueOptions } = this.props;
      options = extend(
        { asArray: false, nullWhenNotExists: false },
        valueOptions,
        options
      );
      const { multiple } = this.props;
      if (multiple === true) {
        const selValueOptions = this._getOptions(value);
        if (Array.isArray(selValueOptions) && selValueOptions.length) {
          this.multipleItems = selValueOptions;
          this.selectedMultiple.update({ items: this.multipleItems });
          this.currentValue = selValueOptions.map(function (item) {
            return item.value;
          });
        } else {
          this.selectedMultiple.update({ items: [] });
          this.currentValue = null;
        }
      } else {
        if (options.asArray === true) {
          value = Array.isArray(value) ? value[0] : value;
        }
        const selValueOption = this._getOption(value);
        if (selValueOption !== null) {
          this.selectedSingle.update(selValueOption);
          this.currentValue = selValueOption.value;
          if (options.asArray === true) {
            this.currentValue = [selValueOption.value];
          }
        } else if (options.nullWhenNotExists) {
          this.selectedSingle.element.innerText = null;
          this.currentValue = null;
        } else {
          this.selectedSingle.element.innerText = value;
          this.currentValue = value;
        }
      } // selectsearchable
      if (this.searchBox && this.searchBox.props && value === null) {
        this.searchBox._setValue("");
      }
    }
    selectOption(option) {
      this.optionList.selectItem(option);
    }
    selectOptions(options) {
      this.optionList.selectItems(options);
    }
    getMultipleValue(obj) {
      return ((target) =>
        Object.keys(target).map((key) => target[key]))(obj.itemRefs);
    }
    getSelectedOption() {
      if (!this.optionList || !this.optionList.props) {
        return null;
      }
      if (this.props.multiple === false) {
        return this.optionList.getSelectedItem();
      } // console.log('---', this.optionList.getSelectedItems())
      // console.log('---', this.getMultipleValue(this.optionList.selectControl.selectedMultiple))
      return this.getMultipleValue(
        this.optionList.selectControl.selectedMultiple
      ); // return this.optionList.getSelectedItems()
    }
    _getOptionsByValue(value) {
      if (this.props.multiple === false) {
        return this._getOption(value);
      }
      return this._getOptions(value);
    }
    _getValueText(options, value) {
      const { valueOptions } = this.props;
      const that = this;
      options = extend({ asArray: false }, valueOptions, options);
      if (!this.optionList) {
        value = this.currentValue;
      }
      const selected =
        value !== undefined
          ? this._getOptionsByValue(value)
          : this.getSelectedOption();
      if (selected !== null) {
        if (Array.isArray(selected) && selected.length > 0) {
          const vals = selected.map(function (item) {
            return item.props
              ? item.props[that.props.optionFields.text]
              : item.text;
          });
          return vals;
        }
        if (options.asArray === true && !Array.isArray(selected)) {
          return selected.props
            ? [selected.props[that.props.optionFields.text]]
            : [selected.text];
        }
        if (!Array.isArray(selected)) {
          return selected.props
            ? selected.props[that.props.optionFields.text]
            : selected.text;
        }
      }
      return null;
    } // optionsoptionList
    _update(props) {
      if (props.options && this.optionList && this.optionList.props) {
        this.props.options = props.options;
        this.optionList.update({});
      }
    }
    _getValue(options) {
      const { valueOptions, showSearch } = this.props;
      const that = this;
      options = extend({ asArray: false }, valueOptions, options);
      if (!this.optionList || !this.optionList.props) {
        return this.currentValue;
      }
      if (showSearch) {
        const selectedSearch = this.getSelectedOption();
        if (selectedSearch && selectedSearch.props)
          return selectedSearch.props.value;
        return this.currentValue;
      }
      const selected = this.getSelectedOption();
      if (selected !== null) {
        if (Array.isArray(selected) && selected.length > 0) {
          const vals = selected.map(function (item) {
            return item.props[that.props.optionFields.value];
          });
          return vals;
        }
        if (options.asArray === true && !Array.isArray(selected)) {
          return [selected.props[that.props.optionFields.value]];
        }
        if (!Array.isArray(selected)) {
          return selected.props[that.props.optionFields.value];
        }
      }
      return null;
    }
    _setValue(value, options) {
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      if (this.props.showSearch) {
        const selectedOption = this.internalOptions.find(
          (e) => e.value === value
        );
        if (selectedOption) {
          this.checked = true;
          this.checkedOption = selectedOption;
          this.updateSearchPopup(selectedOption && selectedOption.text);
          this._directSetValue(value);
        }
      } else {
        // popup list
        //  update, optionList
        if (this.optionList && this.optionList.props) {
          this.optionList.unselectAllItems({ triggerSelectionChange: false });
          this.selectOptions(value, {
            triggerSelectionChange: options.triggerChange,
          });
        }
        this._directSetValue(value);
        if (options.triggerChange) {
          this._onValueChange();
        } // if (this.optionList) {
        //   this.optionList.unselectAllItems({ triggerSelectionChange: false })
        //   this.selectOptions(value, { triggerSelectionChange: options.triggerChange })
        // } else {
        //   this._directSetValue(value)
        //   if (options.triggerChange) {
        //     this._onValueChange()
        //   }
        // }
      }
    }
    _getOption(value) {
      let option = null;
      const options = this.internalOptions;
      if (Array.isArray(value)) {
        value = value[0];
      }
      for (let i = 0; i < options.length; i++) {
        if (options[i].value === value) {
          option = options[i];
          break;
        }
      }
      return option;
    }
    _getOptions(value) {
      let retOptions = null;
      const options = this.internalOptions;
      if (Array.isArray(value)) {
        retOptions = [];
        for (let i = 0; i < options.length; i++) {
          if (value.indexOf(options[i].value) !== -1) {
            retOptions.push(options[i]);
          }
        }
      }
      return retOptions;
    }
    _valueChange(changed) {
      if (!this.props) return; //  clearIcon, 
      changed.newValue
        ? this.props.allowClear && this.clearIcon.show()
        : this.props.allowClear && this.clearIcon.hide();
      if (this.placeholder) {
        //  || options
        if (
          (Array.isArray(changed.newValue) && changed.newValue.length === 0) ||
          !this._getOption(changed.newValue)
        ) {
          this.placeholder.show();
        } else {
          this.placeholder.hide();
        }
      } // this
      if (this.props && this.props.showSearch) {
        const selectedOption = this.internalOptions.find(
          (e) => e.value === changed.newValue
        );
        this.checkedOption = selectedOption;
        this.updateSearchPopup(selectedOption && selectedOption.text);
        this.checked = true;
      }
    }
    _disable() {
      if (this.firstRender === false) {
        this.control.disable();
      }
    }
    _enable() {
      if (this.firstRender === false) {
        this.control.enable();
      }
    }
    appendOption() {}
    updateSearchPopup(text) {
      if (this.optionList) this.optionList.update({ text });
    }
    handleFilter(text, options) {
      const { filterOption } = this.props;
      return filterOption(text, options);
    }
    selectAll() {
      if (!this.optionList) return;
      const allKeys = this.optionList.getAllItems().map((n) => {
        return n.key;
      });
      this.setValue(allKeys, { triggerChange: !this.props.changeOnClose });
    }
    clear(options = { triggerChange: true }) {
      this._resetValidStatus();
      this.setValue(null, options);
    }
    _normalizeSearchable() {
      const { searchable, optionFields } = this.props;
      if (searchable) {
        this.setProps({
          searchable: Component.extendProps(
            {
              placeholder: null,
              filter: ({ inputValue, options }) => {
                if (!inputValue) {
                  return options;
                }
                const filteredOptions = [];
                options.forEach((option) => {
                  if (option[optionFields.text].contains(inputValue)) {
                    filteredOptions.push(option);
                  }
                });
                return filteredOptions;
              },
            },
            searchable
          ),
        });
      }
    }
    _normalizeInternalOptions(options) {
      if (!Array.isArray(options) || !options.length) {
        this.internalOptions = [];
        return;
      } // if (this.props.extraOptions) {
      //   this.initHiddenOptions = this.props.extraOptions.map((n) => {
      //     return n[this.props.optionFields.value]
      //   })
      //   options = [...options, ...this.props.extraOptions]
      // }
      const { optionFields } = this.props;
      this.internalOptions = clone(options);
      this.handleOptions(this.internalOptions, optionFields);
    }
    handleOptions(options, optionFields) {
      const { text: textField, value: valueField } = optionFields;
      if (!Array.isArray(options)) return [];
      const internalOptions = options;
      for (let i = 0; i < internalOptions.length; i++) {
        const item = internalOptions[i];
        item.text = item[textField];
        item.value = item[valueField];
      }
    }
  }
  Select.defaults = {
    options: [],
    optionFields: { text: "text", value: "value" },
    optionDefaults: {
      key() {
        return this.props.value;
      },
      _config: function () {
        this.setProps({ children: this.props.text });
      },
    },
    selectedSingle: {
      classes: { "nom-select-single": true },
      _config: function () {
        this.setProps({ children: this.props.text });
      },
    },
    selectedMultiple: {
      classes: { "nom-select-multiple": true },
      component: List,
      itemDefaults: {},
      itemSelectable: { scrollIntoView: true },
      gutter: "sm",
    },
    extraOptions: [],
    multiple: false,
    showArrow: true,
    maxTagWidth: 120,
    maxTagCount: -1,
    minItemsForSearch: 20,
    filterOption: (text, options) =>
      options.filter((o) => o.text.indexOf(text) >= 0),
    virtual: false,
    allowClear: true,
    popupContainer: "body",
    popupWidth: null,
    showSelectAll: false,
    selectAllText: "",
    clearText: "",
  };
  Component.register(Select);
  class SkeletonAvatar extends Avatar {
    constructor(props, ...mixins) {
      super(Component.extendProps(SkeletonAvatar.defaults, props), ...mixins);
    }
  }
  SkeletonAvatar.defaults = {};
  Component.register(SkeletonAvatar);
  class SkeletonImage extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(SkeletonImage.defaults, props), ...mixins);
    }
    _config() {
      const width = isNumeric(this.props.width)
        ? `${this.props.width}px`
        : this.props.width;
      const height = isNumeric(this.props.height)
        ? `${this.props.height}px`
        : this.props.height;
      let fontSize = "2.5rem";
      if (width || height) {
        const num = Math.max(parseInt(width, 10), parseInt(height, 10));
        if (num > 200) {
          fontSize = "4rem";
        }
        if (num > 400) {
          fontSize = "5rem";
        }
      }
      this.setProps({
        attrs: { style: { width: width, height: height, fontSize: fontSize } },
        children: { component: "Icon", type: "image" },
      });
    }
  }
  SkeletonImage.defaults = { width: null, height: null };
  Component.register(SkeletonImage);
  class SkeletonParagraph extends Component {
    constructor(props, ...mixins) {
      super(
        Component.extendProps(SkeletonParagraph.defaults, props),
        ...mixins
      );
    }
    _config() {
      this.setProps({ tag: "ul", children: this.getParagraph() });
    }
    getParagraph() {
      const rows = this.props.paragraph > 1 ? this.props.paragraph : 3;
      const list = [];
      for (let i = 0; i < rows; i++) {
        list.push({ tag: "li" });
      }
      return list;
    }
  }
  SkeletonParagraph.defaults = {};
  Component.register(SkeletonParagraph);
  class SkeletonTitle extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(SkeletonTitle.defaults, props), ...mixins);
    }
    _config() {
      const width = isNumeric(this.props.width)
        ? `${this.props.width}px`
        : this.props.width;
      this.setProps({ attrs: { style: { width: width, maxWidth: width } } });
    }
  }
  SkeletonTitle.defaults = {};
  Component.register(SkeletonTitle);
  class Skeleton extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Skeleton.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const { type, cols, rows } = this.props;
      if (type) {
        const typeMap = {
          avatar: { component: SkeletonAvatar, size: this.props.size },
          title: { component: SkeletonTitle, width: this.props.width },
          paragraph: {
            component: SkeletonParagraph,
            paragraph: this.props.paragraph,
          },
          image: {
            component: SkeletonImage,
            width: this.props.width,
            height: this.props.height,
          },
        };
        this.setProps({
          children: typeMap[this.props.type],
          classes: { "nom-skeleton-single": true },
        });
      } else if (rows && cols) {
        this.setProps({
          children: {
            component: "Flex",
            gutter: "large",
            fills: true,
            rows: that.getCols(that.props.rows),
          },
        });
      } else if (rows || cols) {
        this.setProps({
          children: {
            component: "Flex",
            gutter: "large",
            fills: true,
            rows: that.props.rows ? that.getSkeleton(rows) : null,
            cols: that.props.cols ? that.getSkeleton(cols) : null,
          },
        });
      } else {
        this.setProps({ children: that.getSkeleton() });
      }
    }
    getCols(num) {
      if (!num) {
        num = 1;
      }
      const that = this;
      const arr = [];
      for (let i = 0; i < num; i++) {
        arr.push({
          fills: true,
          gutter: "large",
          cols: that.getSkeleton(that.props.cols),
        });
      }
      return arr;
    }
    getSkeleton(num) {
      if (!num) {
        num = 1;
      }
      const { avatar, title, paragraph, image } = this.props;
      const arr = [];
      for (let i = 0; i < num; i++) {
        arr.push({
          component: "Flex",
          gutter: "medium",
          cols: [
            avatar &&
              Object.assign({ component: SkeletonAvatar }, this.props.avatar),
            image &&
              Object.assign({ component: SkeletonImage }, this.props.image),
            {
              grow: true,
              children: [
                title && { component: SkeletonTitle },
                paragraph && {
                  component: SkeletonParagraph,
                  paragraph: this.props.paragraph,
                },
              ],
            },
          ],
        });
      }
      return arr;
    }
  }
  Component.mixin({
    _created: function () {
      if (this.props.skeleton && this.props.autoRender) {
        this.showSkeleton = true;
      }
    },
    _config: function () {
      if (this.showSkeleton && this.firstRender) {
        this.setProps({
          children: Object.assign(
            { component: "Skeleton" },
            this.props.skeleton
          ),
        });
        return false;
      }
    },
  });
  Skeleton.defaults = {
    type: null,
    avatar: false,
    title: true,
    paragraph: 3,
    image: false,
    cols: null,
    rows: null,
  };
  Component.register(Skeleton);
  class SlideCaptcha extends Component {
    constructor(props, ...mixins) {
      super(
        Component.extendProps(SlideCaptcha.defaults, props, {
          state: {
            // 
            startTime: new Date(), // 
            endTime: new Date(), // 
            isMove: false, // ()
            poorX: 0, // 
            distance: 0,
          },
        }),
        ...mixins
      );
    }
    dispatch(action) {
      let newState = {};
      switch (
        action.type // 
      ) {
        case "reset":
          newState = {
            // 
            startTime: new Date(), // 
            endTime: new Date(), // 
            isMove: false, // ()
            poorX: 0, // 
            distance: 0,
          };
          break; // 
        case "setStartTime":
          newState = { startTime: action.payload };
          break; // 
        case "setEndTime":
          newState = { endTime: action.payload };
          break; // 
        case "setMove":
          newState = { isMove: action.payload };
          break; // 
        case "setPoorX":
          newState = { poorX: action.payload };
          break; // 
        case "setDistance":
          newState = { distance: action.payload };
          break;
        case "change":
          newState = Object.assign({}, action.payload);
          break;
        default:
          throw new Error(
            `unsupport dispatch type:${action} in SlideCaptcha reducer`
          );
      }
      this.update({ state: Object.assign({}, newState) });
    }
    /**
     * 
     */ getMaxSlideWidth() {
      return this.props.width - 40;
    }
    defaultEvent(e) {
      e.preventDefault();
    }
    refresh() {
      this.props.onRefresh && this.props.onRefresh();
      this.dispatch({ type: "reset" });
    }
    /**
     * /
     * @param {*} currentPageX 
     */ dragStart(currentPageX) {
      const { state } = this.props;
      this.dispatch({
        type: "change",
        payload: {
          isMove: true,
          poorX: currentPageX - state.distance, // 
          startTime: new Date(),
        },
      });
    }
    /**
     * 
     * @param {*} currentPageX 
     */ dragMoving(currentPageX) {
      const { state } = this.props;
      const distance = currentPageX - state.poorX; // 
      const maxSlideWidth = this.getMaxSlideWidth();
      if (
        state.isMove &&
        distance !== state.distance &&
        distance >= 0 &&
        distance < maxSlideWidth
      ) {
        this.dispatch({ type: "change", payload: { distance } });
      }
    }
    /**
     * 
     * @param {*} currentPageX 
     */ dragEnd() {
      const that = this;
      const {
        state,
        validate,
        autoRefreshOnFail,
        onFinish,
        token,
        onFinishFailed,
      } = that.props; // 5 
      if (!state.isMove || state.distance < 5) {
        that.dispatch({ type: "reset" });
        return true;
      }
      that.dispatch({ type: "setMove", payload: false });
      if (state.poorX === undefined) {
        return true;
      }
      that.dispatch({ type: "setEndTime", payload: new Date() });
      setTimeout(() => {
        // 
        validate &&
          validate({
            token: token,
            point: state.distance,
            timespan: Math.abs(Number(state.endTime) - Number(state.startTime)),
          })
            .then((result) => {
              onFinish && onFinish(result);
              return result;
            })
            .catch((err) => {
              if (onFinishFailed) {
                onFinishFailed(err, that.refresh);
              }
              if (autoRefreshOnFail) {
                that.refresh();
              }
            });
      });
    }
    handleMouseMove(e) {
      this.dragMoving(e.pageX);
    }
    handleMouseUp() {
      this.dragEnd();
    }
    handleRefreshCaptcha(e) {
      this.refresh();
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
      e.stopImmediatePropagation && e.stopImmediatePropagation();
    }
    _config() {
      const {
        width,
        height,
        bgSrc,
        captchSrc,
        top,
        tip,
        refreshTitle,
        state,
      } = this.props;
      const that = this;
      this.setProps({
        attrs: { style: { height: `${height + 44}px`, width: `${width}px` } },
        children: [
          {
            tag: "div",
            attrs: {
              style: {
                width: `${width}px`,
                height: `${height}px`,
                background: "#e8e8e8",
              },
            },
            children: [
              {
                tag: "div",
                classes: { "captcha-img": true },
                attrs: {
                  style: {
                    backgroundImage: `url(${bgSrc})`,
                    width: `${width}px`,
                    height: `${height}px`,
                  },
                },
              },
              {
                tag: "div",
                classes: { "small-drag": true },
                attrs: {
                  style: {
                    backgroundImage: `url(${captchSrc})`,
                    top: `${top}px`,
                    left: `${state.distance}px`,
                  },
                },
              },
            ],
          },
          {
            tag: "div",
            classes: { drag: true },
            attrs: { style: { width: `${width}px` } },
            children: [
              {
                tag: "div",
                classes: { "drag-bg": true },
                attrs: { style: { width: `${state.distance}px` } },
              },
              {
                tag: "div",
                classes: { "drag-text": true },
                attrs: { style: { width: `${width}px` }, unselectable: "on" },
                children: tip,
              },
              {
                tag: "div",
                classes: { handler: true, "handler-bg": true },
                attrs: {
                  style: { left: `${state.distance}px` },
                  onmousedown: function (e) {
                    that.dragStart(e.pageX);
                  },
                },
              },
              {
                classes: { "refesh-btn": true },
                component: "Button",
                icon: "refresh",
                shape: "circle",
                type: "link",
                attrs: {
                  onmouseup: this.handleRefreshCaptcha,
                  style: { visibility: state.isMove ? "hidden" : "visible" },
                  title: refreshTitle,
                },
              },
            ],
          },
        ],
      });
    }
    _created() {
      this.handleMouseMove = this.handleMouseMove.bind(this);
      this.handleMouseUp = this.handleMouseUp.bind(this);
      this.dragStart = this.dragStart.bind(this);
      this.dragEnd = this.dragEnd.bind(this);
      this.dragMoving = this.dragMoving.bind(this);
      this.handleRefreshCaptcha = this.handleRefreshCaptcha.bind(this);
      this.defaultEvent = this.defaultEvent.bind(this); // 
      this.referenceElement.addEventListener(
        "mousemove",
        this.handleMouseMove,
        true
      );
      this.referenceElement.addEventListener("mouseup", this.handleMouseUp);
    }
    _remove() {
      this.referenceElement.removeEventListener(
        "mousemove",
        this.handleMouseMove,
        true
      );
      this.referenceElement.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
  SlideCaptcha.defaults = {
    token: null,
    bgSrc: "",
    captchSrc: "",
    width: 300,
    height: 300,
    top: 0, // onRefresh:()=>{},
    // validate:()=>{},
    // onFinish:()=>{},
    // onFinishFailed:()=>{},
    refreshTitle: "",
    tip: "",
    autoRefreshOnFail: true, // 
  };
  Component.register(SlideCaptcha);
  class Slider extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Slider.defaults, props), ...mixins);
      _defineProperty2(this, "_handleMouseMove", (event) => {
        if (!this._isDragging) return;
        const barWdith = this._bar.element.offsetWidth;
        const deltaX = event.clientX - this._startX;
        this._newOffset =
          this._offset + Math.round((deltaX / barWdith) * this._max);
        const left = Math.round((barWdith * this._newOffset) / this._max);
        if (this._newOffset < 0 || this._newOffset > this._max) {
          return;
        }
        this._handler.element.style.left = `${left}px`;
      });
      _defineProperty2(this, "_handleMouseUp", () => {
        window.removeEventListener("mousemove", this._handleMouseMove);
        window.removeEventListener("mouseup", this._handleMouseUp);
        if (!this._isDragging) return;
        this._isDragging = false;
        if (this._newOffset) {
          this._offset = this._newOffset;
          if (this._offset <= 0) {
            this._offset = 0;
          }
          if (this._offset >= this._max) {
            this._offset = this._max;
          }
          this.setValue(Math.round(this._offset));
        }
      });
    }
    _created() {
      const { value } = this.props; // 0100
      const max = getValidMax();
      this.initValue = getValidValue(value, max);
      super._created();
    }
    _config() {
      const sliderRef = this;
      const { value, disable, showTip } = this.props;
      this._max = getValidMax(this.props.max);
      sliderRef._offset = getValidValue(value, this._max);
      this.setProps({
        control: {
          children: {
            classes: {
              "nom-slider-content": true,
              "nom-slider-content-disabled": disable,
            },
            _created() {
              sliderRef._bar = this;
            },
            onClick: disable
              ? null
              : ({ event }) => {
                  event.target.focus();
                  const _offset = getOffset(
                    sliderRef._bar,
                    event.clientX,
                    sliderRef._max
                  );
                  sliderRef.setValue(Math.round(_offset));
                },
            attrs: {
              tabindex: "0",
              onkeydown: sliderRef._handleKeyDown.bind(sliderRef),
            },
            children: [
              { classes: { "nom-slider-rail": true } },
              {
                classes: { "nom-slider-track": true },
                _created() {
                  sliderRef._track = this;
                },
                _config() {
                  const offset = sliderRef.getValue();
                  const _offset = offset / sliderRef._max;
                  this.setProps({
                    attrs: { style: { left: 0, width: `${_offset * 100}%` } },
                  });
                },
              },
              {
                classes: { "nom-slider-handle": true },
                _created() {
                  sliderRef._handler = this;
                },
                _config() {
                  const offset = sliderRef.getValue();
                  const _offset = offset / sliderRef._max;
                  const tip = isFalsy(offset) ? 0 : offset.toString();
                  let tooltip = showTip === false ? null : tip;
                  if (showTip && isFunction(showTip)) {
                    tooltip = showTip(tip);
                  }
                  this.setProps({
                    attrs: {
                      title: tooltip,
                      style: { left: `${_offset * 100}%` },
                      onmousedown: (event) => {
                        if (sliderRef.props.disable) return; // 
                        sliderRef._startX = event.clientX;
                        sliderRef._isDragging = true;
                        sliderRef._initEvents();
                        event.preventDefault();
                      },
                    },
                  });
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _initEvents() {
      window.removeEventListener("mousemove", this._handleMouseMove);
      window.removeEventListener("mouseup", this._handleMouseUp);
      window.addEventListener("mousemove", this._handleMouseMove);
      window.addEventListener("mouseup", this._handleMouseUp);
    }
    triggerEdit() {
      return false;
    }
    _remove() {
      window.removeEventListener("mousemove", this._handleMouseMove);
      window.removeEventListener("mouseup", this._handleMouseUp);
    }
    _getValue() {
      return getValidValue(this._offset, this._max);
    }
    _setValue(value) {
      this._newOffset = null;
      const _value = value === null ? 0 : value;
      if (!isNumeric(_value) || _value < 0 || _value > this.props.max) return;
      if (this._handler && _value !== this.oldValue) {
        this._offset = _value;
        this._handler.update();
        this._track.update();
        super._onValueChange();
        this.oldValue = this.currentValue;
        this.currentValue = _value;
      }
    }
    _handleKeyDown(e) {
      const { keyCode } = e;
      const value = this.getValue();
      if (keyCode === 38) {
        if (value <= this.props.max) {
          this.setValue(value + 1);
        }
      } else if (keyCode === 40) {
        if (value >= 0) {
          this.setValue(value - 1);
        }
      }
    }
  }
  Slider.defaults = { disable: false, max: 100 };
  Component.register(Slider);
  class StaticText extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(StaticText.defaults, props), ...mixins);
    }
    _config() {
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: { children: this.props.value },
      });
      super._config();
    }
    _setValue(value) {
      this.update({ value });
    }
    _getValue() {
      return this.props.value;
    }
  }
  StaticText.defaults = { value: null };
  Component.register(StaticText);
  const STATUS = {
    WAIT: "wait",
    PROCESS: "process",
    FINISH: "finish",
    ERROR: "error",
  };
  class Step extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Step.defaults, props), ...mixins);
    }
    _config() {
      // status wait process finish error
      const {
        status,
        title,
        subTitle,
        description,
        onChange,
        index,
        icon: i,
        iconRender,
        simple,
        direction,
      } = this.props;
      let icon;
      if (isFunction(iconRender)) {
        icon = iconRender();
      } else {
        icon = this._handleIcon();
      }
      this.setProps({
        classes: {
          [`nom-step-item-${status}`]: true,
          "nom-step-item-icon-render-mode": isFunction(iconRender),
          "nom-step-simple": simple,
        },
        children: [
          {
            classes: { "nom-step-item-container": true },
            _config() {
              if (onChange) {
                this.setProps({
                  attrs: { role: "button" },
                  onClick: () => {
                    onChange(index);
                  },
                });
              }
            },
            children: [
              { classes: { "nom-step-item-tail": true } },
              {
                classes: {
                  "nom-step-item-icon": true,
                  "nom-step-item-icon-customer": !!i || isFunction(iconRender),
                  "nom-step-item-icon-whole-customer": isFunction(iconRender),
                },
                children: icon,
              },
              {
                classes: { "nom-step-item-content": true },
                renderIf: !simple || direction === "vertical",
                children: [
                  { classes: { "nom-step-item-title": true }, children: title },
                  !simple && {
                    classes: { "nom-step-item-subtitle": true },
                    children: subTitle,
                  },
                  {
                    classes: { "nom-step-item-description": true },
                    children: description,
                  },
                ],
              },
              direction === "horizontal" && {
                classes: { "nom-step-item-line-horizontal": true },
              },
            ],
          },
          simple &&
            direction === "horizontal" && {
              classes: { "nom-step-item-content": true },
              children: [
                { classes: { "nom-step-item-title": true }, children: title },
                {
                  classes: { "nom-step-item-description": true },
                  children: description,
                },
              ],
            },
        ],
      });
      super._config();
    }
    _handleIcon() {
      const { status, icon: i, index, simple } = this.props; // const { WAIT, PROCESS, FINISH, ERROR } = STATUS
      const { FINISH, ERROR } = STATUS;
      if (simple) {
        if (status === FINISH) {
          return {
            classes: {
              "nom-step-icon-mini": true,
              [`nom-step-${status}-icon`]: true,
            },
          };
        }
        if (status === ERROR) {
          return {
            classes: {
              "nom-step-icon-mini": true,
              [`nom-step-${status}-icon`]: true,
            },
          };
        }
        return {
          classes: {
            "nom-step-icon-mini": true,
            [`nom-step-${status}-icon`]: true,
          },
        };
      }
      if (i) {
        return Component.normalizeIconProps(i);
      }
      if (status === FINISH) {
        return {
          component: "Icon",
          type: "check-light",
          classes: { [`nom-step-${status}-icon`]: true },
        };
      }
      if (status === ERROR) {
        return {
          component: "Icon",
          type: "close",
          classes: { [`nom-step-${status}-icon`]: true },
        };
      }
      return {
        tag: "span",
        children: index + 1,
        classes: { [`nom-step-${status}-icon`]: true },
      };
    }
  }
  Step.defaults = {
    disabled: false,
    current: 0, // wait process finish error
    status: "wait",
    iconRender: null,
  };
  class Steps extends Component {
    constructor(props, ...mixins) {
      // active current
      super(Component.extendProps(Steps.defaults, props), ...mixins);
    }
    _config() {
      // const steps = this
      const { direction, current } = this.props;
      this._handleCurrent(current);
      this.setProps({
        tag: "div",
        classes: {
          "nom-steps-horizontal": direction === "horizontal",
          "nom-steps-vertical": direction === "vertical",
          "nom-steps-simple": this.props.simple,
        },
      });
      this.setProps({ children: this._handleChild() });
      super._config();
    }
    _rendered() {
      this.props.simple &&
        this.props.direction === "horizontal" &&
        this._fixPaddingLeft();
    }
    _fixPaddingLeft() {
      const me = this;
      setTimeout(() => {
        const w =
          me.element.querySelector(".nom-step > .nom-step-item-content")
            .offsetWidth / 2;
        this.element.style.paddingLeft = `${parseInt(w, 10) + 14}px`;
      }, 0);
    }
    _handleChild() {
      const { options, onChange, simple, direction } = this.props;
      if (!options || !Array.isArray(options) || options.length === 0)
        return [];
      return options.map((item, index) =>
        Object.assign({ status: this._getStatus(index, this.current) }, item, {
          index,
          simple,
          direction,
          component: Step,
          onChange: isFunction(onChange) ? onChange : undefined,
        })
      );
    }
    _getStatus(index, current) {
      const { WAIT, PROCESS, FINISH } = STATUS;
      if (index === current) return PROCESS;
      return index < current ? FINISH : WAIT;
    }
    _handleCurrent(cur) {
      let current = 0;
      if (isNumeric(cur)) current = parseInt(cur, 10);
      this.current = current;
    }
  }
  Steps.defaults = {
    direction: "horizontal",
    current: 0,
    options: [],
    onChange: null,
    simple: false,
  };
  Component.register(Steps);
  class Switch extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Switch.defaults, props), ...mixins);
    }
    _config() {
      const that = this;
      const { value, unselectedText, selectedText, animate } = this.props;
      this._propStyleClasses = ["size"];
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: {
          tag: "button",
          classes: { "nom-switch-control": true, "nom-switch-active": !!value },
          attrs: {
            onclick: () => {
              if (that.props.disabled) {
                return false;
              }
              that._handleClick();
            },
          },
          children: [
            {
              tag: "input",
              _created() {
                that.ck = this;
              },
              attrs: {
                type: "checkbox",
                hidden: true,
                checked: value,
                onchange() {
                  that._onValueChange();
                  that.update({ value: !value });
                },
              },
            },
            {
              tag: "div",
              classes: {
                "nom-switch-el": true,
                "nom-switch-text": value,
                "nom-switch-indicator": !value,
                "nom-switch-text-left": value && animate,
                "nom-switch-indicator-left": !value && animate,
              },
              children: value ? selectedText : null,
            },
            {
              tag: "div",
              children: value ? null : unselectedText,
              classes: {
                "nom-switch-el": true,
                "nom-switch-text": !value,
                "nom-switch-indicator": value,
                "nom-switch-text-right": !value && animate,
                "nom-switch-indicator-right": value && animate,
              },
            }, // { tag: 'i' },
          ],
        },
      });
      super._config();
    }
    _handleClick() {
      if (this.ck) {
        this.ck.element.click();
      }
    }
    triggerEdit() {
      return false;
    }
    _getValue() {
      return this.ck.element.checked;
    }
    _setValue(value) {
      this.ck.element.checked = value === true;
      this.update({ value });
    }
  }
  Switch.defaults = {
    unselectedText: "",
    selectedText: "",
    value: false,
    size: "small",
  };
  Component.register(Switch);
  class TabPanel extends Component {
    constructor(props, ...mixins) {
      const defaults = { hidden: true };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.tabContent = this.parent;
      this.tabContent.panels[this.key] = this;
    }
    _config() {
      this.setProps({
        hidden: this.key !== this.tabContent.props.selectedPanel,
      });
    }
    _show() {
      if (this.tabContent.shownPanel === this) {
        return;
      }
      this.tabContent.shownPanel && this.tabContent.shownPanel.hide();
      this.tabContent.shownPanel = this;
      this.tabContent.props.selectedPanel = this.key;
    }
  }
  Component.register(TabPanel);
  class TabContent extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(TabContent.defaults, props), ...mixins);
    }
    _created() {
      this.panels = {};
      this.shownPanel = null;
    }
    _config() {
      const { panels } = this.props;
      const children = [];
      if (Array.isArray(panels) && panels.length > 0) {
        for (let i = 0; i < panels.length; i++) {
          let panel = panels[i];
          panel = Component.extendProps({}, this.props.panelDefaults, panel);
          children.push(panel);
        }
      }
      this.setProps({ children: children });
    }
    createPanel(param) {
      this.props.panels.push(param);
      new TabPanel(Object.assign({ reference: this.element }, param));
    }
    getPanel(param) {
      let retPanel = null;
      if (isString(param)) {
        return this.panels[param];
      }
      if (isFunction(param)) {
        for (const panel in this.panels) {
          if (this.panels.hasOwnProperty(panel)) {
            if (param.call(this.panels[panel]) === true) {
              retPanel = this.panels[panel];
              break;
            }
          }
        }
      }
      return retPanel;
    }
    showPanel(param) {
      const panel = this.getPanel(param);
      if (panel === null) {
        return false;
      }
      panel.show();
    }
    removePanel(param) {
      const panel = this.getPanel(param);
      if (panel) {
        panel.remove();
      }
      this.panels[param] && delete this.panels[param];
      this.props.panels = this.props.panels.filter((x) => {
        return x.key !== param;
      });
    }
  }
  TabContent.defaults = { panels: [], panelDefaults: { component: TabPanel } };
  Component.register(TabContent);
  class TabItem extends Component {
    constructor(props, ...mixins) {
      const defaults = {
        tag: "a",
        url: null,
        icon: null,
        text: null,
        subtext: null,
        selectable: { byClick: true },
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.firstShow = true;
    }
    _config() {
      const { icon, text, subtext } = this.props;
      this.setProps({
        attrs: { href: this.getItemUrl(this.props.url) },
        children: [
          icon && { component: "Icon", type: icon },
          text && { tag: "span", children: text },
          subtext && { tag: "span", children: subtext },
        ],
      });
    }
    _select() {
      setTimeout(() => {
        if (this.list.props.tabContent !== false) {
          const tabContent = this.list.getTabContent();
          tabContent.showPanel(this.key);
        }
        !this.list.firstSelect && this.list.triggerChange();
        this.list.firstSelect = false;
      }, 0);
    }
    getItemUrl(url) {
      if (url) {
        return url;
      }
      return "javascript:void(0);";
    }
  }
  Component.register(TabItem);
  class TabList extends List {
    constructor(props, ...mixins) {
      super(Component.extendProps(TabList.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.firstSelect = true;
    }
    _config() {
      this._addPropStyle("direction", "fit");
      this.setProps({ selectedItems: this.props.selectedTab });
      super._config();
    }
    createItem(param) {
      this.appendItem(param);
    }
    getTabContent() {
      return this.props.tabContent.call(this);
    }
    selectTab(param, selectOptions) {
      this.selectItems(param, selectOptions);
    }
    triggerChange() {
      const selectedItem = this.getSelectedItem();
      if (this.props.parentTab) {
        this._callHandler(this.props.parentTab.props.onTabSelectionChange, {
          selectedItem: selectedItem,
          key: selectedItem.key,
        });
      } else {
        this._callHandler(this.props.onTabSelectionChange, {
          selectedItem: selectedItem,
          key: selectedItem.key,
        });
      }
    }
  }
  TabList.defaults = {
    itemDefaults: { component: TabItem },
    tabContent: null,
    uistyle: "plain",
    itemSelectable: { byClick: true, scrollIntoView: false },
    onTabSelectionChange: null,
    disabledItems: [],
  };
  Component.register(TabList);
  class Tabs extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Tabs.defaults, props), ...mixins);
    }
    _config() {
      this._addPropStyle("fit");
      const that = this;
      const tabItems = [];
      const tabPanles = [];
      const { tabs, uistyle, disabledItems } = this.props;
      let { selectedTab } = this.props;
      for (let i = 0; i < tabs.length; i++) {
        const tab = tabs[i];
        const key = tab.key || `tab${i}`;
        tab.item.key = key;
        tab.panel.key = key;
        tabItems.push(tab.item);
        tabPanles.push(tab.panel);
      }
      if (selectedTab === undefined) {
        selectedTab = tabItems[0] && tabItems[0].key;
      }
      this.setProps({
        tabList: {
          component: TabList,
          name: "tabList",
          items: tabItems,
          uistyle: uistyle,
          selectedTab: selectedTab,
          disabledItems: disabledItems,
          _created: function () {
            this.tabs = that;
            that.tabList = this;
          },
          tabContent: function () {
            return that.tabContent;
          },
          parentTab: this,
        },
        tabContent: {
          component: TabContent,
          panels: tabPanles,
          _created: function () {
            that.tabContent = this;
          },
        },
      });
      if (this.props.tools) {
        this.setProps({
          children: [
            {
              component: "Cols",
              fit: true,
              strechIndex: 0,
              gutter: "xs",
              items: [
                this.props.tabList,
                this.props.tools
                  ? {
                      classes: { "nom-tabs-tools": true },
                      children: isFunction(this.props.tools)
                        ? this.props.tools()
                        : this.props.tools,
                    }
                  : null,
              ],
            },
            this.props.tabContent,
          ],
        });
      } else {
        this.setProps({
          children: [this.props.tabList, this.props.tabContent],
        });
      }
    }
    getSelectedTab() {
      return this.tabList.getSelectedItem();
    }
    selectTab(key) {
      return this.tabList.selectItem(key);
    }
    createTab(param) {
      this.props.tabs.push(param);
      const { key, item, panel } = param;
      this.tabList.createItem(Object.assign({ key }, item));
      this.tabContent.createPanel(Object.assign({ key }, panel));
    }
    removeTab(key) {
      if (!this.tabList.getItem(key)) {
        console.warn(`The specified object was not found.`);
        return;
      }
      if (this.getSelectedTab().key === key) {
        const newKey = this._getTabSibling(key);
        newKey && this.selectTab(newKey);
      }
      const item = this.tabList.getItem(key);
      const panel = this.tabContent.getPanel(key);
      this.props.onTabRemove &&
        this._callHandler(this.props.onTabRemove, { item, panel });
      this.tabList.removeItem(key);
      this.tabContent.removePanel(key);
      this.props.tabs = this.props.tabs.filter((x) => {
        return x.key !== key;
      });
    }
    _getTabSibling(key) {
      const { tabs } = this.props;
      const idx = tabs.findIndex((x) => {
        return x.key === key;
      });
      if (idx > 0) {
        return tabs[idx - 1].key;
      }
      if (tabs[idx + 1]) {
        return tabs[idx + 1].key;
      }
      return false;
    }
    updatePanel(key, newPanelProps) {
      const panel = this.tabContent.getPanel(key);
      panel.update(newPanelProps);
    }
  }
  Tabs.defaults = {
    tabs: [], // selectedTab: 'tab0',
    uistyle: "plain", // hat,card,line,pill
    onTabSelectionChange: null,
    disabledItems: [],
    tools: null,
    onTabRemove: null,
  };
  Component.register(Tabs);
  class Tag extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Tag.defaults, props), ...mixins);
    }
    _config() {
      this._propStyleClasses = ["size", "color"];
      const {
        icon,
        rightIcon,
        text,
        type,
        overflowCount,
        removable,
      } = this.props;
      const number = this.props.number;
      const that = this;
      if (icon || rightIcon) {
        this.setProps({ classes: { "p-with-icon": true } });
      }
      if (type === "round") {
        this.setProps({ classes: { "u-shape-round": true } });
      }
      if (this.props.color && this._isValidColor(this.props.color)) {
        this.setProps({
          attrs: {
            style: {
              backgroundColor: this.props.color,
              borderColor: this.props.borderColor || this.props.color,
              color: this.props.textColor || "#fff",
            },
          },
        });
      }
      this.setProps({
        classes: {
          "nom-tag-pointer": !!this.props.onClick || this.props.removable,
        },
        children: {
          component: "Flex",
          align: "center",
          cols: [
            Component.normalizeIconProps(icon),
            {
              children: {
                classes: { "nom-tag-content": true },
                children: text,
                attrs: {
                  style: {
                    maxWidth: this.props.maxWidth
                      ? `${this.props.maxWidth}px`
                      : null,
                  },
                },
              },
            },
            (number || number === 0) && {
              tag: "span",
              children: number > overflowCount ? `${overflowCount}+` : number,
            },
            Component.normalizeIconProps(rightIcon),
            removable &&
              Component.normalizeIconProps({
                type: "times",
                classes: {
                  "nom-tag-remove": true,
                  "nom-tag-remove-basic": !that.props.styles,
                },
                onClick: function ({ event }) {
                  nomui.utils.isFunction(that.props.removable) &&
                    that.props.removable(that.props.key);
                  that.hasOwnProperty("props") &&
                    that.props.onRemove &&
                    that._callHandler(that.props.onRemove, {
                      key: that.props.key,
                    });
                  event.stopPropagation();
                },
              }),
          ],
        },
      });
    }
    _isValidColor(str) {
      const re = /^#([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i;
      return re.test(str);
    }
    _disable() {
      this.element.setAttribute("disabled", "disabled");
    }
  }
  Tag.defaults = {
    key: null,
    tag: "span",
    type: "square",
    color: null,
    text: null,
    icon: null,
    number: null,
    overflowCount: 99,
    removable: false,
    size: "sm",
    maxWidth: null,
  };
  Component.register(Tag);
  class TimelineItem extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(TimelineItem.defaults, props), ...mixins);
    }
    _config() {
      const { dot, color, label, pending, children } = this.props;
      this.setProps({
        classes: {
          "nom-timeline-item": true,
          "nom-timeline-item-pending": pending,
        },
        children: [
          label && {
            tag: "div",
            classes: { "nom-timeline-item-label": true },
            children: label,
          },
          { tag: "div", classes: { "nom-timeline-item-tail": true } },
          {
            tag: "div",
            classes: {
              "nom-timeline-item-head": true,
              "nom-timeline-item-head-custom": !!dot,
              [`nom-timeline-item-head-${color}`]: true,
            },
            attrs: {
              style: {
                "border-color": /blue|red|green|gray/.test(color || "")
                  ? undefined
                  : color,
              },
            },
            children: [dot],
          },
          {
            tag: "div",
            classes: { "nom-timeline-item-content": true },
            children,
          },
        ],
      });
    }
  }
  TimelineItem.defaults = {
    tag: "li",
    color: "blue", //  blue, red, green, gray
    dot: null, // 
    label: null, // 
    pending: false, // 
    children: null, // 
  };
  Component.register(TimelineItem);
  class Timeline extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Timeline.defaults, props), ...mixins);
    }
    _getPositionClass(ele, index) {
      const { mode } = this.props;
      if (mode === "alternate") {
        return index % 2 === 0
          ? `nom-timeline-item-left`
          : `nom-timeline-item-right`;
      }
      if (mode === "left") {
        return `nom-timeline-item-left`;
      }
      if (mode === "right") {
        return `nom-timeline-item-right`;
      }
      if (ele.props && ele.props.position === "right") {
        return `nom-timeline-item-right`;
      }
      return "";
    }
    _config() {
      const { reverse, pending, mode, pendingDot, items } = this.props;
      const that = this;
      const hasLabelItem = items && items.some((item) => item && item.label); // pending
      const pendingItem = pending
        ? {
            component: TimelineItem,
            pending: !!pending,
            dot: pendingDot || { component: "Icon", type: "loading" },
            children: typeof pending === "boolean" ? null : pending,
          }
        : null; // position
      const children = [];
      if (Array.isArray(items) && items.length > 0) {
        const timeLineItems = [...items];
        if (pendingItem) {
          timeLineItems.push(pendingItem);
        }
        if (reverse) {
          timeLineItems.reverse();
        }
        const itemsCount = timeLineItems.length;
        const lastCls = "nom-timeline-item-last";
        for (let i = 0; i < timeLineItems.length; i++) {
          const ele = timeLineItems[i];
          const positionCls = that._getPositionClass(ele, i);
          const pendingClass = i === itemsCount - 2 ? lastCls : "";
          const readyClass = i === itemsCount - 1 ? lastCls : "";
          children.push(
            Object.assign({ component: TimelineItem }, ele, {
              classes: Object.assign({}, ele.classes, {
                [!reverse && !!pending ? pendingClass : readyClass]: true,
                [positionCls]: true,
              }),
            })
          );
        }
      }
      this.setProps({
        classes: {
          [`nom-timeline-pending`]: !!pending,
          [`nom-timeline-reverse`]: !!reverse,
          [`nom-timeline-${mode}`]: !!mode && !hasLabelItem,
          [`nom-timeline-label`]: hasLabelItem,
        },
        children,
      });
    }
  }
  Timeline.defaults = {
    tag: "ul",
    mode: "left", //  mode  left | alternate | right
    pending: false, // ,
    // 
    pendingDot: { component: "Icon", type: "loading" },
    reverse: false, // 
    items: null, // 
  };
  Component.register(Timeline);
  class TimePickerList extends List {
    constructor(props, ...mixins) {
      const defaults = {
        gutter: "xs",
        cols: 1,
        min: "00",
        max: "59",
        scrollIntoView: false,
      };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.scroller = this.parent;
      this.timeWrapper = this.parent.parent.parent.parent.parent;
      this.pickerControl = this.timeWrapper.parentPopup.pickerControl;
      this.pickerControl.timeList[this.props.type] = this;
    }
    _config() {
      let items = [];
      const that = this;
      const { _isHourOverRange, _isMinuteOverRange } = this.pickerControl;
      const { type } = this.props;
      this.props.min = this.pickerControl.timeRange[this.props.type][0];
      this.props.max = this.pickerControl.timeRange[this.props.type][1];
      if (type === "hour") {
        items = this.pickerControl.getHour();
      } else if (type === "minute") {
        items = this.pickerControl.getMinute();
      } else if (type === "second") {
        items = this.pickerControl.getSecond();
      }
      this.setProps({
        items: items,
        itemSelectable: {
          multiple: false,
          byClick: true,
          scrollIntoView: { block: "center", scrollMode: "always" },
        },
        itemDefaults: {
          _config: function () {
            const key = this.props.key; // hour:  minutesecond || minute:  second
            const disabledOverRange =
              (type !== "hour" && _isHourOverRange) ||
              (type === "second" && _isMinuteOverRange);
            this.setProps({
              disabled:
                key < that.props.min ||
                key > that.props.max ||
                disabledOverRange,
            });
          },
        },
        onItemSelectionChange: () => {
          this.onChange();
        },
      });
      super._config();
    }
    onChange() {
      this.setTime();
    }
    setTime() {
      const key = this.getSelectedItem().key || "00";
      this.pickerControl.setTime({ type: this.props.type, value: key });
    }
    resetTime() {
      const _val = this.pickerControl.getValue();
      if (_val) {
        const t = _val.split(":");
        if (this.props.type === "hour") {
          this.selectItem(t[0], { triggerSelectionChange: false });
        } else if (this.props.type === "minute") {
          this.selectItem(t[1], { triggerSelectionChange: false });
        } else {
          this.selectItem(t[2], { triggerSelectionChange: false });
        }
      } else {
        this.unselectAllItems();
      }
    }
    refresh() {
      this.update();
    }
  }
  class TimePickerWrapper extends Component {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      this.parentPopup = this.parent.parent.parent;
      this.pickerControl = this.parentPopup.pickerControl;
    }
    _config() {
      const that = this;
      const noStep =
        !that.pickerControl.props.hourStep &&
        !that.pickerControl.props.minuteStep &&
        !that.pickerControl.props.secondStep;
      const nowInRange =
        (!(
          that.pickerControl.props.minTime &&
          that.pickerControl.props.minTime >
            new Date().format(that.pickerControl.props.format)
        ) &&
          !(
            that.pickerControl.props.maxTime &&
            that.pickerControl.props.maxTime <
              new Date().format(that.pickerControl.props.format)
          )) ||
        (!that.pickerControl.props.minTime &&
          !that.pickerControl.props.maxTime);
      this.setProps({
        children: {
          component: "Rows",
          gutter: null,
          items: [
            {
              component: "Cols",
              gutter: null,
              classes: { "timepicker-group": true },
              fills: true,
              align: "stretch",
              children: [
                {
                  hidden: !this.pickerControl.props.format.includes("HH"),
                  children: { component: TimePickerList, type: "hour" },
                },
                {
                  hidden: !this.pickerControl.props.format.includes("mm"),
                  children: { component: TimePickerList, type: "minute" },
                },
                {
                  hidden: !this.pickerControl.props.format.includes("ss"),
                  children: { component: TimePickerList, type: "second" },
                },
              ],
            },
            {
              component: "Cols",
              justify: "between",
              hidden: !that.pickerControl.defaultValue && !noStep,
              attrs: {
                style: { padding: "5px", "border-top": "1px solid #ddd" },
              },
              items: [
                noStep && {
                  component: "Button",
                  size: "small",
                  text: that.pickerControl.props.nowText,
                  disabled: !nowInRange,
                  onClick: function () {
                    that.pickerControl.setNow();
                    that.pickerControl.popup.hide();
                    that.pickerControl.handleChange();
                  },
                },
                that.pickerControl.props.defaultValue && {
                  component: "Button",
                  size: "small",
                  text: that.pickerControl.props.resetText,
                  onClick: function () {
                    that.pickerControl.popup.hide();
                    that.pickerControl.handleChange();
                    that.pickerControl.defaultValue =
                      that.pickerControl.props.defaultValue;
                  },
                },
              ],
            },
          ],
        },
      });
    }
  }
  Component.register(TimePickerWrapper);
  class TimePickerPopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = {};
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.pickerControl = this.opener.parent.parent;
    }
    _config() {
      this.setProps({
        children: {
          component: Layout,
          body: { children: { component: TimePickerWrapper } },
        },
      });
      super._config();
    }
  }
  Component.register(TimePickerPopup);
  class TimePicker extends Textbox {
    constructor(props, ...mixins) {
      super(Component.extendProps(TimePicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.defaultValue = this.props.value;
      this.timeList = []; // this.confirm = false
      this.empty = !this.props.value;
      this.minTime = { hour: "00", minute: "00", second: "00" };
      this.maxTime = { hour: "23", minute: "59", second: "59" };
      this.time = { hour: "00", minute: "00", second: "00" };
      if (this.props.value) {
        const t = this.props.value.split(":");
        this.time.hour = t[0] || "00";
        this.time.minute = t[1] || "00";
        this.time.second = t[2] || "00";
      }
      this.defaultTime = this.time;
      this.hasPopup = false;
    }
    _config() {
      if (this.props.minTime) {
        const time = new Date(`2000 ${this.props.minTime}`);
        this.minTime = {
          hour: this.getDoubleDigit(time.getHours()),
          minute: this.getDoubleDigit(time.getMinutes()),
          second: this.getDoubleDigit(time.getSeconds()),
        };
      }
      if (this.props.maxTime) {
        const time = new Date(`2000 ${this.props.maxTime}`);
        this.maxTime = {
          hour: this.getDoubleDigit(time.getHours()),
          minute: this.getDoubleDigit(time.getMinutes()),
          second: this.getDoubleDigit(time.getSeconds()),
        };
      }
      this.timeRange = {
        hour: [this.minTime.hour, this.maxTime.hour],
        minute: ["00", "59"],
        second: ["00", "59"],
      };
      this._calcTimeRangeByTime();
      this.setProps({
        leftIcon: "clock",
        clearProps: {
          component: "Icon",
          type: "times",
          classes: { "nom-field-clear-handler": true },
          hidden: !this.props.allowClear || this.props.disabled,
          onClick: (args) => {
            if (this.props.disabled) return false;
            this.clearTime();
            args.event && args.event.stopPropagation();
          },
        },
      });
      super._config();
    }
    _rendered() {
      const that = this;
      this.popup = new TimePickerPopup({
        trigger: this.control,
        onHide: () => {
          that.getValue() !== that.defaultValue && that.handleChange();
        },
        onShow: () => {
          this.defaultValue = this.props.value;
          this.resetList();
        },
      });
    }
    getHour() {
      const hour = [];
      if (this.props.hourStep) {
        hour.push({ key: "00", children: "00" });
        for (let i = 0; i < 24; i++) {
          if ((i + 1) % this.props.hourStep === 0 && i !== 23) {
            hour.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return hour;
      }
      for (let i = 0; i < 24; i++) {
        hour.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return hour;
    }
    getMinute() {
      const minute = [];
      if (this.props.minuteStep) {
        minute.push({ key: "00", children: "00" });
        for (let i = 0; i < 60; i++) {
          if ((i + 1) % this.props.minuteStep === 0 && i !== 59) {
            minute.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return minute;
      }
      for (let i = 0; i < 60; i++) {
        minute.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return minute;
    }
    getSecond() {
      const second = [];
      if (this.props.secondStep) {
        second.push({ key: "00", children: "00" });
        for (let i = 0; i < 60; i++) {
          if ((i + 1) % this.props.secondStep === 0 && i !== 59) {
            second.push({
              key: this.getDoubleDigit(i + 1),
              children: this.getDoubleDigit(i + 1),
            });
          }
        }
        return second;
      }
      for (let i = 0; i < 60; i++) {
        second.push({
          key: this.getDoubleDigit(i),
          children: this.getDoubleDigit(i),
        });
      }
      return second;
    }
    setTime(data) {
      this.time[data.type] = data.value;
      if (this.time.hour <= this.minTime.hour) {
        this.time.hour = this.minTime.hour;
        if (this.time.minute <= this.minTime.minute) {
          this.time.minute = this.minTime.minute;
        }
        if (this.time.minute <= this.minTime.minute) {
          if (this.time.second <= this.minTime.second) {
            this.time.second = this.minTime.second;
          }
        }
      }
      if (this.time.hour >= this.maxTime.hour) {
        this.time.hour = this.maxTime.hour;
        if (this.time.minute >= this.maxTime.minute) {
          this.time.minute = this.maxTime.minute;
        }
        if (this.time.minute >= this.maxTime.minute) {
          if (this.time.second >= this.maxTime.second) {
            this.time.second = this.maxTime.second;
          }
        }
      }
      this.checkTimeRange();
      const result = new Date(
        "2000",
        "01",
        "01",
        this.time.hour,
        this.time.minute,
        this.time.second
      ).format(this.props.format);
      this.setValue(result);
      this.resetList();
    }
    clearTime() {
      this.setValue(null);
      this.empty = true;
      this.time = { hour: "00", minute: "00", second: "00" };
      this.resetList();
      this.popup.hide();
    }
    setNow() {
      const c = new Date().format("HH:mm:ss");
      const t = c.split(":");
      this.time.hour = t[0];
      this.time.minute = t[1];
      this.time.second = t[2];
      this.checkTimeRange();
      this.setValue(c.format(this.props.format));
      this.empty = false;
      this.resetList();
      this.popup.hide();
    }
    resetList() {
      const that = this;
      Object.keys(this.timeList).forEach(function (key) {
        that.timeList[key].resetTime();
      });
    }
    handleChange() {
      this.props.onChange && this._callHandler(this.props.onChange);
    }
    _onBlur() {
      if (
        this.getValue() &&
        !Date.isValid(this.getValue(), this.props.format)
      ) {
        this.clearTime();
      }
      super._onBlur();
    }
    showPopup() {
      this.popup.show();
    }
    getDoubleDigit(num) {
      if (num < 10) {
        return `0${num}`;
      }
      return `${num}`;
    }
    checkTimeRange() {
      const that = this;
      const beforeHourFlag = this._isHourOverRange;
      const beforeMinuteFlag = this._isMinuteOverRange;
      const { hour, minute, second } = this.timeRange;
      const beforeTimeRangeStr = `${hour}-${minute}-${second}`;
      this._calcTimeRangeByTime();
      this.empty = false;
      const { hour: aHour, minute: aMinute, second: aSecond } = this.timeRange;
      const afterTimeRangeStr = `${aHour}-${aMinute}-${aSecond}`;
      let needRefreshList = []; // timeRange , list
      if (afterTimeRangeStr !== beforeTimeRangeStr) {
        needRefreshList = ["hour", "minute", "second"];
      } else if (beforeHourFlag !== this._isHourOverRange) {
        // hourOverRange
        needRefreshList = ["minute", "second"];
      } else if (beforeMinuteFlag !== this._isMinuteOverRange) {
        // minuteOverRange, 
        needRefreshList = ["second"];
      }
      needRefreshList.forEach(function (key) {
        that.timeList[key].refresh();
      });
    } // timeRange  overRange
    _calcTimeRangeByTime() {
      const { time, timeRange, minTime, maxTime } = this;
      this._isHourOverRange =
        time.hour < minTime.hour || time.hour > maxTime.hour;
      this._isMinuteOverRange =
        (time.hour === minTime.hour && time.minute < minTime.minute) ||
        (time.hour === maxTime.hour && time.minute > maxTime.minute);
      if (time.hour <= minTime.hour) {
        timeRange.hour = [minTime.hour, maxTime.hour];
        timeRange.minute = [minTime.minute, "59"];
        if (time.minute <= minTime.minute) {
          timeRange.second = [minTime.second, "59"];
        } else {
          timeRange.second = ["00", "59"];
        }
      } else if (time.hour >= maxTime.hour) {
        timeRange.minute = ["00", maxTime.minute];
        if (time.minute >= maxTime.minute) {
          timeRange.second = ["00", maxTime.second];
        } else {
          timeRange.second = ["00", "59"];
        }
      } else {
        timeRange.minute = timeRange.second = ["00", "59"];
      }
    }
  }
  TimePicker.defaults = {
    allowClear: true,
    value: null,
    format: "HH:mm:ss",
    hourStep: null,
    minuteStep: null,
    secondStep: null,
    readonly: false,
    restrictInput: true,
    placeholder: null,
    showNow: true,
    minTime: null,
    maxTime: null,
    nowText: "",
    resetText: "",
  };
  Component.register(TimePicker);
  class TimeRangePicker extends Group {
    constructor(props, ...mixins) {
      super(Component.extendProps(TimeRangePicker.defaults, props), ...mixins);
    }
    _created() {
      super._created();
    }
    _config() {
      const that = this;
      const {
        format,
        hourStep,
        minuteStep,
        secondStep,
        allowClear,
        minTime,
        maxTime,
        required,
        requiredMessage,
        rules,
        startPickerProps,
        endPickerProps,
        disabled,
      } = this.props;
      this.setProps({
        inline: true,
        fields: [
          Object.assign(
            {
              component: "TimePicker",
              name: that.props.fieldName.start,
              ref: (c) => {
                that.startPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              format,
              hourStep,
              minuteStep,
              secondStep,
              allowClear,
              disabled,
              minTime,
              maxTime,
              required,
              requiredMessage,
              rules,
            },
            startPickerProps
          ),
          { component: "StaticText", value: "-" },
          Object.assign(
            {
              component: "TimePicker",
              name: that.props.fieldName.end,
              ref: (c) => {
                that.endPicker = c;
              },
              onChange: function (args) {
                that.checkRange(args.sender.name);
              },
              format,
              hourStep,
              minuteStep,
              secondStep,
              allowClear,
              disabled,
              minTime,
              maxTime,
              required,
              requiredMessage,
              rules,
            },
            endPickerProps
          ),
        ],
      });
      super._config();
    }
    _getValueText() {
      const val = this.getValue();
      return `${
        val[this.props.fieldName.start]
      } - ${val[this.props.fieldName.end]}`;
    }
    handleChange() {
      this.props.onChange && this._callHandler(this.props.onChange);
    }
    triggerEdit() {
      this.startPicker.triggerEdit();
    }
    checkRange(type) {
      const that = this;
      const active =
        type === this.props.fieldName.start ? this.startPicker : this.endPicker;
      const opposite =
        type === this.props.fieldName.start ? this.endPicker : this.startPicker;
      if (active.getValue()) {
        if (active.name === that.props.fieldName.start) {
          opposite.update({ minTime: active.getValue() });
          if (opposite.getValue() && opposite.getValue() < active.getValue()) {
            opposite.clearTime();
            opposite.focus();
            opposite.showPopup();
          } else if (!opposite.getValue()) {
            opposite.focus();
            that.props.autoPopupEnd && opposite.showPopup();
          }
        } else if (
          opposite.getValue() &&
          opposite.getValue() > active.getValue()
        ) {
          opposite.clearTime();
        }
      }
      if (active.getValue() && opposite.getValue()) {
        that.handleChange();
      }
    }
  }
  TimeRangePicker.defaults = {
    allowClear: true,
    value: null,
    format: "HH:mm:ss",
    hourStep: 0,
    minuteStep: 0,
    secondStep: 0,
    readonly: false,
    placeholder: null,
    autoPopupEnd: true,
    showNow: true,
    onChange: null,
    fieldName: { start: "start", end: "end" },
    flatValue: true,
    startPickerProps: { placeholder: "" },
    endPickerProps: { placeholder: "" },
  };
  Component.register(TimeRangePicker);
  class Tour extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Tour.defaults, props), ...mixins);
    }
    _created() {
      this.total = 0;
    }
    _config() {
      const { steps } = this.props;
      if (steps.length) {
        this.total = steps.length;
        this._createStep(1);
      }
    }
    _createStep(index) {
      const {
        padding,
        steps,
        allowSkip,
        scrollIntoView,
        showPagination,
      } = this.props;
      let { current } = this.props;
      const item = steps[index - 1];
      const { target, align = "top", render } = item;
      current = index;
      let ele = isFunction(target) ? target() : target;
      if (ele.element) {
        ele = ele.element;
      }
      let info = ele.getBoundingClientRect();
      if (scrollIntoView) {
        if (
          info.top < 0 ||
          info.left < 0 ||
          info.bottom >
            (window.innerHeight || document.documentElement.clientHeight) ||
          info.right >
            (window.innerWidth || document.documentElement.clientWidth)
        ) {
          ele.scrollIntoView();
          info = ele.getBoundingClientRect();
        }
      }
      this.backdrop = new nomui.Layer({
        classes: { "nom-tour-backdrop": true },
        attrs: {
          style: {
            top: `${info.top - padding}px`,
            left: `${info.left - padding}px`,
            width: `${info.width + padding * 2}px`,
            height: `${info.height + padding * 2}px`,
          },
        },
      });
      this.mask = new nomui.Layer({ classes: { "nom-tour-mask": true } });
      const str = this.props.pageInfoText
        .replace("{{current}}", current)
        .replace("{{total}}", this.total);
      this.stepLayer = new nomui.Layer({
        alignOuter: true,
        align: align,
        alignTo: ele,
        classes: { "nom-tour-container": true },
        attrs: { placement: align },
        children: [
          isFunction(render) ? render() : this._renderContent(item),
          {
            classes: { "nom-tour-close": true },
            hidden: !allowSkip,
            component: "Icon",
            type: "times",
            onClick: () => {
              this._destroyStep();
              this.props.onClose &&
                this._callHandler(this.props.onClose, { current: current });
            },
          },
          {
            component: "Flex",
            classes: { "nom-tour-navi": true },
            align: "center",
            cols: [
              {
                grow: true,
                children: {
                  classes: { "nom-tour-navi-text": true },
                  hidden: !showPagination,
                  children: str,
                },
              },
              {
                component: "Button",
                size: "small",
                hidden: current === 1 || this.total === 1,
                text: this.props.prevText,
                onClick: () => {
                  this._destroyStep();
                  this._createStep(current - 1);
                },
              },
              {
                component: "Button",
                size: "small",
                hidden: current === this.total || this.total === 1,
                text: this.props.nextText,
                onClick: () => {
                  this._destroyStep();
                  this._createStep(current + 1);
                },
              },
              {
                component: "Button",
                size: "small",
                hidden: current !== this.total && this.total !== 1,
                text: this.props.finishText,
                type: "primary",
                onClick: () => {
                  this._destroyStep();
                  this.props.onFinish &&
                    this._callHandler(this.props.onFinish, { current });
                },
              },
            ],
          },
          {
            classes: { "nom-tour-arrow": true },
            children: `#<svg aria-hidden="true" width="24" height="6" viewBox="0 0 24 7" fill="currentColor" xmlns="http://www.w3.org/2000/svg" ><path d="M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z"></path></svg>`,
          },
        ],
      });
      this.props.onChange &&
        this._callHandler(this.props.onChange, { current });
    }
    _destroyStep() {
      this.stepLayer.remove();
      this.mask.remove();
      this.backdrop.remove();
    }
    _renderContent(item) {
      const { title, description } = item;
      return {
        component: "Flex",
        rows: [
          { classes: { "nom-tour-title": true }, children: title },
          { classes: { "nom-tour-description": true }, children: description },
        ],
      };
    }
  }
  Tour.defaults = {
    padding: 2,
    steps: [],
    allowSkip: true,
    onClose: null,
    onChange: null,
    onFinish: null,
    current: 1,
    scrollIntoView: true,
    showPagination: true,
    prevText: "",
    nextText: "",
    finishText: "",
    pageInfoText: "{{current}} / {{total}}",
  };
  Component.register(Tour);
  class Transfer extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Transfer.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.selectedKeys = [];
      this.selectData = [];
    }
    _config() {
      const me = this;
      const { data, dataFields, value, showSearch } = this.props;
      let initKeys = [];
      if (this.props.value) {
        if (isString(value)) {
          initKeys = [value];
        } else {
          initKeys = value;
        }
      }
      this.setProps({
        // RadioList,CheckboxListdiv focusable 
        //  tabindex fouces Tooltip
        attrs: { tabindex: this.props.tabindex || 0 },
        control: {
          children: {
            component: "Flex",
            classes: { "nom-transfer-container": true },
            align: "center",
            gutter: "medium",
            cols: [
              {
                children: {
                  component: "Layout",
                  classes: { "nom-transfer-box": true },
                  attrs: {
                    style: {
                      height: isString(me.props.height)
                        ? me.props.height
                        : `${me.props.height}px`,
                    },
                  },
                  header: {
                    children: {
                      component: "Flex",
                      align: "center",
                      fit: true,
                      cols: [
                        {
                          grow: true,
                          children: {
                            component: "Button",
                            text: me.props.selectAllText,
                            size: "small",
                            ref: (c) => {
                              me.checkAllBtn = c;
                            },
                            type: "text",
                            onClick: ({ sender }) => {
                              if (me.props.disabled) {
                                return;
                              }
                              if (
                                sender.props.text === me.props.selectAllText
                              ) {
                                sender.update({
                                  text: me.props.deselectAllText,
                                });
                                me.checkAll();
                              } else {
                                sender.update({ text: me.props.selectAllText });
                                me.uncheckAll();
                              }
                            },
                          },
                        },
                        {
                          ref: (c) => {
                            me.sourceCount = c;
                          },
                          children: "",
                        },
                      ],
                    },
                  },
                  body: {
                    children: {
                      component: "Layout",
                      header: showSearch
                        ? {
                            _created: function () {
                              me.sourceSearchContainer = this;
                            },
                            children: {
                              component: "Textbox",
                              allowClear: false,
                              _created: function () {
                                me.sourceSearch = this;
                              },
                              onValueChange: debounce(({ newValue }) => {
                                me._onSourceSearch(newValue);
                              }, 1000),
                            },
                          }
                        : false,
                      body: {
                        children: {
                          component: "Tree",
                          _created: function () {
                            me.sourceTree = this;
                          },
                          data: data,
                          dataFields: dataFields,
                          nodeSelectable: false,
                          disabled: me.props.disabled,
                          expandable: { byIndicator: true },
                          nodeCheckable: {
                            cascade: me.props.displayAsTree,
                            checkedNodeKeys: initKeys,
                            onCheckChange: () => {
                              me._updateSourceCount();
                            },
                          },
                          nodeDefaults: {
                            onClick: ({ sender, event }) => {
                              if (
                                me.props.disabled ||
                                sender.checkboxRef.props.disabled
                              ) {
                                return;
                              }
                              if (sender.props.checked) {
                                sender.uncheck();
                              } else {
                                sender.check();
                              }
                              event.stopPropagation();
                            },
                          },
                        },
                      },
                    },
                  },
                  footer:
                    this.props.pagination || this.props.footerRender
                      ? {
                          children: this.props.footerRender
                            ? this.props.footerRender()
                            : {
                                component: "Flex",
                                fit: true,
                                align: "center",
                                justify: "end",
                                cols: [
                                  {
                                    children: {
                                      component: "Pager",
                                      itemsSort: ["pages"],
                                      totalCount: 50,
                                      simple: true,
                                      pageIndex: 1,
                                      pageSize: 20,
                                    },
                                  },
                                ],
                              },
                        }
                      : false,
                },
              },
              {
                gutter: "small",
                rows: [
                  {
                    component: "Button",
                    size: "small",
                    icon: "right",
                    ref: (c) => {
                      me.addTrigger = c;
                    },
                    onClick: () => {
                      if (me.props.disabled) {
                        return;
                      }
                      me.addNodes();
                    },
                  },
                  {
                    component: "Button",
                    size: "small",
                    icon: "left",
                    ref: (c) => {
                      me.removeTrigger = c;
                    },
                    onClick: () => {
                      if (me.props.disabled) {
                        return;
                      }
                      me.removeNodes();
                    },
                  },
                ],
              },
              {
                children: {
                  component: "Layout",
                  classes: { "nom-transfer-box": true },
                  attrs: {
                    style: {
                      height: isString(me.props.height)
                        ? me.props.height
                        : `${me.props.height}px`,
                    },
                  },
                  header: {
                    children: {
                      component: "Flex",
                      align: "center",
                      fit: true,
                      cols: [
                        {
                          grow: true,
                          children: {
                            component: "Button",
                            text: me.props.clearText,
                            size: "small",
                            type: "text",
                            onClick: () => {
                              if (me.props.disabled) {
                                return;
                              }
                              me.clear();
                            },
                          },
                        },
                        {
                          ref: (c) => {
                            me.targetCount = c;
                          },
                          children: "",
                        },
                      ],
                    },
                  },
                  body: {
                    children: {
                      component: "Layout",
                      header: showSearch
                        ? {
                            _created: function () {
                              me.targetSearchContainer = this;
                            },
                            children: {
                              component: "Textbox",
                              allowClear: false,
                              _created: function () {
                                me.targetSearch = this;
                              },
                              onValueChange: debounce(({ newValue }) => {
                                me._onTargetSearch(newValue);
                              }, 1000),
                            },
                          }
                        : false,
                      body: {
                        children: {
                          component: "Tree",
                          _created: function () {
                            me.targetTree = this;
                          },
                          data: [],
                          disabled: me.props.disabled,
                          flatData: me.props.displayAsTree,
                          dataFields: Object.assign({}, dataFields, {
                            children: "noChildrenAllowed",
                          }),
                          nodeSelectable: false,
                          sortable: true,
                          expandable: { byIndicator: true },
                          nodeCheckable: {
                            cascade: me.props.displayAsTree,
                            onCheckChange: () => {
                              me._updateTargetCount();
                            },
                          },
                          nodeDefaults: {
                            onClick: ({ sender }) => {
                              if (
                                me.props.disabled ||
                                sender.checkboxRef.props.disabled
                              ) {
                                return;
                              }
                              if (sender.props.checked) {
                                sender.uncheck();
                              } else {
                                sender.check();
                              }
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            ],
          },
        },
      });
      super._config();
    }
    _rendered() {
      if (this.firstRender || this._refreshFlag) {
        this._updateCountNum();
        this.addNodes();
        this._refreshFlag = false;
      }
    }
    _getCheckedChildNodeKeys(nodes, ignoreCheck) {
      const checkedNodes = [];
      nodes.forEach((node) => {
        if (ignoreCheck || node.isChecked()) {
          checkedNodes.push(node.key);
        }
        if (node.getChildNodes().length) {
          Array.prototype.push.apply(
            checkedNodes,
            this._getCheckedChildNodeKeys(node.getChildNodes(), ignoreCheck)
          );
        }
      });
      return checkedNodes;
    }
    _showParent(node) {
      const p = node.parentNode.parentNode;
      if (p.classList.contains("nom-tree-node")) {
        p.classList.remove("s-hidden");
        this._showParent(p);
      }
    }
    _onSourceSearch(val) {
      this.sourceTree.element
        .querySelectorAll(".nom-tree-node")
        .forEach((n) => {
          if (
            !val ||
            n
              .querySelector(".nom-tree-node-content-text")
              .innerHTML.includes(val)
          ) {
            n.classList.remove("s-hidden");
            this._showParent(n);
          } else {
            n.classList.add("s-hidden");
          }
        });
    }
    _onTargetSearch(val) {
      this.targetTree.element
        .querySelectorAll(".nom-tree-node")
        .forEach((n) => {
          if (
            !val ||
            n
              .querySelector(".nom-tree-node-content-text")
              .innerHTML.includes(val)
          ) {
            n.classList.remove("s-hidden");
            this._showParent(n);
          } else {
            n.classList.add("s-hidden");
          }
        });
    }
    _updateCountNum() {
      this._updateSourceCount();
      this._updateTargetCount();
    }
    _updateSourceCount() {
      if (
        this.sourceTree.element.querySelectorAll("input:checked:enabled").length
      ) {
        this.addTrigger.update({ type: "primary" });
      } else {
        this.addTrigger.update({ type: null });
      }
      const u = this.sourceTree.getCheckedNodeKeys().length;
      const d = this._getCheckedChildNodeKeys(
        this.sourceTree.getChildNodes(),
        true
      ).length;
      this.sourceCount.update({
        children: this.props.countText
          .replace("{{current}}", u)
          .replace("{{total}}", d),
      });
    }
    _updateTargetCount() {
      if (
        this.targetTree.element.querySelectorAll("input:checked:enabled").length
      ) {
        this.removeTrigger.update({ type: "primary" });
      } else {
        this.removeTrigger.update({ type: null });
      }
      const u = this.targetTree.getCheckedNodeKeys().length;
      const d = this._getCheckedChildNodeKeys(
        this.targetTree.getChildNodes(),
        true
      ).length;
      this.targetCount.update({
        children: this.props.countText
          .replace("{{current}}", u)
          .replace("{{total}}", d),
      });
    }
    _disableNode(node) {
      node.checkboxRef.disable();
    }
    _enableNode(node) {
      node.checkboxRef.enable();
    }
    _hideNode(node) {
      node.element.classList.add("s-hidden");
    }
    _showNode(node) {
      node.element.classList.remove("s-hidden");
    }
    _processChecked(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const node = this.sourceTree.getNode(nodes[i]);
        if (!node.isChecked()) {
          continue;
        } // 
        if (
          !node.props.data.disabled &&
          !this.selectedKeys.includes(node.key)
        ) {
          this.selectedKeys.push(node.key);
          if (node.parentNode) {
            node.props.data.parentKey = node.parentNode.key;
          }
          this.selectData.push(node.props.data);
        } // 
        let hideFlag = true;
        if (node.props.data.children) {
          const cNodes = node.getChildNodes();
          for (let x = 0; x < cNodes.length; x++) {
            if (!cNodes[x].isChecked()) {
              hideFlag = false;
            }
          }
        }
        if (this.props.hideOnSelect && hideFlag) {
          this._hideNode(node);
        }
        this._disableNode(node);
      }
    }
    addNodes() {
      const nodes = this._getCheckedChildNodeKeys(
        this.sourceTree.getChildNodes()
      );
      this._processChecked(nodes);
      this.targetTree.update({ data: this.selectData });
      this._updateCountNum();
      const v = this.getValue();
      this.props.value = v;
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: v });
    }
    removeNodes() {
      const nodes = this._getCheckedChildNodeKeys(
        this.targetTree.getChildNodes()
      );
      if (!nodes.length) {
        return;
      }
      this._removeItem(nodes);
      this.selectData = this.targetTree.getData();
      this._updateCountNum();
      const v = this.getValue();
      this.props.value = v;
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: v });
    }
    _removeItem(nodes) {
      for (let i = 0; i < nodes.length; i++) {
        const nodeKey = nodes[i];
        this.selectedKeys = this.selectedKeys.filter((n) => {
          return n !== nodeKey;
        });
        const sourceItem = this.sourceTree.getNode(nodeKey);
        if (this.props.hideOnSelect) {
          this._showNode(sourceItem);
        }
        this._enableNode(sourceItem);
        sourceItem.uncheck();
        this.targetTree.getNode(nodeKey) &&
          this.targetTree.getNode(nodeKey).props &&
          this.targetTree.getNode(nodeKey).remove();
      }
    }
    checkAll(options) {
      this.sourceTree.checkAllNodes(
        Object.assign({ ignoreDisabled: true }, options)
      );
    }
    uncheckAll(options) {
      this.sourceTree.uncheckAllNodes(
        Object.assign({ ignoreDisabled: true }, options)
      );
    }
    disable() {
      this._refreshFlag = true;
      this.update({ disabled: true });
    }
    enable() {
      this._refreshFlag = true;
      this.update({ disabled: false });
    }
    clear() {
      this.checkAllBtn.update({ text: this.props.selectAllText });
      this.props.value = null;
      const nodes = this._getCheckedChildNodeKeys(
        this.targetTree.getChildNodes(),
        true
      );
      if (!nodes.length) {
        return;
      }
      this._removeItem(nodes);
      this.selectData = [];
      this._updateCountNum();
      this.props.onChange &&
        this._callHandler(this.props.onChange, { newValue: this.getValue() });
    }
    getValue() {
      const keys = this._getCheckedChildNodeKeys(
        this.targetTree.getChildNodes(),
        true
      );
      if (!keys || !keys.length) {
        return null;
      }
      return keys;
    }
  }
  Transfer.defaults = {
    data: [],
    value: null,
    hideOnSelect: false, // 
    footerRender: null, // pagination: false,
    itemRender: null,
    showSearch: false,
    onChange: null,
    height: 240, // onSearch: null,
    // onScroll: null,
    displayAsTree: false,
    dataFields: {
      key: "key",
      text: "text",
      children: "children",
      parentKey: "parentKey",
    },
    selectAllText: "",
    clearText: "",
    deselectAllText: "",
    countText: `{{current}}/{{total}}`,
  };
  Component.register(Transfer);
  class TreeSelectPopup extends Popup {
    constructor(props, ...mixins) {
      const defaults = { animate: true };
      super(Component.extendProps(defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.selectControl = this.opener.parent.parent;
    }
    _config() {
      const that = this;
      const { nodeSelectable, nodeCheckable } = that.props;
      const {
        searchable,
        options,
        treeDataFields,
        flatOptions,
        multiple,
        initExpandLevel,
        popupWidth,
        extraTools,
      } = this.selectControl.props;
      let { maxPopupWidth } = this.selectControl.props;
      if (isNumeric(maxPopupWidth)) {
        maxPopupWidth = `${maxPopupWidth}px`;
      }
      let w = `${this.selectControl.control.offsetWidth()}px`;
      if (isNumeric(popupWidth)) {
        w = `${popupWidth}px`;
      } else if (popupWidth === "auto") {
        w = "auto";
      }
      this.setProps({
        attrs: {
          style: {
            width: w,
            maxWidth:
              maxPopupWidth || `${this.selectControl.control.offsetWidth()}px`,
          },
        },
        children: {
          component: Layout,
          header: searchable
            ? {
                children: {
                  component: Textbox,
                  placeholder: searchable.placeholder,
                  _created: (inst) => {
                    this.selectControl.searchBox = inst;
                  },
                  onValueChange: ({ newValue }) => {
                    this.timer && clearTimeout(this.timer);
                    this.timer = setTimeout(() => {
                      const loading = new nomui.Loading({
                        container: this.selectControl.tree.parent,
                      });
                      const result = searchable.filter({
                        inputValue: newValue,
                        options: options,
                        sender: this.selectControl,
                      });
                      if (result && result.then) {
                        return result
                          .then((value) => {
                            this.selectControl.tree.update({
                              initExpandLevel: newValue ? -1 : initExpandLevel, // 
                              data: value,
                            }); //  optionsMap
                            this.selectControl.getOptionsMap();
                            loading && loading.remove();
                          })
                          .catch(() => {
                            loading && loading.remove();
                          });
                      }
                      loading && loading.remove();
                      result &&
                        this.selectControl.tree.update({
                          initExpandLevel: newValue ? -1 : initExpandLevel, // 
                          data: result,
                        });
                    }, 300);
                  },
                },
              }
            : null,
          body: {
            children: {
              component: "Tree",
              expandable: { byIndicator: true },
              data: clone(options),
              dataFields: treeDataFields,
              flatData: flatOptions,
              multiple,
              nodeSelectable,
              nodeCheckable,
              initExpandLevel,
              _created: function () {
                that.selectControl.tree = this;
              },
            },
          },
          footer: extraTools
            ? {
                classes: { "nom-tree-select-popup-extra-tools": true },
                children: isFunction(extraTools)
                  ? extraTools({ popup: this, inst: this.selectControl })
                  : extraTools,
              }
            : false,
        },
      });
      super._config();
    }
    animateHide() {
      if (!this.element) return false;
      let animateName;
      if (this.element.getAttribute("offset-y") !== "0") {
        animateName = "nom-tree-select-animate-bottom-hide";
      } else {
        animateName = "nom-tree-select-animate-top-hide";
      }
      this.addClass(animateName);
      setTimeout(() => {
        if (!this.element) return false;
        this.hide();
        this.removeClass(animateName);
      }, 160);
    }
    _rendered() {
      this.removeClass("nom-layer-animate-show");
      this.selectControl.props.animate &&
        this.props.animate &&
        this.animateInit();
      if (this.selectControl.props.animate && !this.props.animate) {
        this.props.animate = true;
      }
    }
    animateInit() {
      if (!this.element) return false;
      if (this.element.getAttribute("offset-y") !== "0") {
        this.addClass("nom-tree-select-animate-bottom-show");
      } else {
        this.addClass("nom-tree-select-animate-top-show");
      }
    }
    _show() {
      super._show();
      this.selectControl.searchBox && this.selectControl.searchBox.focus();
      this.removeClass("nom-layer-animate-show");
      this.selectControl.props.animate &&
        this.props.animate &&
        this.animateInit();
    }
  }
  Component.register(TreeSelectPopup);
  class TreeSelect extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(TreeSelect.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.items = [];
      this.tempValue = this.props.value;
    }
    _config() {
      if (this.props.treeCheckable) {
        this.props.multiple = true;
      }
      if (this.tree && this.props && this.props.options) {
        this.tree.update({ data: this.props.options });
      }
      this.getOptionsMap();
      const children = this._getContentChildren();
      this.setProps({ control: { disabled: this.props.disabled, children } });
      super._config();
    }
    _enable() {
      this.control.props.disabled = false;
    }
    _disable() {
      this.control.props.disabled = true;
    }
    _rendered() {
      this.popup = new TreeSelectPopup({
        trigger: this.control,
        nodeCheckable: this.props.multiple && this._getPopupNodeCheckable(),
        onShow: () => {
          if (this.props.disabled) {
            this.popup.hide();
          }
          if (!this.props.multiple) {
            this.tree.update({
              nodeSelectable: this._getPopupNodeSelectable(),
            });
          } else {
            this.tree.setCheckedNodeKeys(this.getValue());
            this._lastShowValue = this.getValue();
          }
        },
        onHide: () => {
          if (this.props.multiple && this.props.changeOnClose) {
            const _currentValue = this.getValue();
            if (!deepEqual(_currentValue, this._lastShowValue)) {
              this._onValueChange();
            }
          }
        },
      });
      this._valueChange({ newValue: this.currentValue });
    } //  {key: optionItem} 
    getOptionsMap() {
      this.optionMap = this.getList();
    } // 
    getList() {
      const { treeDataFields } = this.props;
      let { options } = this.props;
      const optionMap = {};
      function mapTree(data, parentKey) {
        return data.forEach(function (item) {
          const _fieldKey = treeDataFields.key;
          const _fieldText = treeDataFields.text;
          const _parentKey = treeDataFields.parentKey;
          const _children = treeDataFields.children;
          optionMap[item[_fieldKey]] = {
            key: item[_fieldKey],
            [_fieldKey]: item[_fieldKey],
            [_fieldText]: item[_fieldText],
            [_parentKey]: parentKey,
          };
          if (item[_children] && item[_children].length > 0) {
            mapTree(item[_children], item[_fieldKey]);
          }
        });
      } // popuptreeoptions
      if (this.tree) {
        options = this.tree.getData();
      }
      mapTree(options);
      return optionMap;
    }
    _getContentChildren() {
      const { showArrow, placeholder, allowClear } = this.props;
      const that = this;
      const children = [];
      this._normalizeSearchable(); // _content: 
      children.push({
        classes: { "nom-tree-select-content": true },
        _created() {
          that._content = this;
        },
        children: this._getContentBadges(),
      }); // placeholder
      if (isString(placeholder)) {
        children.push({
          _created() {
            that.placeholder = this;
          },
          classes: { "nom-tree-select-placeholder": true },
          children: placeholder,
        });
      } // 
      if (showArrow) {
        children.push({
          component: Icon,
          type: "down",
          classes: { "nom-tree-select-arrow": true },
        });
      }
      if (allowClear) {
        children.push({
          component: Icon,
          type: "times",
          classes: {
            "nom-tree-select-clear": true,
            "nom-field-clear-handler": true,
          },
          hidden: true,
          ref: (c) => {
            this.clearIcon = c;
          },
          onClick: (args) => {
            if (this.props.disabled) {
              return;
            }
            args.event && args.event.stopPropagation();
            this._setValue(null);
            this.props.onClear && this._callHandler(this.props.onClear);
            this.props.allowClear && this.clearIcon.hide(); // this.tree && this.props.multiple && this.tree.setCheckedNodeKeys(null)
            this.popup && this.popup.hide();
          },
        });
      }
      return children;
    }
    _normalizeSearchable() {
      const { searchable } = this.props;
      if (searchable) {
        this.setProps({
          searchable: Component.extendProps(
            {
              placeholder: null,
              filter: ({ inputValue, options }) => {
                if (!inputValue) return options;
                const {
                  key,
                  text,
                  parentKey,
                  children,
                } = this.props.treeDataFields; // 1. () filteredMap
                const reg = new RegExp(inputValue, "i");
                const filteredMap = new Map();
                ((target) =>
                  Object.keys(target).map((key) => [key, target[key]]))(
                  this.optionMap
                ).forEach(([optKey, optValue]) => {
                  //   optiontext
                  if (reg.test(optValue[text])) {
                    filteredMap.set(
                      optKey,
                      Object.assign({}, optValue, { __filterNode: true })
                    ); //  filteredMap 
                    let optParentKey = optValue[parentKey];
                    while (optParentKey) {
                      const parent = this.optionMap[optParentKey]; // parent (map) set
                      if (!filteredMap.get(optParentKey)) {
                        filteredMap.set(optParentKey, parent);
                      }
                      optParentKey = parent && parent[parentKey];
                    }
                  }
                }); //  filteredMap options()
                function getFileterOptions(list) {
                  const res = [];
                  list.forEach((opt) => {
                    const filterOpt = filteredMap.get(opt[key]);
                    if (filterOpt) {
                      const obj = Object.assign({}, opt);
                      if (filterOpt.__filterNode)
                        obj.__filterNode = filterOpt.__filterNode; // children
                      // , children
                      if (opt[children]) {
                        const _children = getFileterOptions(opt[children]);
                        obj[children] = _children.length
                          ? _children
                          : opt[children];
                      }
                      res.push(obj);
                    }
                  });
                  return res;
                }
                return getFileterOptions(options);
              },
            },
            searchable
          ),
        });
      }
    }
    _getContentBadges() {
      const { treeDataFields, maxTagCount, maxTagWidth } = this.props;
      if (!isNullish(this.currentValue) && !Array.isArray(this.currentValue)) {
        this.currentValue = [this.currentValue];
      }
      const { currentValue } = this;
      const items = [];
      const that = this;
      let num = 0;
      if (currentValue && currentValue.length) {
        num = currentValue.length - maxTagCount;
        currentValue.forEach((curValue, idx) => {
          const curOption = this.optionMap[curValue];
          if (curOption) {
            items.push({
              component: "Tag",
              type: "square",
              size: "xs",
              classes: {
                "nom-tree-select-tag-hidden":
                  maxTagCount > 0 && idx > maxTagCount,
              },
              attrs: { style: { cursor: "default" } },
              maxWidth: maxTagWidth,
              text: curOption[treeDataFields.text],
              key: curOption[treeDataFields.key],
              removable:
                that.props.multiple &&
                maxTagCount > 0 &&
                idx < maxTagCount &&
                function (param) {
                  that._setValue(
                    currentValue.filter(function (k) {
                      return k !== param;
                    })
                  );
                },
            });
          }
        });
      }
      if (maxTagCount > 0 && items.length > maxTagCount) {
        const overList = items.slice(maxTagCount, items.length);
        items[maxTagCount] = Object.assign({}, items[maxTagCount - 1], {
          classes: { "nom-tree-select-overtag-trigger": true },
          text: `+${num}`,
          removable: false,
          popup: {
            triggerAction: "hover",
            align: "top center",
            classes: { "nom-tree-select-extra-tags": true },
            children: {
              component: "List",
              gutter: "sm",
              itemDefaults: {
                key() {
                  return this.props[that.props.treeDataFields.key];
                },
                _config: function () {
                  this.setProps({
                    tag: "span",
                    onClick: (args) => {
                      args.event.stopPropagation();
                    },
                    attrs: {
                      title: this.props[that.props.treeDataFields.text],
                    },
                    children: [
                      {
                        tag: "span",
                        classes: { "nom-tree-select-item-content": true },
                        attrs: {
                          style: { maxWidth: `${that.props.maxTagWidth}px` },
                        },
                        children: this.props[that.props.treeDataFields.text],
                      },
                    ],
                  });
                },
              },
              items: overList,
            },
          },
        });
      }
      return items;
    } // nodeSelectable
    _getPopupNodeSelectable() {
      const { multiple, treeSelectable } = this.props;
      const { currentValue } = this;
      if (multiple) return false;
      return Component.extendProps(
        { onlyleaf: this.props.onlyleaf },
        treeSelectable,
        {
          selectedNodeKey: currentValue && currentValue[0],
          onNodeSelect: ({ nodeData }) => {
            this._setValue([nodeData.key]);
          },
        }
      );
    } // nodeCheckable
    _getPopupNodeCheckable() {
      const { multiple, treeCheckable } = this.props;
      const { currentValue } = this;
      if (!multiple && !treeCheckable) return false; // 
      return Component.extendProps(
        { onlyleaf: this.props.onlyleaf },
        treeCheckable,
        {
          checkedNodeKeys: currentValue,
          onCheckChange: () => {
            const checkedKeys = this.tree.getCheckedNodeKeys();
            this._setValue(checkedKeys, {
              triggerChange: !this.props.changeOnClose,
            });
          },
        }
      );
    }
    _getParentNode(node) {
      if (node.parentNode) {
        return this._getParentNode(node.parentNode);
      }
      return node;
    }
    _getCheckedChildNodes(nodes) {
      const checkedNodes = [];
      nodes.forEach((node) => {
        if (node.isChecked()) {
          checkedNodes.push(node.key);
        }
        if (node.getChildNodes().length) {
          Array.prototype.push.apply(
            checkedNodes,
            this._getCheckedChildNodes(node.getChildNodes())
          );
        }
      });
      return checkedNodes;
    }
    _setValue(value, options) {
      this.tempValue = value;
      if (options === false) {
        options = { triggerChange: false };
      } else {
        options = extend({ triggerChange: true }, options);
      }
      if (options.triggerChange) {
        this._onValueChange();
      } else {
        this.currentValue = this.tempValue;
        if (this.placeholder) {
          isNullish(this.currentValue)
            ? this.placeholder.show()
            : this.placeholder.hide();
        }
      }
      this._content.update({ children: this._getContentBadges() }); // : setValue
      if (this.props.multiple) {
        this.popup.selectControl.tree &&
          this.popup.selectControl.tree.setCheckedNodeKeys(value);
      } else {
        // : popup,onShow
        this.props.animate && this.popup.animateHide();
        !this.props.animate && this.popup.hide();
      }
    } // getValue
    _getValue(options) {
      const { valueOptions } = this.props;
      options = extend({ asArray: false }, valueOptions, options);
      if (isNullish(this.tempValue)) {
        return null;
      }
      if (Array.isArray(this.tempValue)) {
        if (this.props.multiple === false && options.asArray !== true) {
          return this.tempValue[0];
        }
        return this.tempValue;
      }
      if (options.asArray) {
        return [this.tempValue];
      }
      return this.tempValue;
    }
    getValueText() {
      const { treeDataFields } = this.props;
      const arr = [];
      const v = this.getValue();
      if (isString(v)) {
        arr.push(this.optionMap[v][treeDataFields.text]);
      } else if (Array.isArray(v)) {
        v.forEach((n) => {
          arr.push(this.optionMap[n][treeDataFields.text]);
        });
      }
      return arr.toString();
    }
    _valueChange(changed) {
      const { newValue } = changed; //  || null || undefined
      const isNewValueClear =
        (Array.isArray(newValue) && !newValue.length) || isNullish(newValue);
      if (this.props.allowClear) {
        // newValue ? icon : icon
        isNewValueClear ? this.clearIcon.hide() : this.clearIcon.show();
      }
      if (this.placeholder) {
        isNewValueClear ? this.placeholder.show() : this.placeholder.hide();
      }
    }
  }
  TreeSelect.defaults = {
    options: [],
    allowClear: false,
    placeholder: "", // treeselect
    treeSelectable: {},
    multiple: false, // 
    treeCheckable: false,
    maxTagWidth: 120,
    maxTagCount: -1,
    treeDataFields: {
      key: "value",
      text: "text",
      children: "children",
      parentKey: "parentKey",
    },
    valueOptions: { asArray: false },
    onlyleaf: false,
    showArrow: true,
    initExpandLevel: -1,
    popupWidth: null,
  };
  Component.register(TreeSelect);
  const DEFAULT_ACCEPT$1 =
    "image/*,application/msword,application/pdf,application/x-rar-compressed,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/vnd.ms-works,application/zip,audio/*,video/*,text/plain,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.wordprocessingml.template,application/vnd.ms-word.document.macroEnabled.12,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.openxmlformats-officedocument.spreadsheetml.template,application/vnd.ms-excel.sheet.macroEnabled.12,application/vnd.ms-excel.template.macroEnabled.12,application/vnd.openxmlformats-officedocument.presentationml.presentation,application/vnd.openxmlformats-officedocument.presentationml.template,application/vnd.openxmlformats-officedocument.presentationml.slideshow,application/vnd.ms-powerpoint.addin.macroEnabled.12,application/vnd.ms-powerpoint.presentation.macroEnabled.12,application/vnd.ms-powerpoint.slideshow.macroEnabled.12,application/csv";
  function getUUID$1() {
    return `nom-upload-${Math.random().toString().substr(2)}`;
  }
  function isBlobFile$1(file) {
    const ft = Object.prototype.toString.call(file);
    return ft === "[object File]" || ft === "[object Blob]";
  }
  function getFileFromList$1(file, fileList) {
    return fileList.find((e) => e.uuid === file.uuid);
  }
  function cloneFileWithInfo$1(file) {
    return Object.assign({}, file, {
      lastModified: file.lastModified,
      lastModifiedDate: file.lastModifiedDate,
      name: file.name,
      size: file.size,
      type: file.type,
      uuid: file.uuid,
      percent: 0,
      originFile: file,
    });
  }
  function getError$1(option, xhr) {
    const msg = `Can't ${option.method} ${option.action} ${xhr.status}`;
    const err = new Error(msg);
    return Object.assign({}, err, {
      status: xhr.status,
      method: option.method,
      url: option.action,
    });
  }
  function getBody$1(xhr) {
    const text = xhr.responseText || xhr.response;
    if (!text) {
      return text;
    }
    try {
      return JSON.parse(text);
    } catch (e) {
      return text;
    }
  }
  function upload$1(option) {
    const xhr = new XMLHttpRequest();
    if (option.onProgress && xhr.upload) {
      xhr.upload.onprogress = function progress(e) {
        if (e.total > 0) {
          e.percent = (e.loaded / e.total) * 100;
        }
        option.onProgress(e);
      };
    }
    const formData = new FormData();
    if (option.data) {
      Object.keys(option.data).forEach((key) => {
        const value = option.data[key];
        if (Array.isArray(value)) {
          value.forEach((item) => {
            formData.append(`${key}[]`, item);
          });
          return;
        }
        formData.append(key, option.data[key]);
      });
    }
    if (option.file instanceof Blob) {
      formData.append(option.filename, option.file, option.file.name);
    } else {
      formData.append(option.filename, option.file);
    }
    xhr.onerror = function error(e) {
      option.onError(e);
    };
    xhr.onload = function onload() {
      if (xhr.status < 200 || xhr.status >= 300) {
        return option.onError(getError$1(option, xhr), getBody$1(xhr));
      }
      return option.onSuccess(getBody$1(xhr), xhr);
    };
    xhr.open(option.method, option.action, true);
    if (option.withCredentials && "withCredentials" in xhr) {
      xhr.withCredentials = true;
    }
    const headers = option.headers || {};
    if (headers["X-Requested-With"] !== null) {
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    Object.keys(headers).forEach((header) => {
      if (headers[header] !== null) {
        xhr.setRequestHeader(header, headers[header]);
      }
    });
    xhr.send(formData);
    return {
      abort() {
        xhr.abort();
      },
    };
  }
  class Upload extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Upload.defaults, props), ...mixins);
      _defineProperty2(this, "_onFileDrop", (e) => {
        const { multiple } = this.props;
        e.preventDefault();
        if (e.type === "dragover") {
          return;
        }
        let files = [...e.dataTransfer.files];
        if (multiple === false) {
          files = files.slice(0, 1);
        }
        this._uploadFiles(files, this.fileList);
      });
    }
    _created() {
      this.reqs = {};
      this.failedFileList = [];
      this.unSupportedFileList = [];
      this.inQueueIds = [];
    }
    _config() {
      const that = this;
      const { disabled, accept, multiple, trigger, draggable } = this.props;
      this.fileList = this.props.fileList || this.props.defaultFileList;
      this.acceptList = accept ? this._getAcceptList() : "";
      let initializing = true;
      if (nomui.utils.isPromiseLike(that.fileList)) {
        that.fileList.then((res) => {
          initializing = false;
          that.fileList = res;
          that.props.onChange &&
            that._callHandler(that.props.onChange, {
              file: null,
              fileList: that.fileList,
            });
          if (!disabled && this.triggerRef) {
            that.triggerRef.enable();
          }
        });
      } else {
        initializing = false;
      }
      this._watchStatus();
      const defaults = {
        disabled: disabled || initializing, // disabled,
        ref: (c) => {
          that.triggerRef = c;
        },
        classes: { "nom-upload-trigger": true },
        attrs: {
          onclick() {
            !disabled && that._handleClick();
          },
          ondrop(e) {
            !disabled && draggable && that._onFileDrop(e);
          },
          ondragover(e) {
            e.preventDefault();
          },
        },
      };
      const defaultBtn = { component: "Button", text: this.props.uploadText };
      const triggerProps = Component.extendProps(
        defaults,
        trigger || defaultBtn
      );
      const folderAttrs = this.props.folder
        ? {
            webkitdirectory: true,
            mozdirectory: true,
            msdirectory: true,
            odirectory: true,
            directory: true,
          }
        : {};
      this.setProps({
        children: [
          {
            tag: "input",
            hidden: true,
            _created() {
              that.inputFile = this;
            },
            attrs: Object.assign(
              {
                type: "file",
                multiple: multiple,
                accept: accept || DEFAULT_ACCEPT$1,
                onchange: that._onChange.bind(that),
                onclick: (e) => {
                  e.stopPropagation();
                },
              },
              folderAttrs
            ),
          },
          triggerProps,
        ],
      });
    }
    getData() {
      return this.fileList;
    }
    disable() {
      this.triggerRef.disable();
    }
    enable() {
      this.triggerRef.enable();
    }
    pickFile() {
      this._handleClick();
    }
    _watchStatus(file) {
      if (file) {
        const currentStatus = file.status;
        const allList = this.fileList || [];
        const allStats = allList.map((n) => {
          return n.status;
        });
        const noUploading = !allStats.includes("uploading");
        if (currentStatus === "uploading") {
          this._showLoading();
        } else if (currentStatus === "done") {
          this._cancleLoading(noUploading);
        } else if (currentStatus === "error") {
          this._cancleLoading(noUploading);
          if (this.props.showErrorMsg) {
            new nomui.Message({
              content:
                isString(file.response) && file.response.length
                  ? file.response
                  : this.props.uploadFailText,
              type: "error",
            });
          }
        }
      } else {
        this._cancleLoading(true);
      }
    }
    _showLoading() {
      if (!this.loading) {
        this.loading = new nomui.Loading({ container: this.triggerRef });
      }
    }
    _cancleLoading(flag) {
      if (flag && this.loading) {
        this.loading.remove();
        this.loading = null;
      }
    }
    _getAcceptList() {
      if (this.props.accept) {
        return this.props.accept
          .replace("image/*", ".jpg,.png,.gif,.jpeg,.jp2,.jpe,.bmp,.tif,.tiff")
          .replace("video/*", ".3gpp,.mp2,.mp3,.mp4,.mpeg,.mpg")
          .replace("audio/*", ".3gpp,.ac3,.asf,.au,.mp2,.mp3,.mp4,.ogg");
      }
    }
    _checkType(file) {
      if (!this.props.accept) {
        return true;
      }
      if (!file || !file.name) {
        return false;
      }
      const { name } = file;
      const type = name.substring(name.lastIndexOf(".")).toLowerCase();
      if (this.acceptList.toLowerCase().includes(type)) {
        return true;
      }
      return false;
    }
    _onChange(e) {
      const { files } = e.target;
      const uploadedFiles = this.fileList;
      this._uploadFiles(files, uploadedFiles);
      if (this.inputFile && this.inputFile.element) {
        this.inputFile.element.value = "";
      }
    }
    _uploadFiles(files, uploadedFiles) {
      this.inQueueIds = []; // 
      let fileList = Array.from(files);
      const uploadedFileList = Array.from(uploadedFiles);
      fileList = fileList.map((e) => {
        if (!e.uuid) {
          e.uuid = getUUID$1();
        }
        e.uploadTime = new Date().getTime();
        this.inQueueIds.push(e.uuid);
        return e;
      });
      this.failedFileList = [];
      this.unSupportedFileList = [];
      this.props.onStart &&
        this._callHandler(this.props.onStart, {
          files: fileList,
          uploadedFiles,
        });
      fileList.forEach((file) => {
        this._upload(file, [...uploadedFileList, ...fileList]);
      });
    }
    _upload(file, fileList) {
      const beforeUpload = this.props.beforeUpload;
      if (!this._checkType(file)) {
        if (this.props.showErrorMsg) {
          new nomui.Alert({ title: this.props.unSupportedTypeText });
        }
        this.unSupportedFileList.push(file);
        this._callHandler(this.props.onTypeCheckFailed, {
          file,
          list: this.unSupportedFileList,
        });
        let status = "pending";
        if (
          this.fileList.filter((x) => {
            return x.status === "done" && this.inQueueIds.includes(x.uuid);
          }).length +
            this.failedFileList.length +
            this.unSupportedFileList.length ===
          this.inQueueIds.length
        ) {
          status = "done";
        }
        if (this.props.onChange) {
          this._callHandler(this.props.onChange, {
            file: file,
            fileList: [...this.fileList],
            failedFileList: this.failedFileList,
            unSupportedFileList: this.unSupportedFileList,
            status,
          });
        }
        return;
      }
      if (!beforeUpload) {
        Promise.resolve().then(() => this._post(file));
        return;
      }
      const before = beforeUpload(file, fileList);
      if (this.inputFile && this.inputFile.element)
        this.inputFile.element.value = "";
      if (nomui.utils.isPromiseLike(before)) {
        before.then((pFile) => {
          if (isBlobFile$1(pFile)) {
            this._post(pFile);
            return;
          }
          this._post(file);
        });
      } else if (before !== false) {
        Promise.resolve().then(() => {
          this._post(file);
        });
      }
    }
    _post(file) {
      if (!this.rendered) {
        return;
      }
      const that = this;
      const { props } = this;
      const { uuid } = file;
      new Promise((resolve) => {
        const actionRet = this.props.action;
        resolve(isFunction(actionRet) ? actionRet(file) : actionRet);
      }).then((action) => {
        const { data, method, headers, withCredentials } = props;
        const option = {
          action,
          file,
          filename: props.name,
          data,
          method,
          headers,
          withCredentials,
          onProgress: (e) => {
            that._onProgress(e, file);
          },
          onSuccess: (ret, xhr) => {
            that._onSuccess(ret, file, xhr);
          },
          onError: (err, ret) => {
            that._onError(err, ret, file);
            that.reqs[uuid] && delete that.reqs[uuid];
          },
        };
        this._onStart(file);
        this.reqs[uuid] = upload$1(option);
      });
    }
    _watchChange({ file, fileList }) {
      // 
      this.fileList = fileList;
      this._watchStatus(file);
      if (this.triggerRef) {
        const disableBtn = this.fileList.some((n) =>
          ["removing", "uploading"].includes(n.status)
        );
        if (!this.props.disabled) {
          disableBtn ? this.triggerRef.disable() : this.triggerRef.enable();
        }
      }
      let status = "pending";
      if (
        this.fileList.filter((x) => {
          return x.status === "done" && this.inQueueIds.includes(x.uuid);
        }).length +
          this.failedFileList.length +
          this.unSupportedFileList.length ===
        this.inQueueIds.length
      ) {
        status = "done";
      }
      if (this.props.onChange) {
        this._callHandler(this.props.onChange, {
          file,
          fileList: [...this.fileList],
          failedFileList: this.failedFileList,
          unSupportedFileList: this.unSupportedFileList,
          status,
        });
      }
    }
    _onStart(file) {
      const currentFile = cloneFileWithInfo$1(file);
      currentFile.status = "uploading"; // 
      const fileList = Array.from(this.fileList);
      const findIndex = fileList.findIndex((f) => f.uuid === currentFile.uuid);
      if (findIndex === -1) {
        fileList.push(currentFile);
      } else {
        fileList[findIndex] = currentFile;
      }
      this._watchChange({ file: currentFile, fileList: fileList });
    }
    _onProgress(e, file) {
      const currentFile = getFileFromList$1(file, this.fileList);
      if (!currentFile) {
        return;
      }
      currentFile.percent = e.percent;
      this._watchChange({
        event: e,
        file: currentFile,
        fileList: [...this.fileList],
      });
    }
    _onSuccess(response, file, xhr) {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e) {
        /* do nothing */
      }
      const currentFile = getFileFromList$1(file, this.fileList);
      if (!currentFile) {
        return;
      }
      currentFile.response = response;
      currentFile.status = "done";
      currentFile.xhr = xhr;
      this._watchChange({ file: currentFile, fileList: [...this.fileList] });
    }
    _onError(error, response, file) {
      const currentFile = getFileFromList$1(file, this.fileList);
      if (!currentFile) {
        return;
      }
      this.fileList = this.fileList.filter((n) => {
        return n.uuid !== file.uuid;
      });
      currentFile.error = error;
      currentFile.status = "error";
      currentFile.response = response;
      if (
        this.failedFileList.findIndex((x) => {
          return x.uuid === file.uuid;
        }) === -1
      ) {
        this.failedFileList.push(Object.assign({}, currentFile, { response }));
      }
      this._watchChange({ file: currentFile, fileList: [...this.fileList] });
    }
    _handleClick() {
      if (this.inputFile) {
        this.inputFile.element.click();
      }
    }
  }
  Upload.defaults = {
    reference: "body",
    action: "",
    disabled: false,
    beforeUpload: null,
    trigger: null, // 
    draggable: false, // 
    defaultFileList: [], // 
    multiple: false,
    folder: false,
    name: "file",
    data: {}, // request option
    method: "post",
    headers: {},
    withCredentials: false,
    onChange: null,
    onStart: null,
    uploadText: "",
    uploadFailText: "",
    showErrorMsg: true,
    onTypeCheckFailed: null,
    unSupportedTypeText: "",
  };
  Component.register(Upload);
  const DEFAULT_ACCEPT =
    "image/*,application/msword,application/pdf,application/x-rar-compressed,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/vnd.ms-works,application/zip,audio/*,video/*,text/plain,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.wordprocessingml.template,application/vnd.ms-word.document.macroEnabled.12,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.openxmlformats-officedocument.spreadsheetml.template,application/vnd.ms-excel.sheet.macroEnabled.12,application/vnd.ms-excel.template.macroEnabled.12,application/vnd.openxmlformats-officedocument.presentationml.presentation,application/vnd.openxmlformats-officedocument.presentationml.template,application/vnd.openxmlformats-officedocument.presentationml.slideshow,application/vnd.ms-powerpoint.addin.macroEnabled.12,application/vnd.ms-powerpoint.presentation.macroEnabled.12,application/vnd.ms-powerpoint.slideshow.macroEnabled.12,application/csv";
  function getUUID() {
    return `nom-upload-${Math.random().toString().substr(2)}`;
  } // export function getDate(timestamp) {
  //   if (isNumeric(timestamp) && POSITIVE_INTEGER.test(timestamp.toString())) {
  //     const date = new Date(timestamp)
  //     const month = date.getMonth() + 1
  //     const day = date.getDate()
  //     return `${date.getFullYear()}-${month > 9 ? month : `0${month}`}-${day > 9 ? day : `0${day}`}`
  //   }
  //   return null
  // }
  function isValidDate(date) {
    if (date === null || date === undefined) return null;
    let _date = date;
    if (!isDate(_date)) {
      _date = new Date(_date);
    }
    return !Number.isNaN(_date.getTime());
  }
  function getDate(d, format = "yyyy-MM-dd") {
    if (!isValidDate(d)) return null;
    const _date = isDate(d) ? d : new Date(d); // return isString(d) ? formatDate(d, format) : d.format(format)
    return _date.format(format);
  }
  function getFileSize(number) {
    if (!isNumeric(number)) {
      return "NA bytes";
    }
    if (number < 1024) {
      return `${number} bytes`;
    }
    if (number > 1024 && number < 1048576) {
      return `${(number / 1024).toFixed(2)} KB`;
    }
    if (number > 1048576) {
      return `${(number / 1048576).toFixed(2)} MB`;
    }
  }
  function isPromiseLike(promiseLike) {
    return (
      promiseLike !== null &&
      (typeof promiseLike === "object" || typeof promiseLike === "function") &&
      typeof promiseLike.then === "function"
    );
  }
  function isBlobFile(file) {
    const ft = Object.prototype.toString.call(file);
    return ft === "[object File]" || ft === "[object Blob]";
  }
  function getFileFromList(file, fileList) {
    return fileList.find((e) => e.uuid === file.uuid);
  }
  function cloneFileWithInfo(file) {
    return Object.assign({}, file, {
      lastModified: file.lastModified,
      lastModifiedDate: file.lastModifiedDate,
      name: file.name,
      size: file.size,
      type: file.type,
      uuid: file.uuid,
      percent: 0,
      originFile: file,
    });
  }
  function removeFile(file, fileList) {
    const remains = fileList.filter((item) => item.uuid !== file.uuid);
    if (remains.lenth === fileList.length) {
      return null;
    }
    return remains;
  }
  class FileItem extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(FileItem.defaults, props), ...mixins);
    }
    _created() {
      this._uploader = this.parent.parent.parent.parent;
    }
    _config() {
      const that = this;
      const {
        file,
        onRemove,
        allowUpdate,
        extraAction,
        customizeInfo,
      } = this.props;
      const { uuid, status } = file;
      const _info = isFunction(customizeInfo)
        ? customizeInfo(file)
        : this._handleDefaultCustomizeInfo(file);
      if (uuid) {
        let imgDisplay = {};
        if (status === "error") {
          imgDisplay = {
            children: [
              {
                component: "Icon",
                type: "file-error",
                classes: { "file-img": true },
              },
            ],
          };
        } else {
          imgDisplay =
            status === "done"
              ? this.renderUploadedFile(file)
              : {
                  children: [
                    {
                      component: "Icon",
                      type: "loading",
                      classes: { "file-img": true },
                    },
                  ],
                };
        }
        const actions = [];
        if (onRemove) {
          actions.push({
            tag: "a",
            children: onRemove.text || this._uploader.props.removeText,
            attrs: {
              href: "javascript:void(0)",
              onclick: (e) => {
                e.preventDefault();
                status !== "removing" &&
                  onRemove.action({ sender: that._uploader, file });
              },
            },
          });
        }
        if (allowUpdate) {
          actions.push({
            tag: "a",
            children: this._uploader.props.updateText,
            onClick() {
              that._uploader._handleUpdate({ file });
            },
          });
        }
        if (Array.isArray(extraAction) && extraAction.length > 0) {
          extraAction.forEach(({ text, action }) => {
            const children = isFunction(text) ? text(file) : text;
            if (!isNullish(children)) {
              actions.push({
                tag: "a",
                children,
                attrs: {
                  href: "javascript:void(0)",
                  onclick: (e) => {
                    e.preventDefault();
                    isFunction(action) &&
                      action({ sender: that._uploader, file });
                  },
                },
              });
            }
          });
        }
        this.setProps({
          tag: "div",
          children: [
            {
              tag: "div",
              _config() {
                this.setProps({ children: [Object.assign({}, imgDisplay)] });
                this.setProps({ classes: { "upload-img-container": true } });
              },
            },
            {
              tag: "div",
              _config() {
                this.setProps({
                  children: [
                    {
                      // tag: 'div',
                      _config() {
                        this.setProps({ children: _info });
                      },
                    },
                    {
                      // tag: 'div',
                      _config() {
                        this.setProps({
                          classes: {
                            "upload-opt-btn": true,
                            "upload-opt-removing": status === "removing",
                          },
                        });
                      },
                      children: actions,
                    },
                  ],
                });
                this.setProps({ classes: { "upload-info-container": true } });
              },
            },
          ],
        });
        this.setProps({ classes: { "u-flex-row": true } });
      }
    }
    renderUploadedFile(file) {
      // const { name } = file
      const renderer = this.props.renderer;
      if (isFunction(renderer)) {
        return Object.assign({}, renderer(file), {
          classes: { "file-img": true },
        });
      }
      return { component: "Icon", type: "file", classes: { "file-img": true } };
    }
    _handleDefaultCustomizeInfo(file) {
      if (!file) return null;
      const { onPreview } = this._uploader.props;
      const { name, size, uploadTime } = file;
      return [
        {
          tag: "span",
          children: [
            {
              tag: "a",
              children: name,
              classes: { "upload-file-name": true },
              onClick: ({ sender }) => {
                isFunction(onPreview) && onPreview({ sender, file });
              },
            },
          ],
        },
        { tag: "span", children: getFileSize(size) },
        {
          tag: "span",
          children: `${this._uploader.props.updateTimeText} : ${
            getDate(uploadTime) ? getDate(uploadTime) : "NA"
          }`,
          classes: { "upload-file-update": true, "u-border-left ": true },
        },
      ];
    }
  }
  FileItem.defaults = { disabled: false, file: null };
  class FileList extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(FileList.defaults, props), ...mixins);
    }
    _created() {
      super._created();
      this.uploaderControl = this.parent.parent.parent.control;
      this.uploaderControl.list = this;
    }
    _config() {
      const {
        files,
        onRemove,
        allowUpdate,
        extraAction,
        initializing,
        renderer,
        customizeInfo,
      } = this.props;
      const children = [];
      if (Array.isArray(files) && files.length > 0) {
        files.forEach((file) => {
          children.push({
            component: FileItem,
            file,
            onRemove,
            allowUpdate,
            extraAction,
            renderer,
            customizeInfo,
          });
        });
      }
      if (initializing) {
        this.setProps({
          tag: "div",
          children: {
            component: "Icon",
            type: "loading",
            classes: { "file-img": true },
          },
        });
      } else {
        this.setProps({ tag: "div", children });
      }
    }
  }
  FileList.defaults = { disabled: false, files: null };
  function getError(option, xhr) {
    const msg = `Can't ${option.method} ${option.action} ${xhr.status}`;
    const err = new Error(msg);
    return Object.assign({}, err, {
      status: xhr.status,
      method: option.method,
      url: option.action,
    });
  }
  function getBody(xhr) {
    const text = xhr.responseText || xhr.response;
    if (!text) {
      return text;
    }
    try {
      return JSON.parse(text);
    } catch (e) {
      return text;
    }
  }
  function upload(option) {
    const xhr = new XMLHttpRequest();
    if (option.onProgress && xhr.upload) {
      xhr.upload.onprogress = function progress(e) {
        if (e.total > 0) {
          e.percent = (e.loaded / e.total) * 100;
        }
        option.onProgress(e);
      };
    }
    const formData = new FormData();
    if (option.data) {
      Object.keys(option.data).forEach((key) => {
        const value = option.data[key];
        if (Array.isArray(value)) {
          value.forEach((item) => {
            formData.append(`${key}[]`, item);
          });
          return;
        }
        formData.append(key, option.data[key]);
      });
    }
    if (option.file instanceof Blob) {
      formData.append(option.filename, option.file, option.file.name);
    } else {
      formData.append(option.filename, option.file);
    }
    xhr.onerror = function error(e) {
      option.onError(e);
    };
    xhr.onload = function onload() {
      if (xhr.status < 200 || xhr.status >= 300) {
        return option.onError(getError(option, xhr), getBody(xhr));
      }
      return option.onSuccess(getBody(xhr), xhr);
    };
    xhr.open(option.method, option.action, true);
    if (option.withCredentials && "withCredentials" in xhr) {
      xhr.withCredentials = true;
    }
    const headers = option.headers || {};
    if (headers["X-Requested-With"] !== null) {
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    Object.keys(headers).forEach((header) => {
      if (headers[header] !== null) {
        xhr.setRequestHeader(header, headers[header]);
      }
    });
    xhr.send(formData);
    return {
      abort() {
        xhr.abort();
      },
    };
  }
  class Uploader extends Field {
    constructor(props, ...mixins) {
      super(Component.extendProps(Uploader.defaults, props), ...mixins);
      this.reqs = {};
      this.onChange.bind(this);
      this._changeUploadMode.bind(this);
    }
    _created() {
      // this.fileList = this.props.fileList || this.props.defaultFileList
      this._updateFile = null;
      this._updateFileIcon = [];
      super._created();
    }
    _config() {
      const that = this; // const { disabled, accept, button: cButton, multiple, files } = this.props;
      const {
        disabled,
        accept,
        button,
        multiple,
        extraAction,
        display,
        allowUpdate,
        onRemove,
        renderer,
        customizeInfo,
        actionRender,
        showList,
      } = this.props;
      const customTrigger = actionRender || button;
      this.fileList = this.props.fileList || this.props.defaultFileList;
      if (this.fileList && this.fileList.length > 0) {
        this.fileList = showList ? this.fileList : this.fileList.slice(-1);
      }
      this.acceptList = accept ? this.getAcceptList() : "";
      let initializing = true;
      if (isPromiseLike(that.fileList)) {
        that.fileList.then((fs) => {
          initializing = false;
          that.fileList = fs;
          if (!disabled && this.customTrigger) {
            that.customTrigger.enable();
          }
          that.list &&
            that.list.update({ initializing: false, files: this.fileList });
        });
      } else {
        initializing = false;
      }
      const children = [];
      const defaultButtonProps = {
        component: "Button",
        text: this.props.uploadText,
        icon: "upload",
      };
      const inputUploader = {
        tag: "input",
        hidden: true,
        _created() {
          that.inputFile = this;
        },
        attrs: {
          type: "file",
          multiple: multiple,
          accept: accept || DEFAULT_ACCEPT,
          onchange: that._onChange.bind(that),
          onclick: (e) => {
            e.stopPropagation();
          },
        },
      };
      children.push(inputUploader);
      let triggerButton = customTrigger;
      if (!triggerButton && triggerButton !== false)
        triggerButton = defaultButtonProps;
      const defaults = {
        disabled: disabled || initializing, // disabled,
        ref: (c) => {
          that.customTrigger = c;
        },
        attrs: {
          onclick() {
            that._handleClick();
          },
          onKeyDown(e) {
            that._onKeyDowne(e);
          },
        },
      };
      if (triggerButton !== false) {
        if (isFunction(customTrigger)) {
          triggerButton = customTrigger();
        }
        triggerButton = Component.extendProps(defaults, triggerButton);
        children.push(triggerButton);
      }
      if (showList) {
        if (display) {
          if (initializing || (this.fileList && this.fileList.length > 0)) {
            children.push({
              component: FileList,
              classes: { "nom-file-list-only": triggerButton === false },
              ref: (c) => {
                that.list = c;
              },
              initializing,
              files:
                display === "replace" && !multiple
                  ? this.fileList.slice(-1)
                  : this.fileList,
              renderer,
              onRemove:
                onRemove &&
                isFunction(onRemove.action) &&
                Object.assign({}, onRemove, {
                  action: that.handleRemove.bind(that),
                }),
              allowUpdate,
              extraAction,
              customizeInfo,
            });
          }
        }
      } else if (this.fileList && this.fileList.length) {
        if (
          this.fileList[0].status === "uploading" &&
          !this._updateFileIcon.includes("loading")
        ) {
          triggerButton.children.push({
            component: "Icon",
            type: "loading",
            classes: { "file-loading-img": true },
          });
          this._updateFileIcon.push("loading");
        } else if (
          this.fileList[0].status === "done" &&
          !this._updateFileIcon.includes("close-circle")
        ) {
          triggerButton.tooltip = this.props.reUploadText;
          this._updateFileIcon.push("close-circle");
          this._updateFileIcon.splice(this._updateFileIcon.indexOf("error"), 1);
          this.deleteIcon("loading", triggerButton);
        } else if (
          this.fileList[0].status === "error" &&
          !this._updateFileIcon.includes("error")
        ) {
          this.deleteIcon("loading", triggerButton);
          new nomui.Message({
            content: this.props.uploadFailText,
            type: "error",
          });
        }
        if (this.fileList[0].status !== "uploading") {
          this._updateFileIcon.splice(
            this._updateFileIcon.indexOf("loading"),
            1
          );
        }
      } else {
        this.deleteIcon("close-circle", triggerButton);
      }
      this.setProps({ control: { children } });
      super._config();
    }
    deleteIcon(name, file) {
      this._updateFileIcon.splice(this._updateFileIcon.indexOf(name), 1);
      const index = file.children.findIndex(
        (element) => element && element.type === name
      );
      if (index > 0) file.children.splice(index, 1);
    }
    getAcceptList() {
      if (this.props.accept) {
        return this.props.accept
          .replace("image/*", ".jpg,.png,.gif,.jpeg,.jp2,.jpe,.bmp,.tif,.tiff")
          .replace("video/*", ".3gpp,.mp2,.mp3,.mp4,.mpeg,.mpg")
          .replace("audio/*", ".3gpp,.ac3,.asf,.au,.mp2,.mp3,.mp4,.ogg");
      }
    }
    checkType(file) {
      if (!this.props.accept) {
        return true;
      }
      if (!file || !file.name) {
        return false;
      }
      const { name } = file;
      const type = name.substring(name.lastIndexOf(".")).toLowerCase();
      if (this.acceptList.toLowerCase().includes(type)) {
        return true;
      }
      return false;
    }
    _onChange(e) {
      const { files } = e.target;
      const uploadedFiles = this.fileList;
      this.uploadFiles(files, uploadedFiles);
    }
    uploadFiles(files, uploadedFiles) {
      // 
      let fileList = Array.from(files);
      const uploadedFileList = Array.from(uploadedFiles);
      if (this._updateFile) {
        fileList = fileList.map((e) => {
          e.uuid = this._updateFile;
          e.uploadTime = new Date().getTime();
          return e;
        });
        uploadedFiles.map((file) => {
          if (file.uuid === this._updateFile) {
            const f = fileList[0] || [];
            f.uuid = this._updateFile;
            return f;
          }
          return file;
        });
      } else {
        fileList = fileList.map((e) => {
          if (!e.uuid) {
            e.uuid = getUUID();
          }
          e.uploadTime = new Date().getTime();
          return e;
        });
      }
      fileList.forEach((file) => {
        this.upload(file, [...uploadedFileList, ...fileList]);
      });
    }
    upload(file, fileList) {
      const beforeUpload = this.props.beforeUpload;
      if (!this.checkType(file)) {
        new nomui.Alert({ title: this.props.unSupportedTypeText });
        return;
      }
      if (!beforeUpload) {
        Promise.resolve().then(() => this.post(file));
        return;
      }
      const before = beforeUpload(file, fileList);
      if (this.inputFile && this.inputFile.element)
        this.inputFile.element.value = "";
      if (isPromiseLike(before)) {
        before.then((pFile) => {
          if (isBlobFile(pFile)) {
            this.post(pFile);
            return;
          }
          this.post(file);
        });
      } else if (before !== false) {
        Promise.resolve().then(() => {
          this.post(file);
        });
      }
    }
    post(file) {
      if (!this.rendered) {
        return;
      }
      const that = this;
      const { props } = this;
      new Promise((resolve) => {
        const actionRet = this.props.action;
        resolve(isFunction(actionRet) ? actionRet(file) : actionRet);
      }).then((action) => {
        const { data, method, headers, withCredentials } = props;
        const option = {
          action,
          data,
          file,
          filename: props.fileFieldName || props.name,
          method,
          headers,
          withCredentials,
          onProgress: (e) => {
            that.onProgress(e, file);
          },
          onSuccess: (ret, xhr) => {
            that.onSuccess(ret, file, xhr);
          },
          onError: (err, ret) => {
            that.onError(err, ret, file);
          },
        };
        this.onStart(file);
        this.reqs[file.uuid] = upload(option);
        this._updateFile = null;
        this._changeUploadMode();
      });
    }
    onChange(info) {
      // 
      this.fileList = info.fileList;
      const { onChange: onChangeProp } = this.props;
      this.update({ fileList: [...info.fileList] });
      if (this.customTrigger) {
        const disableBtn = this.fileList.some((file) =>
          ["removing", "uploading", "updating"].includes(file.status)
        );
        if (!this.props.disabled) {
          disableBtn
            ? this.customTrigger.disable()
            : this.customTrigger.enable();
        }
      }
      if (onChangeProp) {
        onChangeProp(
          Object.assign({}, info, {
            sender: this,
            fileList: [...this.fileList],
          })
        );
      }
    }
    onStart(file) {
      const uploadFile = cloneFileWithInfo(file);
      uploadFile.status = this._updateFile ? "updating" : "uploading"; // 
      const nextFileList = Array.from(this.fileList);
      const findIndex = nextFileList.findIndex(
        (f) => f.uuid === uploadFile.uuid
      );
      if (findIndex === -1) {
        nextFileList.push(uploadFile);
      } else {
        nextFileList[findIndex] = uploadFile;
      }
      this.onChange({ file: uploadFile, fileList: nextFileList });
    }
    onProgress(e, file) {
      const uploadingFile = getFileFromList(file, this.fileList);
      if (!uploadingFile) {
        return;
      }
      uploadingFile.percent = e.percent;
      this.onChange({
        event: e,
        file: uploadingFile,
        fileList: [...this.fileList],
      });
    }
    onSuccess(response, file, xhr) {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e) {
        /* do nothing */
      }
      const uploadFile = getFileFromList(file, this.fileList);
      if (!uploadFile) {
        return;
      }
      uploadFile.response = response;
      uploadFile.status = "done";
      uploadFile.xhr = xhr;
      this.onChange({ file: uploadFile, fileList: [...this.fileList] });
      this._onValueChange();
    }
    onError(error, response, file) {
      const uploadFile = getFileFromList(file, this.fileList);
      if (!uploadFile) {
        return;
      }
      uploadFile.error = error;
      uploadFile.status = "error";
      uploadFile.response = response;
      this.onChange({ file: uploadFile, fileList: [...this.fileList] });
    }
    handleRemove({ sender, file }) {
      const {
        onRemove: { action },
      } = this.props; // removing
      file.status = "removing";
      this.fileList = this.fileList.map((f) =>
        f.uuid === file.uuid ? Object.assign({}, f, { status: "removing" }) : f
      );
      this.onChange({ file, fileList: this.fileList });
      Promise.resolve(
        isFunction(action) ? action({ sender, file }) : action
      ).then((ret) => {
        if (ret === false) {
          return;
        }
        const remainsFileList = removeFile(file, this.fileList);
        if (remainsFileList) {
          file.status = "removed";
          this.fileList = remainsFileList;
          if (this.reqs[file.uuid]) {
            this.reqs[file.uuid].abort();
            delete this.reqs[file.uuid];
          }
        }
        this.onChange({ file, fileList: remainsFileList });
        this._onValueChange();
      });
    }
    _handleUpdate({ file }) {
      if (file && file.uuid) {
        this._updateFile = file.uuid;
      }
      this._changeUploadMode();
      this._handleClick(file);
    }
    _changeUploadMode() {
      if (this.inputFile && this.inputFile.element) {
        if (this._updateFile) {
          this.inputFile.element.multiple = false;
        } else {
          this.inputFile.element.multiple = this.props.multiple;
        }
      }
    }
    _handleClick() {
      if (this.inputFile) {
        this.inputFile.element.click();
      }
    }
    _onkeyDown(e) {
      if (e.eky === "Enter") {
        this._handleClick();
      }
    }
    triggerEdit() {
      return false;
    }
    _getValue() {
      const { fileResponseAsValue, multiple } = this.props;
      if (fileResponseAsValue === true) {
        if (isNotEmptyArray(this.fileList)) {
          if (!multiple) {
            return this.fileList[0].response;
          }
          return this.fileList.map((item) => item.response);
        }
      }
      const _val = isNotEmptyArray(this.fileList)
        ? this.fileList.filter(({ status }) => status === "done")
        : null;
      return isNotEmptyArray(_val) ? _val : null;
    }
    focus() {
      this.element.scrollIntoView();
      super.focus();
    }
  }
  Uploader.defaults = {
    // 
    action: "",
    disabled: false,
    beforeUpload: null,
    button: null,
    defaultFileList: [],
    multiple: false,
    name: "file",
    fileFieldName: "file",
    display: true,
    data: {}, // request option
    method: "post",
    headers: {},
    withCredentials: false,
    allowUpdate: false,
    onRemove: null,
    renderer: null,
    extraAction: [],
    customizeInfo: null,
    actionRender: null,
    showList: true,
    uploadText: "",
    uploadFailText: "",
    reUploadText: "",
    unSupportedTypeText: "",
    removeText: "",
    updateText: "",
    updateTimeText: "",
    fileResponseAsValue: false,
  };
  Component.register(Uploader);
  const FontGap = 3;
  const prepareCanvas = (width, height, ratio = 1) => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const realWidth = width * ratio;
    const realHeight = height * ratio;
    canvas.setAttribute("width", `${realWidth}px`);
    canvas.setAttribute("height", `${realHeight}px`);
    ctx.save();
    return [ctx, canvas, realWidth, realHeight];
  };
  /**
   * Get the clips of text content.
   * This is a lazy hook function since SSR no need this
   */ const getClips = ({
    content,
    rotate,
    ratio = 1,
    width,
    height,
    font,
    gap = 100,
  }) => {
    // ================= Text / Image =================
    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(
      width,
      height,
      ratio
    );
    if (content instanceof HTMLImageElement) {
      // Image
      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
    } else {
      // Text
      const {
        color,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        textAlign,
      } = font;
      const mergedFontSize = Number(fontSize) * ratio;
      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
      ctx.fillStyle = color;
      ctx.textAlign = textAlign;
      ctx.textBaseline = "top";
      const contents = Array.isArray(content) ? content : [content];
      let filledTextX = contentWidth / 2;
      if (textAlign.toLowerCase() === "left") {
        filledTextX = 0;
      } else if (textAlign.toLowerCase() === "right") {
        filledTextX = contentWidth;
      }
      if (contents.length) {
        contents.forEach((item, index) => {
          ctx.fillText(
            item || "",
            filledTextX,
            index * (mergedFontSize + FontGap * ratio)
          );
        });
      }
    } // ==================== Rotate ====================
    const angle = (Math.PI / 180) * Number(rotate);
    const maxSize = Math.max(width, height);
    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio); // Copy from `ctx` and rotate
    rCtx.translate(realMaxSize / 2, realMaxSize / 2);
    rCtx.rotate(angle);
    if (contentWidth > 0 && contentHeight > 0) {
      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
    } // Get boundary of rotated text
    function getRotatePos(x, y) {
      const targetX = x * Math.cos(angle) - y * Math.sin(angle);
      const targetY = x * Math.sin(angle) + y * Math.cos(angle);
      return [targetX, targetY];
    }
    let left = 0;
    let right = 0;
    let top = 0;
    let bottom = 0;
    const halfWidth = contentWidth / 2;
    const halfHeight = contentHeight / 2;
    const points = [
      [0 - halfWidth, 0 - halfHeight],
      [0 + halfWidth, 0 - halfHeight],
      [0 + halfWidth, 0 + halfHeight],
      [0 - halfWidth, 0 + halfHeight],
    ];
    points.forEach(([x, y]) => {
      const [targetX, targetY] = getRotatePos(x, y);
      left = Math.min(left, targetX);
      right = Math.max(right, targetX);
      top = Math.min(top, targetY);
      bottom = Math.max(bottom, targetY);
    });
    const cutLeft = left + realMaxSize / 2;
    const cutTop = top + realMaxSize / 2;
    const cutWidth = right - left;
    const cutHeight = bottom - top; // ================ Fill Alternate ================
    const realGapX = gap * ratio;
    const realGapY = gap * ratio;
    const filledWidth = (cutWidth + realGapX) * 2;
    const filledHeight = cutHeight + realGapY;
    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
    function drawImg(targetX = 0, targetY = 0) {
      fCtx.drawImage(
        rCanvas,
        cutLeft,
        cutTop,
        cutWidth,
        cutHeight,
        targetX,
        targetY,
        cutWidth,
        cutHeight
      );
    }
    drawImg();
    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
  };
  class Watermark extends Component {
    constructor(props, ...mixins) {
      super(Component.extendProps(Watermark.defaults, props), ...mixins);
    }
    _created() {
      this.fontGap = 3;
    }
    _config() {
      const me = this;
      const { content } = this.props;
      this.setProps({
        children: [
          {
            classes: { "nom-watermark-mask": true },
            onCreated: ({ inst }) => {
              me.mask = inst;
            },
          },
          content && isFunction(content) ? content() : content,
        ],
      });
    }
    _rendered() {
      this.firstRender && this._initWatermark();
    }
    _initWatermark() {
      const { image, text } = this.props;
      if (image) {
        const img = new window.Image();
        img.src = image;
        img.onload = () => {
          this._drawCanvas(img);
        };
        img.onerror = () => {
          this._drawCanvas(text);
        };
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.src = image;
      } else {
        this._drawCanvas(text);
      }
    }
    _drawCanvas(item) {
      const { rotate, ratio, font, gap } = this.props;
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const [markWidth, markHeight] = this._getMarkSize(ctx);
      const result = getClips({
        content: item,
        rotate,
        ratio,
        width: markWidth,
        height: markHeight,
        font,
        gap,
      });
      setTimeout(() => {
        this.mask.element.style.backgroundImage = `url('${result[0]}')`;
      }, 0);
    }
    _getMarkSize(ctx) {
      const { image, text, font, width = 120, height = 60 } = this.props;
      const { fontSize, fontFamily } = font;
      let defaultWidth = width;
      let defaultHeight = height;
      if (!image && ctx.measureText) {
        ctx.font = `${Number(fontSize)}px ${fontFamily}`;
        const items = Array.isArray(text) ? text : [text];
        const sizes = items.map((item) => {
          const metrics = ctx.measureText(item);
          return [
            metrics.width,
            metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent,
          ];
        });
        defaultWidth = Math.ceil(Math.max(...sizes.map((size) => size[0])));
        defaultHeight =
          Math.ceil(Math.max(...sizes.map((size) => size[1]))) * items.length +
          (items.length - 1) * this.fontGap;
      }
      return [defaultWidth, defaultHeight];
    }
  }
  Watermark.defaults = {
    image: null,
    text: "",
    content: null,
    ratio: 1,
    rotate: -35,
    gap: 100,
    font: {
      color: "rgba(0,0,0,.15)",
      fontSize: 16,
      fontStyle: "normal",
      fontWeight: "normal",
      fontFamily: "sans-serif",
      textAlign: "center",
    },
  };
  Component.register(Watermark);
  /**
   * nomui
   * @param {install:(nomui)=>{}} plugin
   * @description plugininstall
   */ function use(plugin) {
    plugin.install(this);
  }
  exports.Alert = Alert;
  exports.Anchor = Anchor;
  exports.AnchorContent = AnchorContent;
  exports.App = App;
  exports.AutoComplete = AutoComplete;
  exports.Avatar = Avatar;
  exports.AvatarGroup = AvatarGroup;
  exports.BackTop = BackTop;
  exports.Badge = Badge;
  exports.Breadcrumb = Breadcrumb;
  exports.Button = Button;
  exports.Caption = Caption;
  exports.Carousel = Carousel;
  exports.Cascader = Cascader;
  exports.Checkbox = Checkbox;
  exports.CheckboxList = CheckboxList;
  exports.CheckboxTree = CheckboxTree;
  exports.Collapse = Collapse;
  exports.ColorPicker = ColorPicker;
  exports.Cols = Cols;
  exports.Component = Component;
  exports.Confirm = Confirm;
  exports.Container = Container;
  exports.Countdown = Countdown;
  exports.DataList = DataList;
  exports.DatePicker = DatePicker;
  exports.DateRangePicker = DateRangePicker;
  exports.Divider = Divider;
  exports.Drawer = Drawer;
  exports.Dropdown = Dropdown;
  exports.Ellipsis = Ellipsis;
  exports.Empty = Empty;
  exports.Field = Field;
  exports.Flex = Flex;
  exports.Form = Form;
  exports.Grid = Grid;
  exports.Group = Group;
  exports.GroupGrid = GroupGrid;
  exports.GroupList = GroupList;
  exports.GroupTree = GroupTree;
  exports.Icon = Icon;
  exports.IconPicker = IconPicker;
  exports.Image = Image;
  exports.Layer = Layer;
  exports.Layout = Layout;
  exports.List = List;
  exports.ListItemMixin = ListItemMixin;
  exports.ListSetter = ListSetter;
  exports.Loading = Loading;
  exports.MaskInfo = MaskInfo;
  exports.MaskInfoField = MaskInfoField;
  exports.Menu = Menu;
  exports.Message = Message;
  exports.Modal = Modal;
  exports.MultilineTextbox = MultilineTextbox;
  exports.Navbar = Navbar;
  exports.Notification = Notification;
  exports.NumberInput = NumberInput;
  exports.NumberSpinner = NumberSpinner;
  exports.Numberbox = Numberbox;
  exports.Pager = Pager;
  exports.Panel = Panel;
  exports.PartialDatePicker = PartialDatePicker;
  exports.PartialDateRangePicker = PartialDateRangePicker;
  exports.Password = Password;
  exports.Popconfirm = Popconfirm;
  exports.Popup = Popup;
  exports.Progress = Progress;
  exports.RadioList = RadioList;
  exports.Rate = Rate;
  exports.Result = Result;
  exports.Router = Router;
  exports.Rows = Rows;
  exports.RuleManager = RuleManager;
  exports.Scrollbar = Scrollbar;
  exports.Select = Select;
  exports.Skeleton = Skeleton;
  exports.SlideCaptcha = SlideCaptcha;
  exports.Slider = Slider;
  exports.Spinner = Spinner;
  exports.StaticText = StaticText;
  exports.Statistic = Statistic;
  exports.Steps = Steps;
  exports.Switch = Switch;
  exports.Table = Table;
  exports.Tabs = Tabs;
  exports.Tag = Tag;
  exports.Textbox = Textbox;
  exports.TimePicker = TimePicker;
  exports.TimeRangePicker = TimeRangePicker;
  exports.Timeline = Timeline;
  exports.Toolbar = Toolbar;
  exports.Tooltip = Tooltip;
  exports.Tour = Tour;
  exports.Transfer = Transfer;
  exports.Tree = Tree;
  exports.TreeSelect = TreeSelect;
  exports.Upload = Upload;
  exports.Uploader = Uploader;
  exports.Watermark = Watermark;
  exports.n = n$1;
  exports.use = use;
  exports.utils = index;
  Object.defineProperty(exports, "__esModule", { value: true });
});
